<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>tango.text.Util</title>
  <style type="text/css">
  .linescolumn > a { display: block; }
  td { vertical-align: top; }
  </style>
  <link href="html.css" rel="stylesheet" type="text/css">
</head>
<body>
<table><tr><td class="linescolumn"><a id="L1" href="#L1">1</a><a id="L2" href="#L2">2</a><a id="L3" href="#L3">3</a><a id="L4" href="#L4">4</a><a id="L5" href="#L5">5</a><a id="L6" href="#L6">6</a><a id="L7" href="#L7">7</a><a id="L8" href="#L8">8</a><a id="L9" href="#L9">9</a><a id="L10" href="#L10">10</a><a id="L11" href="#L11">11</a><a id="L12" href="#L12">12</a><a id="L13" href="#L13">13</a><a id="L14" href="#L14">14</a><a id="L15" href="#L15">15</a><a id="L16" href="#L16">16</a><a id="L17" href="#L17">17</a><a id="L18" href="#L18">18</a><a id="L19" href="#L19">19</a><a id="L20" href="#L20">20</a><a id="L21" href="#L21">21</a><a id="L22" href="#L22">22</a><a id="L23" href="#L23">23</a><a id="L24" href="#L24">24</a><a id="L25" href="#L25">25</a><a id="L26" href="#L26">26</a><a id="L27" href="#L27">27</a><a id="L28" href="#L28">28</a><a id="L29" href="#L29">29</a><a id="L30" href="#L30">30</a><a id="L31" href="#L31">31</a><a id="L32" href="#L32">32</a><a id="L33" href="#L33">33</a><a id="L34" href="#L34">34</a><a id="L35" href="#L35">35</a><a id="L36" href="#L36">36</a><a id="L37" href="#L37">37</a><a id="L38" href="#L38">38</a><a id="L39" href="#L39">39</a><a id="L40" href="#L40">40</a><a id="L41" href="#L41">41</a><a id="L42" href="#L42">42</a><a id="L43" href="#L43">43</a><a id="L44" href="#L44">44</a><a id="L45" href="#L45">45</a><a id="L46" href="#L46">46</a><a id="L47" href="#L47">47</a><a id="L48" href="#L48">48</a><a id="L49" href="#L49">49</a><a id="L50" href="#L50">50</a><a id="L51" href="#L51">51</a><a id="L52" href="#L52">52</a><a id="L53" href="#L53">53</a><a id="L54" href="#L54">54</a><a id="L55" href="#L55">55</a><a id="L56" href="#L56">56</a><a id="L57" href="#L57">57</a><a id="L58" href="#L58">58</a><a id="L59" href="#L59">59</a><a id="L60" href="#L60">60</a><a id="L61" href="#L61">61</a><a id="L62" href="#L62">62</a><a id="L63" href="#L63">63</a><a id="L64" href="#L64">64</a><a id="L65" href="#L65">65</a><a id="L66" href="#L66">66</a><a id="L67" href="#L67">67</a><a id="L68" href="#L68">68</a><a id="L69" href="#L69">69</a><a id="L70" href="#L70">70</a><a id="L71" href="#L71">71</a><a id="L72" href="#L72">72</a><a id="L73" href="#L73">73</a><a id="L74" href="#L74">74</a><a id="L75" href="#L75">75</a><a id="L76" href="#L76">76</a><a id="L77" href="#L77">77</a><a id="L78" href="#L78">78</a><a id="L79" href="#L79">79</a><a id="L80" href="#L80">80</a><a id="L81" href="#L81">81</a><a id="L82" href="#L82">82</a><a id="L83" href="#L83">83</a><a id="L84" href="#L84">84</a><a id="L85" href="#L85">85</a><a id="L86" href="#L86">86</a><a id="L87" href="#L87">87</a><a id="L88" href="#L88">88</a><a id="L89" href="#L89">89</a><a id="L90" href="#L90">90</a><a id="L91" href="#L91">91</a><a id="L92" href="#L92">92</a><a id="L93" href="#L93">93</a><a id="L94" href="#L94">94</a><a id="L95" href="#L95">95</a><a id="L96" href="#L96">96</a><a id="L97" href="#L97">97</a><a id="L98" href="#L98">98</a><a id="L99" href="#L99">99</a><a id="L100" href="#L100">100</a><a id="L101" href="#L101">101</a><a id="L102" href="#L102">102</a><a id="L103" href="#L103">103</a><a id="L104" href="#L104">104</a><a id="L105" href="#L105">105</a><a id="L106" href="#L106">106</a><a id="L107" href="#L107">107</a><a id="L108" href="#L108">108</a><a id="L109" href="#L109">109</a><a id="L110" href="#L110">110</a><a id="L111" href="#L111">111</a><a id="L112" href="#L112">112</a><a id="L113" href="#L113">113</a><a id="L114" href="#L114">114</a><a id="L115" href="#L115">115</a><a id="L116" href="#L116">116</a><a id="L117" href="#L117">117</a><a id="L118" href="#L118">118</a><a id="L119" href="#L119">119</a><a id="L120" href="#L120">120</a><a id="L121" href="#L121">121</a><a id="L122" href="#L122">122</a><a id="L123" href="#L123">123</a><a id="L124" href="#L124">124</a><a id="L125" href="#L125">125</a><a id="L126" href="#L126">126</a><a id="L127" href="#L127">127</a><a id="L128" href="#L128">128</a><a id="L129" href="#L129">129</a><a id="L130" href="#L130">130</a><a id="L131" href="#L131">131</a><a id="L132" href="#L132">132</a><a id="L133" href="#L133">133</a><a id="L134" href="#L134">134</a><a id="L135" href="#L135">135</a><a id="L136" href="#L136">136</a><a id="L137" href="#L137">137</a><a id="L138" href="#L138">138</a><a id="L139" href="#L139">139</a><a id="L140" href="#L140">140</a><a id="L141" href="#L141">141</a><a id="L142" href="#L142">142</a><a id="L143" href="#L143">143</a><a id="L144" href="#L144">144</a><a id="L145" href="#L145">145</a><a id="L146" href="#L146">146</a><a id="L147" href="#L147">147</a><a id="L148" href="#L148">148</a><a id="L149" href="#L149">149</a><a id="L150" href="#L150">150</a><a id="L151" href="#L151">151</a><a id="L152" href="#L152">152</a><a id="L153" href="#L153">153</a><a id="L154" href="#L154">154</a><a id="L155" href="#L155">155</a><a id="L156" href="#L156">156</a><a id="L157" href="#L157">157</a><a id="L158" href="#L158">158</a><a id="L159" href="#L159">159</a><a id="L160" href="#L160">160</a><a id="L161" href="#L161">161</a><a id="L162" href="#L162">162</a><a id="L163" href="#L163">163</a><a id="L164" href="#L164">164</a><a id="L165" href="#L165">165</a><a id="L166" href="#L166">166</a><a id="L167" href="#L167">167</a><a id="L168" href="#L168">168</a><a id="L169" href="#L169">169</a><a id="L170" href="#L170">170</a><a id="L171" href="#L171">171</a><a id="L172" href="#L172">172</a><a id="L173" href="#L173">173</a><a id="L174" href="#L174">174</a><a id="L175" href="#L175">175</a><a id="L176" href="#L176">176</a><a id="L177" href="#L177">177</a><a id="L178" href="#L178">178</a><a id="L179" href="#L179">179</a><a id="L180" href="#L180">180</a><a id="L181" href="#L181">181</a><a id="L182" href="#L182">182</a><a id="L183" href="#L183">183</a><a id="L184" href="#L184">184</a><a id="L185" href="#L185">185</a><a id="L186" href="#L186">186</a><a id="L187" href="#L187">187</a><a id="L188" href="#L188">188</a><a id="L189" href="#L189">189</a><a id="L190" href="#L190">190</a><a id="L191" href="#L191">191</a><a id="L192" href="#L192">192</a><a id="L193" href="#L193">193</a><a id="L194" href="#L194">194</a><a id="L195" href="#L195">195</a><a id="L196" href="#L196">196</a><a id="L197" href="#L197">197</a><a id="L198" href="#L198">198</a><a id="L199" href="#L199">199</a><a id="L200" href="#L200">200</a><a id="L201" href="#L201">201</a><a id="L202" href="#L202">202</a><a id="L203" href="#L203">203</a><a id="L204" href="#L204">204</a><a id="L205" href="#L205">205</a><a id="L206" href="#L206">206</a><a id="L207" href="#L207">207</a><a id="L208" href="#L208">208</a><a id="L209" href="#L209">209</a><a id="L210" href="#L210">210</a><a id="L211" href="#L211">211</a><a id="L212" href="#L212">212</a><a id="L213" href="#L213">213</a><a id="L214" href="#L214">214</a><a id="L215" href="#L215">215</a><a id="L216" href="#L216">216</a><a id="L217" href="#L217">217</a><a id="L218" href="#L218">218</a><a id="L219" href="#L219">219</a><a id="L220" href="#L220">220</a><a id="L221" href="#L221">221</a><a id="L222" href="#L222">222</a><a id="L223" href="#L223">223</a><a id="L224" href="#L224">224</a><a id="L225" href="#L225">225</a><a id="L226" href="#L226">226</a><a id="L227" href="#L227">227</a><a id="L228" href="#L228">228</a><a id="L229" href="#L229">229</a><a id="L230" href="#L230">230</a><a id="L231" href="#L231">231</a><a id="L232" href="#L232">232</a><a id="L233" href="#L233">233</a><a id="L234" href="#L234">234</a><a id="L235" href="#L235">235</a><a id="L236" href="#L236">236</a><a id="L237" href="#L237">237</a><a id="L238" href="#L238">238</a><a id="L239" href="#L239">239</a><a id="L240" href="#L240">240</a><a id="L241" href="#L241">241</a><a id="L242" href="#L242">242</a><a id="L243" href="#L243">243</a><a id="L244" href="#L244">244</a><a id="L245" href="#L245">245</a><a id="L246" href="#L246">246</a><a id="L247" href="#L247">247</a><a id="L248" href="#L248">248</a><a id="L249" href="#L249">249</a><a id="L250" href="#L250">250</a><a id="L251" href="#L251">251</a><a id="L252" href="#L252">252</a><a id="L253" href="#L253">253</a><a id="L254" href="#L254">254</a><a id="L255" href="#L255">255</a><a id="L256" href="#L256">256</a><a id="L257" href="#L257">257</a><a id="L258" href="#L258">258</a><a id="L259" href="#L259">259</a><a id="L260" href="#L260">260</a><a id="L261" href="#L261">261</a><a id="L262" href="#L262">262</a><a id="L263" href="#L263">263</a><a id="L264" href="#L264">264</a><a id="L265" href="#L265">265</a><a id="L266" href="#L266">266</a><a id="L267" href="#L267">267</a><a id="L268" href="#L268">268</a><a id="L269" href="#L269">269</a><a id="L270" href="#L270">270</a><a id="L271" href="#L271">271</a><a id="L272" href="#L272">272</a><a id="L273" href="#L273">273</a><a id="L274" href="#L274">274</a><a id="L275" href="#L275">275</a><a id="L276" href="#L276">276</a><a id="L277" href="#L277">277</a><a id="L278" href="#L278">278</a><a id="L279" href="#L279">279</a><a id="L280" href="#L280">280</a><a id="L281" href="#L281">281</a><a id="L282" href="#L282">282</a><a id="L283" href="#L283">283</a><a id="L284" href="#L284">284</a><a id="L285" href="#L285">285</a><a id="L286" href="#L286">286</a><a id="L287" href="#L287">287</a><a id="L288" href="#L288">288</a><a id="L289" href="#L289">289</a><a id="L290" href="#L290">290</a><a id="L291" href="#L291">291</a><a id="L292" href="#L292">292</a><a id="L293" href="#L293">293</a><a id="L294" href="#L294">294</a><a id="L295" href="#L295">295</a><a id="L296" href="#L296">296</a><a id="L297" href="#L297">297</a><a id="L298" href="#L298">298</a><a id="L299" href="#L299">299</a><a id="L300" href="#L300">300</a><a id="L301" href="#L301">301</a><a id="L302" href="#L302">302</a><a id="L303" href="#L303">303</a><a id="L304" href="#L304">304</a><a id="L305" href="#L305">305</a><a id="L306" href="#L306">306</a><a id="L307" href="#L307">307</a><a id="L308" href="#L308">308</a><a id="L309" href="#L309">309</a><a id="L310" href="#L310">310</a><a id="L311" href="#L311">311</a><a id="L312" href="#L312">312</a><a id="L313" href="#L313">313</a><a id="L314" href="#L314">314</a><a id="L315" href="#L315">315</a><a id="L316" href="#L316">316</a><a id="L317" href="#L317">317</a><a id="L318" href="#L318">318</a><a id="L319" href="#L319">319</a><a id="L320" href="#L320">320</a><a id="L321" href="#L321">321</a><a id="L322" href="#L322">322</a><a id="L323" href="#L323">323</a><a id="L324" href="#L324">324</a><a id="L325" href="#L325">325</a><a id="L326" href="#L326">326</a><a id="L327" href="#L327">327</a><a id="L328" href="#L328">328</a><a id="L329" href="#L329">329</a><a id="L330" href="#L330">330</a><a id="L331" href="#L331">331</a><a id="L332" href="#L332">332</a><a id="L333" href="#L333">333</a><a id="L334" href="#L334">334</a><a id="L335" href="#L335">335</a><a id="L336" href="#L336">336</a><a id="L337" href="#L337">337</a><a id="L338" href="#L338">338</a><a id="L339" href="#L339">339</a><a id="L340" href="#L340">340</a><a id="L341" href="#L341">341</a><a id="L342" href="#L342">342</a><a id="L343" href="#L343">343</a><a id="L344" href="#L344">344</a><a id="L345" href="#L345">345</a><a id="L346" href="#L346">346</a><a id="L347" href="#L347">347</a><a id="L348" href="#L348">348</a><a id="L349" href="#L349">349</a><a id="L350" href="#L350">350</a><a id="L351" href="#L351">351</a><a id="L352" href="#L352">352</a><a id="L353" href="#L353">353</a><a id="L354" href="#L354">354</a><a id="L355" href="#L355">355</a><a id="L356" href="#L356">356</a><a id="L357" href="#L357">357</a><a id="L358" href="#L358">358</a><a id="L359" href="#L359">359</a><a id="L360" href="#L360">360</a><a id="L361" href="#L361">361</a><a id="L362" href="#L362">362</a><a id="L363" href="#L363">363</a><a id="L364" href="#L364">364</a><a id="L365" href="#L365">365</a><a id="L366" href="#L366">366</a><a id="L367" href="#L367">367</a><a id="L368" href="#L368">368</a><a id="L369" href="#L369">369</a><a id="L370" href="#L370">370</a><a id="L371" href="#L371">371</a><a id="L372" href="#L372">372</a><a id="L373" href="#L373">373</a><a id="L374" href="#L374">374</a><a id="L375" href="#L375">375</a><a id="L376" href="#L376">376</a><a id="L377" href="#L377">377</a><a id="L378" href="#L378">378</a><a id="L379" href="#L379">379</a><a id="L380" href="#L380">380</a><a id="L381" href="#L381">381</a><a id="L382" href="#L382">382</a><a id="L383" href="#L383">383</a><a id="L384" href="#L384">384</a><a id="L385" href="#L385">385</a><a id="L386" href="#L386">386</a><a id="L387" href="#L387">387</a><a id="L388" href="#L388">388</a><a id="L389" href="#L389">389</a><a id="L390" href="#L390">390</a><a id="L391" href="#L391">391</a><a id="L392" href="#L392">392</a><a id="L393" href="#L393">393</a><a id="L394" href="#L394">394</a><a id="L395" href="#L395">395</a><a id="L396" href="#L396">396</a><a id="L397" href="#L397">397</a><a id="L398" href="#L398">398</a><a id="L399" href="#L399">399</a><a id="L400" href="#L400">400</a><a id="L401" href="#L401">401</a><a id="L402" href="#L402">402</a><a id="L403" href="#L403">403</a><a id="L404" href="#L404">404</a><a id="L405" href="#L405">405</a><a id="L406" href="#L406">406</a><a id="L407" href="#L407">407</a><a id="L408" href="#L408">408</a><a id="L409" href="#L409">409</a><a id="L410" href="#L410">410</a><a id="L411" href="#L411">411</a><a id="L412" href="#L412">412</a><a id="L413" href="#L413">413</a><a id="L414" href="#L414">414</a><a id="L415" href="#L415">415</a><a id="L416" href="#L416">416</a><a id="L417" href="#L417">417</a><a id="L418" href="#L418">418</a><a id="L419" href="#L419">419</a><a id="L420" href="#L420">420</a><a id="L421" href="#L421">421</a><a id="L422" href="#L422">422</a><a id="L423" href="#L423">423</a><a id="L424" href="#L424">424</a><a id="L425" href="#L425">425</a><a id="L426" href="#L426">426</a><a id="L427" href="#L427">427</a><a id="L428" href="#L428">428</a><a id="L429" href="#L429">429</a><a id="L430" href="#L430">430</a><a id="L431" href="#L431">431</a><a id="L432" href="#L432">432</a><a id="L433" href="#L433">433</a><a id="L434" href="#L434">434</a><a id="L435" href="#L435">435</a><a id="L436" href="#L436">436</a><a id="L437" href="#L437">437</a><a id="L438" href="#L438">438</a><a id="L439" href="#L439">439</a><a id="L440" href="#L440">440</a><a id="L441" href="#L441">441</a><a id="L442" href="#L442">442</a><a id="L443" href="#L443">443</a><a id="L444" href="#L444">444</a><a id="L445" href="#L445">445</a><a id="L446" href="#L446">446</a><a id="L447" href="#L447">447</a><a id="L448" href="#L448">448</a><a id="L449" href="#L449">449</a><a id="L450" href="#L450">450</a><a id="L451" href="#L451">451</a><a id="L452" href="#L452">452</a><a id="L453" href="#L453">453</a><a id="L454" href="#L454">454</a><a id="L455" href="#L455">455</a><a id="L456" href="#L456">456</a><a id="L457" href="#L457">457</a><a id="L458" href="#L458">458</a><a id="L459" href="#L459">459</a><a id="L460" href="#L460">460</a><a id="L461" href="#L461">461</a><a id="L462" href="#L462">462</a><a id="L463" href="#L463">463</a><a id="L464" href="#L464">464</a><a id="L465" href="#L465">465</a><a id="L466" href="#L466">466</a><a id="L467" href="#L467">467</a><a id="L468" href="#L468">468</a><a id="L469" href="#L469">469</a><a id="L470" href="#L470">470</a><a id="L471" href="#L471">471</a><a id="L472" href="#L472">472</a><a id="L473" href="#L473">473</a><a id="L474" href="#L474">474</a><a id="L475" href="#L475">475</a><a id="L476" href="#L476">476</a><a id="L477" href="#L477">477</a><a id="L478" href="#L478">478</a><a id="L479" href="#L479">479</a><a id="L480" href="#L480">480</a><a id="L481" href="#L481">481</a><a id="L482" href="#L482">482</a><a id="L483" href="#L483">483</a><a id="L484" href="#L484">484</a><a id="L485" href="#L485">485</a><a id="L486" href="#L486">486</a><a id="L487" href="#L487">487</a><a id="L488" href="#L488">488</a><a id="L489" href="#L489">489</a><a id="L490" href="#L490">490</a><a id="L491" href="#L491">491</a><a id="L492" href="#L492">492</a><a id="L493" href="#L493">493</a><a id="L494" href="#L494">494</a><a id="L495" href="#L495">495</a><a id="L496" href="#L496">496</a><a id="L497" href="#L497">497</a><a id="L498" href="#L498">498</a><a id="L499" href="#L499">499</a><a id="L500" href="#L500">500</a><a id="L501" href="#L501">501</a><a id="L502" href="#L502">502</a><a id="L503" href="#L503">503</a><a id="L504" href="#L504">504</a><a id="L505" href="#L505">505</a><a id="L506" href="#L506">506</a><a id="L507" href="#L507">507</a><a id="L508" href="#L508">508</a><a id="L509" href="#L509">509</a><a id="L510" href="#L510">510</a><a id="L511" href="#L511">511</a><a id="L512" href="#L512">512</a><a id="L513" href="#L513">513</a><a id="L514" href="#L514">514</a><a id="L515" href="#L515">515</a><a id="L516" href="#L516">516</a><a id="L517" href="#L517">517</a><a id="L518" href="#L518">518</a><a id="L519" href="#L519">519</a><a id="L520" href="#L520">520</a><a id="L521" href="#L521">521</a><a id="L522" href="#L522">522</a><a id="L523" href="#L523">523</a><a id="L524" href="#L524">524</a><a id="L525" href="#L525">525</a><a id="L526" href="#L526">526</a><a id="L527" href="#L527">527</a><a id="L528" href="#L528">528</a><a id="L529" href="#L529">529</a><a id="L530" href="#L530">530</a><a id="L531" href="#L531">531</a><a id="L532" href="#L532">532</a><a id="L533" href="#L533">533</a><a id="L534" href="#L534">534</a><a id="L535" href="#L535">535</a><a id="L536" href="#L536">536</a><a id="L537" href="#L537">537</a><a id="L538" href="#L538">538</a><a id="L539" href="#L539">539</a><a id="L540" href="#L540">540</a><a id="L541" href="#L541">541</a><a id="L542" href="#L542">542</a><a id="L543" href="#L543">543</a><a id="L544" href="#L544">544</a><a id="L545" href="#L545">545</a><a id="L546" href="#L546">546</a><a id="L547" href="#L547">547</a><a id="L548" href="#L548">548</a><a id="L549" href="#L549">549</a><a id="L550" href="#L550">550</a><a id="L551" href="#L551">551</a><a id="L552" href="#L552">552</a><a id="L553" href="#L553">553</a><a id="L554" href="#L554">554</a><a id="L555" href="#L555">555</a><a id="L556" href="#L556">556</a><a id="L557" href="#L557">557</a><a id="L558" href="#L558">558</a><a id="L559" href="#L559">559</a><a id="L560" href="#L560">560</a><a id="L561" href="#L561">561</a><a id="L562" href="#L562">562</a><a id="L563" href="#L563">563</a><a id="L564" href="#L564">564</a><a id="L565" href="#L565">565</a><a id="L566" href="#L566">566</a><a id="L567" href="#L567">567</a><a id="L568" href="#L568">568</a><a id="L569" href="#L569">569</a><a id="L570" href="#L570">570</a><a id="L571" href="#L571">571</a><a id="L572" href="#L572">572</a><a id="L573" href="#L573">573</a><a id="L574" href="#L574">574</a><a id="L575" href="#L575">575</a><a id="L576" href="#L576">576</a><a id="L577" href="#L577">577</a><a id="L578" href="#L578">578</a><a id="L579" href="#L579">579</a><a id="L580" href="#L580">580</a><a id="L581" href="#L581">581</a><a id="L582" href="#L582">582</a><a id="L583" href="#L583">583</a><a id="L584" href="#L584">584</a><a id="L585" href="#L585">585</a><a id="L586" href="#L586">586</a><a id="L587" href="#L587">587</a><a id="L588" href="#L588">588</a><a id="L589" href="#L589">589</a><a id="L590" href="#L590">590</a><a id="L591" href="#L591">591</a><a id="L592" href="#L592">592</a><a id="L593" href="#L593">593</a><a id="L594" href="#L594">594</a><a id="L595" href="#L595">595</a><a id="L596" href="#L596">596</a><a id="L597" href="#L597">597</a><a id="L598" href="#L598">598</a><a id="L599" href="#L599">599</a><a id="L600" href="#L600">600</a><a id="L601" href="#L601">601</a><a id="L602" href="#L602">602</a><a id="L603" href="#L603">603</a><a id="L604" href="#L604">604</a><a id="L605" href="#L605">605</a><a id="L606" href="#L606">606</a><a id="L607" href="#L607">607</a><a id="L608" href="#L608">608</a><a id="L609" href="#L609">609</a><a id="L610" href="#L610">610</a><a id="L611" href="#L611">611</a><a id="L612" href="#L612">612</a><a id="L613" href="#L613">613</a><a id="L614" href="#L614">614</a><a id="L615" href="#L615">615</a><a id="L616" href="#L616">616</a><a id="L617" href="#L617">617</a><a id="L618" href="#L618">618</a><a id="L619" href="#L619">619</a><a id="L620" href="#L620">620</a><a id="L621" href="#L621">621</a><a id="L622" href="#L622">622</a><a id="L623" href="#L623">623</a><a id="L624" href="#L624">624</a><a id="L625" href="#L625">625</a><a id="L626" href="#L626">626</a><a id="L627" href="#L627">627</a><a id="L628" href="#L628">628</a><a id="L629" href="#L629">629</a><a id="L630" href="#L630">630</a><a id="L631" href="#L631">631</a><a id="L632" href="#L632">632</a><a id="L633" href="#L633">633</a><a id="L634" href="#L634">634</a><a id="L635" href="#L635">635</a><a id="L636" href="#L636">636</a><a id="L637" href="#L637">637</a><a id="L638" href="#L638">638</a><a id="L639" href="#L639">639</a><a id="L640" href="#L640">640</a><a id="L641" href="#L641">641</a><a id="L642" href="#L642">642</a><a id="L643" href="#L643">643</a><a id="L644" href="#L644">644</a><a id="L645" href="#L645">645</a><a id="L646" href="#L646">646</a><a id="L647" href="#L647">647</a><a id="L648" href="#L648">648</a><a id="L649" href="#L649">649</a><a id="L650" href="#L650">650</a><a id="L651" href="#L651">651</a><a id="L652" href="#L652">652</a><a id="L653" href="#L653">653</a><a id="L654" href="#L654">654</a><a id="L655" href="#L655">655</a><a id="L656" href="#L656">656</a><a id="L657" href="#L657">657</a><a id="L658" href="#L658">658</a><a id="L659" href="#L659">659</a><a id="L660" href="#L660">660</a><a id="L661" href="#L661">661</a><a id="L662" href="#L662">662</a><a id="L663" href="#L663">663</a><a id="L664" href="#L664">664</a><a id="L665" href="#L665">665</a><a id="L666" href="#L666">666</a><a id="L667" href="#L667">667</a><a id="L668" href="#L668">668</a><a id="L669" href="#L669">669</a><a id="L670" href="#L670">670</a><a id="L671" href="#L671">671</a><a id="L672" href="#L672">672</a><a id="L673" href="#L673">673</a><a id="L674" href="#L674">674</a><a id="L675" href="#L675">675</a><a id="L676" href="#L676">676</a><a id="L677" href="#L677">677</a><a id="L678" href="#L678">678</a><a id="L679" href="#L679">679</a><a id="L680" href="#L680">680</a><a id="L681" href="#L681">681</a><a id="L682" href="#L682">682</a><a id="L683" href="#L683">683</a><a id="L684" href="#L684">684</a><a id="L685" href="#L685">685</a><a id="L686" href="#L686">686</a><a id="L687" href="#L687">687</a><a id="L688" href="#L688">688</a><a id="L689" href="#L689">689</a><a id="L690" href="#L690">690</a><a id="L691" href="#L691">691</a><a id="L692" href="#L692">692</a><a id="L693" href="#L693">693</a><a id="L694" href="#L694">694</a><a id="L695" href="#L695">695</a><a id="L696" href="#L696">696</a><a id="L697" href="#L697">697</a><a id="L698" href="#L698">698</a><a id="L699" href="#L699">699</a><a id="L700" href="#L700">700</a><a id="L701" href="#L701">701</a><a id="L702" href="#L702">702</a><a id="L703" href="#L703">703</a><a id="L704" href="#L704">704</a><a id="L705" href="#L705">705</a><a id="L706" href="#L706">706</a><a id="L707" href="#L707">707</a><a id="L708" href="#L708">708</a><a id="L709" href="#L709">709</a><a id="L710" href="#L710">710</a><a id="L711" href="#L711">711</a><a id="L712" href="#L712">712</a><a id="L713" href="#L713">713</a><a id="L714" href="#L714">714</a><a id="L715" href="#L715">715</a><a id="L716" href="#L716">716</a><a id="L717" href="#L717">717</a><a id="L718" href="#L718">718</a><a id="L719" href="#L719">719</a><a id="L720" href="#L720">720</a><a id="L721" href="#L721">721</a><a id="L722" href="#L722">722</a><a id="L723" href="#L723">723</a><a id="L724" href="#L724">724</a><a id="L725" href="#L725">725</a><a id="L726" href="#L726">726</a><a id="L727" href="#L727">727</a><a id="L728" href="#L728">728</a><a id="L729" href="#L729">729</a><a id="L730" href="#L730">730</a><a id="L731" href="#L731">731</a><a id="L732" href="#L732">732</a><a id="L733" href="#L733">733</a><a id="L734" href="#L734">734</a><a id="L735" href="#L735">735</a><a id="L736" href="#L736">736</a><a id="L737" href="#L737">737</a><a id="L738" href="#L738">738</a><a id="L739" href="#L739">739</a><a id="L740" href="#L740">740</a><a id="L741" href="#L741">741</a><a id="L742" href="#L742">742</a><a id="L743" href="#L743">743</a><a id="L744" href="#L744">744</a><a id="L745" href="#L745">745</a><a id="L746" href="#L746">746</a><a id="L747" href="#L747">747</a><a id="L748" href="#L748">748</a><a id="L749" href="#L749">749</a><a id="L750" href="#L750">750</a><a id="L751" href="#L751">751</a><a id="L752" href="#L752">752</a><a id="L753" href="#L753">753</a><a id="L754" href="#L754">754</a><a id="L755" href="#L755">755</a><a id="L756" href="#L756">756</a><a id="L757" href="#L757">757</a><a id="L758" href="#L758">758</a><a id="L759" href="#L759">759</a><a id="L760" href="#L760">760</a><a id="L761" href="#L761">761</a><a id="L762" href="#L762">762</a><a id="L763" href="#L763">763</a><a id="L764" href="#L764">764</a><a id="L765" href="#L765">765</a><a id="L766" href="#L766">766</a><a id="L767" href="#L767">767</a><a id="L768" href="#L768">768</a><a id="L769" href="#L769">769</a><a id="L770" href="#L770">770</a><a id="L771" href="#L771">771</a><a id="L772" href="#L772">772</a><a id="L773" href="#L773">773</a><a id="L774" href="#L774">774</a><a id="L775" href="#L775">775</a><a id="L776" href="#L776">776</a><a id="L777" href="#L777">777</a><a id="L778" href="#L778">778</a><a id="L779" href="#L779">779</a><a id="L780" href="#L780">780</a><a id="L781" href="#L781">781</a><a id="L782" href="#L782">782</a><a id="L783" href="#L783">783</a><a id="L784" href="#L784">784</a><a id="L785" href="#L785">785</a><a id="L786" href="#L786">786</a><a id="L787" href="#L787">787</a><a id="L788" href="#L788">788</a><a id="L789" href="#L789">789</a><a id="L790" href="#L790">790</a><a id="L791" href="#L791">791</a><a id="L792" href="#L792">792</a><a id="L793" href="#L793">793</a><a id="L794" href="#L794">794</a><a id="L795" href="#L795">795</a><a id="L796" href="#L796">796</a><a id="L797" href="#L797">797</a><a id="L798" href="#L798">798</a><a id="L799" href="#L799">799</a><a id="L800" href="#L800">800</a><a id="L801" href="#L801">801</a><a id="L802" href="#L802">802</a><a id="L803" href="#L803">803</a><a id="L804" href="#L804">804</a><a id="L805" href="#L805">805</a><a id="L806" href="#L806">806</a><a id="L807" href="#L807">807</a><a id="L808" href="#L808">808</a><a id="L809" href="#L809">809</a><a id="L810" href="#L810">810</a><a id="L811" href="#L811">811</a><a id="L812" href="#L812">812</a><a id="L813" href="#L813">813</a><a id="L814" href="#L814">814</a><a id="L815" href="#L815">815</a><a id="L816" href="#L816">816</a><a id="L817" href="#L817">817</a><a id="L818" href="#L818">818</a><a id="L819" href="#L819">819</a><a id="L820" href="#L820">820</a><a id="L821" href="#L821">821</a><a id="L822" href="#L822">822</a><a id="L823" href="#L823">823</a><a id="L824" href="#L824">824</a><a id="L825" href="#L825">825</a><a id="L826" href="#L826">826</a><a id="L827" href="#L827">827</a><a id="L828" href="#L828">828</a><a id="L829" href="#L829">829</a><a id="L830" href="#L830">830</a><a id="L831" href="#L831">831</a><a id="L832" href="#L832">832</a><a id="L833" href="#L833">833</a><a id="L834" href="#L834">834</a><a id="L835" href="#L835">835</a><a id="L836" href="#L836">836</a><a id="L837" href="#L837">837</a><a id="L838" href="#L838">838</a><a id="L839" href="#L839">839</a><a id="L840" href="#L840">840</a><a id="L841" href="#L841">841</a><a id="L842" href="#L842">842</a><a id="L843" href="#L843">843</a><a id="L844" href="#L844">844</a><a id="L845" href="#L845">845</a><a id="L846" href="#L846">846</a><a id="L847" href="#L847">847</a><a id="L848" href="#L848">848</a><a id="L849" href="#L849">849</a><a id="L850" href="#L850">850</a><a id="L851" href="#L851">851</a><a id="L852" href="#L852">852</a><a id="L853" href="#L853">853</a><a id="L854" href="#L854">854</a><a id="L855" href="#L855">855</a><a id="L856" href="#L856">856</a><a id="L857" href="#L857">857</a><a id="L858" href="#L858">858</a><a id="L859" href="#L859">859</a><a id="L860" href="#L860">860</a><a id="L861" href="#L861">861</a><a id="L862" href="#L862">862</a><a id="L863" href="#L863">863</a><a id="L864" href="#L864">864</a><a id="L865" href="#L865">865</a><a id="L866" href="#L866">866</a><a id="L867" href="#L867">867</a><a id="L868" href="#L868">868</a><a id="L869" href="#L869">869</a><a id="L870" href="#L870">870</a><a id="L871" href="#L871">871</a><a id="L872" href="#L872">872</a><a id="L873" href="#L873">873</a><a id="L874" href="#L874">874</a><a id="L875" href="#L875">875</a><a id="L876" href="#L876">876</a><a id="L877" href="#L877">877</a><a id="L878" href="#L878">878</a><a id="L879" href="#L879">879</a><a id="L880" href="#L880">880</a><a id="L881" href="#L881">881</a><a id="L882" href="#L882">882</a><a id="L883" href="#L883">883</a><a id="L884" href="#L884">884</a><a id="L885" href="#L885">885</a><a id="L886" href="#L886">886</a><a id="L887" href="#L887">887</a><a id="L888" href="#L888">888</a><a id="L889" href="#L889">889</a><a id="L890" href="#L890">890</a><a id="L891" href="#L891">891</a><a id="L892" href="#L892">892</a><a id="L893" href="#L893">893</a><a id="L894" href="#L894">894</a><a id="L895" href="#L895">895</a><a id="L896" href="#L896">896</a><a id="L897" href="#L897">897</a><a id="L898" href="#L898">898</a><a id="L899" href="#L899">899</a><a id="L900" href="#L900">900</a><a id="L901" href="#L901">901</a><a id="L902" href="#L902">902</a><a id="L903" href="#L903">903</a><a id="L904" href="#L904">904</a><a id="L905" href="#L905">905</a><a id="L906" href="#L906">906</a><a id="L907" href="#L907">907</a><a id="L908" href="#L908">908</a><a id="L909" href="#L909">909</a><a id="L910" href="#L910">910</a><a id="L911" href="#L911">911</a><a id="L912" href="#L912">912</a><a id="L913" href="#L913">913</a><a id="L914" href="#L914">914</a><a id="L915" href="#L915">915</a><a id="L916" href="#L916">916</a><a id="L917" href="#L917">917</a><a id="L918" href="#L918">918</a><a id="L919" href="#L919">919</a><a id="L920" href="#L920">920</a><a id="L921" href="#L921">921</a><a id="L922" href="#L922">922</a><a id="L923" href="#L923">923</a><a id="L924" href="#L924">924</a><a id="L925" href="#L925">925</a><a id="L926" href="#L926">926</a><a id="L927" href="#L927">927</a><a id="L928" href="#L928">928</a><a id="L929" href="#L929">929</a><a id="L930" href="#L930">930</a><a id="L931" href="#L931">931</a><a id="L932" href="#L932">932</a><a id="L933" href="#L933">933</a><a id="L934" href="#L934">934</a><a id="L935" href="#L935">935</a><a id="L936" href="#L936">936</a><a id="L937" href="#L937">937</a><a id="L938" href="#L938">938</a><a id="L939" href="#L939">939</a><a id="L940" href="#L940">940</a><a id="L941" href="#L941">941</a><a id="L942" href="#L942">942</a><a id="L943" href="#L943">943</a><a id="L944" href="#L944">944</a><a id="L945" href="#L945">945</a><a id="L946" href="#L946">946</a><a id="L947" href="#L947">947</a><a id="L948" href="#L948">948</a><a id="L949" href="#L949">949</a><a id="L950" href="#L950">950</a><a id="L951" href="#L951">951</a><a id="L952" href="#L952">952</a><a id="L953" href="#L953">953</a><a id="L954" href="#L954">954</a><a id="L955" href="#L955">955</a><a id="L956" href="#L956">956</a><a id="L957" href="#L957">957</a><a id="L958" href="#L958">958</a><a id="L959" href="#L959">959</a><a id="L960" href="#L960">960</a><a id="L961" href="#L961">961</a><a id="L962" href="#L962">962</a><a id="L963" href="#L963">963</a><a id="L964" href="#L964">964</a><a id="L965" href="#L965">965</a><a id="L966" href="#L966">966</a><a id="L967" href="#L967">967</a><a id="L968" href="#L968">968</a><a id="L969" href="#L969">969</a><a id="L970" href="#L970">970</a><a id="L971" href="#L971">971</a><a id="L972" href="#L972">972</a><a id="L973" href="#L973">973</a><a id="L974" href="#L974">974</a><a id="L975" href="#L975">975</a><a id="L976" href="#L976">976</a><a id="L977" href="#L977">977</a><a id="L978" href="#L978">978</a><a id="L979" href="#L979">979</a><a id="L980" href="#L980">980</a><a id="L981" href="#L981">981</a><a id="L982" href="#L982">982</a><a id="L983" href="#L983">983</a><a id="L984" href="#L984">984</a><a id="L985" href="#L985">985</a><a id="L986" href="#L986">986</a><a id="L987" href="#L987">987</a><a id="L988" href="#L988">988</a><a id="L989" href="#L989">989</a><a id="L990" href="#L990">990</a><a id="L991" href="#L991">991</a><a id="L992" href="#L992">992</a><a id="L993" href="#L993">993</a><a id="L994" href="#L994">994</a><a id="L995" href="#L995">995</a><a id="L996" href="#L996">996</a><a id="L997" href="#L997">997</a><a id="L998" href="#L998">998</a><a id="L999" href="#L999">999</a><a id="L1000" href="#L1000">1000</a><a id="L1001" href="#L1001">1001</a><a id="L1002" href="#L1002">1002</a><a id="L1003" href="#L1003">1003</a><a id="L1004" href="#L1004">1004</a><a id="L1005" href="#L1005">1005</a><a id="L1006" href="#L1006">1006</a><a id="L1007" href="#L1007">1007</a><a id="L1008" href="#L1008">1008</a><a id="L1009" href="#L1009">1009</a><a id="L1010" href="#L1010">1010</a><a id="L1011" href="#L1011">1011</a><a id="L1012" href="#L1012">1012</a><a id="L1013" href="#L1013">1013</a><a id="L1014" href="#L1014">1014</a><a id="L1015" href="#L1015">1015</a><a id="L1016" href="#L1016">1016</a><a id="L1017" href="#L1017">1017</a><a id="L1018" href="#L1018">1018</a><a id="L1019" href="#L1019">1019</a><a id="L1020" href="#L1020">1020</a><a id="L1021" href="#L1021">1021</a><a id="L1022" href="#L1022">1022</a><a id="L1023" href="#L1023">1023</a><a id="L1024" href="#L1024">1024</a><a id="L1025" href="#L1025">1025</a><a id="L1026" href="#L1026">1026</a><a id="L1027" href="#L1027">1027</a><a id="L1028" href="#L1028">1028</a><a id="L1029" href="#L1029">1029</a><a id="L1030" href="#L1030">1030</a><a id="L1031" href="#L1031">1031</a><a id="L1032" href="#L1032">1032</a><a id="L1033" href="#L1033">1033</a><a id="L1034" href="#L1034">1034</a><a id="L1035" href="#L1035">1035</a><a id="L1036" href="#L1036">1036</a><a id="L1037" href="#L1037">1037</a><a id="L1038" href="#L1038">1038</a><a id="L1039" href="#L1039">1039</a><a id="L1040" href="#L1040">1040</a><a id="L1041" href="#L1041">1041</a><a id="L1042" href="#L1042">1042</a><a id="L1043" href="#L1043">1043</a><a id="L1044" href="#L1044">1044</a><a id="L1045" href="#L1045">1045</a><a id="L1046" href="#L1046">1046</a><a id="L1047" href="#L1047">1047</a><a id="L1048" href="#L1048">1048</a><a id="L1049" href="#L1049">1049</a><a id="L1050" href="#L1050">1050</a><a id="L1051" href="#L1051">1051</a><a id="L1052" href="#L1052">1052</a><a id="L1053" href="#L1053">1053</a><a id="L1054" href="#L1054">1054</a><a id="L1055" href="#L1055">1055</a><a id="L1056" href="#L1056">1056</a><a id="L1057" href="#L1057">1057</a><a id="L1058" href="#L1058">1058</a><a id="L1059" href="#L1059">1059</a><a id="L1060" href="#L1060">1060</a><a id="L1061" href="#L1061">1061</a><a id="L1062" href="#L1062">1062</a><a id="L1063" href="#L1063">1063</a><a id="L1064" href="#L1064">1064</a><a id="L1065" href="#L1065">1065</a><a id="L1066" href="#L1066">1066</a><a id="L1067" href="#L1067">1067</a><a id="L1068" href="#L1068">1068</a><a id="L1069" href="#L1069">1069</a><a id="L1070" href="#L1070">1070</a><a id="L1071" href="#L1071">1071</a><a id="L1072" href="#L1072">1072</a><a id="L1073" href="#L1073">1073</a><a id="L1074" href="#L1074">1074</a><a id="L1075" href="#L1075">1075</a><a id="L1076" href="#L1076">1076</a><a id="L1077" href="#L1077">1077</a><a id="L1078" href="#L1078">1078</a><a id="L1079" href="#L1079">1079</a><a id="L1080" href="#L1080">1080</a><a id="L1081" href="#L1081">1081</a><a id="L1082" href="#L1082">1082</a><a id="L1083" href="#L1083">1083</a><a id="L1084" href="#L1084">1084</a><a id="L1085" href="#L1085">1085</a><a id="L1086" href="#L1086">1086</a><a id="L1087" href="#L1087">1087</a><a id="L1088" href="#L1088">1088</a><a id="L1089" href="#L1089">1089</a><a id="L1090" href="#L1090">1090</a><a id="L1091" href="#L1091">1091</a><a id="L1092" href="#L1092">1092</a><a id="L1093" href="#L1093">1093</a><a id="L1094" href="#L1094">1094</a><a id="L1095" href="#L1095">1095</a><a id="L1096" href="#L1096">1096</a><a id="L1097" href="#L1097">1097</a><a id="L1098" href="#L1098">1098</a><a id="L1099" href="#L1099">1099</a><a id="L1100" href="#L1100">1100</a><a id="L1101" href="#L1101">1101</a><a id="L1102" href="#L1102">1102</a><a id="L1103" href="#L1103">1103</a><a id="L1104" href="#L1104">1104</a><a id="L1105" href="#L1105">1105</a><a id="L1106" href="#L1106">1106</a><a id="L1107" href="#L1107">1107</a><a id="L1108" href="#L1108">1108</a><a id="L1109" href="#L1109">1109</a><a id="L1110" href="#L1110">1110</a><a id="L1111" href="#L1111">1111</a><a id="L1112" href="#L1112">1112</a><a id="L1113" href="#L1113">1113</a><a id="L1114" href="#L1114">1114</a><a id="L1115" href="#L1115">1115</a><a id="L1116" href="#L1116">1116</a><a id="L1117" href="#L1117">1117</a><a id="L1118" href="#L1118">1118</a><a id="L1119" href="#L1119">1119</a><a id="L1120" href="#L1120">1120</a><a id="L1121" href="#L1121">1121</a><a id="L1122" href="#L1122">1122</a><a id="L1123" href="#L1123">1123</a><a id="L1124" href="#L1124">1124</a><a id="L1125" href="#L1125">1125</a><a id="L1126" href="#L1126">1126</a><a id="L1127" href="#L1127">1127</a><a id="L1128" href="#L1128">1128</a><a id="L1129" href="#L1129">1129</a><a id="L1130" href="#L1130">1130</a><a id="L1131" href="#L1131">1131</a><a id="L1132" href="#L1132">1132</a><a id="L1133" href="#L1133">1133</a><a id="L1134" href="#L1134">1134</a><a id="L1135" href="#L1135">1135</a><a id="L1136" href="#L1136">1136</a><a id="L1137" href="#L1137">1137</a><a id="L1138" href="#L1138">1138</a><a id="L1139" href="#L1139">1139</a><a id="L1140" href="#L1140">1140</a><a id="L1141" href="#L1141">1141</a><a id="L1142" href="#L1142">1142</a><a id="L1143" href="#L1143">1143</a><a id="L1144" href="#L1144">1144</a><a id="L1145" href="#L1145">1145</a><a id="L1146" href="#L1146">1146</a><a id="L1147" href="#L1147">1147</a><a id="L1148" href="#L1148">1148</a><a id="L1149" href="#L1149">1149</a><a id="L1150" href="#L1150">1150</a><a id="L1151" href="#L1151">1151</a><a id="L1152" href="#L1152">1152</a><a id="L1153" href="#L1153">1153</a><a id="L1154" href="#L1154">1154</a><a id="L1155" href="#L1155">1155</a><a id="L1156" href="#L1156">1156</a><a id="L1157" href="#L1157">1157</a><a id="L1158" href="#L1158">1158</a><a id="L1159" href="#L1159">1159</a><a id="L1160" href="#L1160">1160</a><a id="L1161" href="#L1161">1161</a><a id="L1162" href="#L1162">1162</a><a id="L1163" href="#L1163">1163</a><a id="L1164" href="#L1164">1164</a><a id="L1165" href="#L1165">1165</a><a id="L1166" href="#L1166">1166</a><a id="L1167" href="#L1167">1167</a><a id="L1168" href="#L1168">1168</a><a id="L1169" href="#L1169">1169</a><a id="L1170" href="#L1170">1170</a><a id="L1171" href="#L1171">1171</a><a id="L1172" href="#L1172">1172</a><a id="L1173" href="#L1173">1173</a><a id="L1174" href="#L1174">1174</a><a id="L1175" href="#L1175">1175</a><a id="L1176" href="#L1176">1176</a><a id="L1177" href="#L1177">1177</a><a id="L1178" href="#L1178">1178</a><a id="L1179" href="#L1179">1179</a><a id="L1180" href="#L1180">1180</a><a id="L1181" href="#L1181">1181</a><a id="L1182" href="#L1182">1182</a><a id="L1183" href="#L1183">1183</a><a id="L1184" href="#L1184">1184</a><a id="L1185" href="#L1185">1185</a><a id="L1186" href="#L1186">1186</a><a id="L1187" href="#L1187">1187</a><a id="L1188" href="#L1188">1188</a><a id="L1189" href="#L1189">1189</a><a id="L1190" href="#L1190">1190</a><a id="L1191" href="#L1191">1191</a><a id="L1192" href="#L1192">1192</a><a id="L1193" href="#L1193">1193</a><a id="L1194" href="#L1194">1194</a><a id="L1195" href="#L1195">1195</a><a id="L1196" href="#L1196">1196</a><a id="L1197" href="#L1197">1197</a><a id="L1198" href="#L1198">1198</a><a id="L1199" href="#L1199">1199</a><a id="L1200" href="#L1200">1200</a><a id="L1201" href="#L1201">1201</a><a id="L1202" href="#L1202">1202</a><a id="L1203" href="#L1203">1203</a><a id="L1204" href="#L1204">1204</a><a id="L1205" href="#L1205">1205</a><a id="L1206" href="#L1206">1206</a><a id="L1207" href="#L1207">1207</a><a id="L1208" href="#L1208">1208</a><a id="L1209" href="#L1209">1209</a><a id="L1210" href="#L1210">1210</a><a id="L1211" href="#L1211">1211</a><a id="L1212" href="#L1212">1212</a><a id="L1213" href="#L1213">1213</a><a id="L1214" href="#L1214">1214</a><a id="L1215" href="#L1215">1215</a><a id="L1216" href="#L1216">1216</a><a id="L1217" href="#L1217">1217</a><a id="L1218" href="#L1218">1218</a><a id="L1219" href="#L1219">1219</a><a id="L1220" href="#L1220">1220</a><a id="L1221" href="#L1221">1221</a><a id="L1222" href="#L1222">1222</a><a id="L1223" href="#L1223">1223</a><a id="L1224" href="#L1224">1224</a><a id="L1225" href="#L1225">1225</a><a id="L1226" href="#L1226">1226</a><a id="L1227" href="#L1227">1227</a><a id="L1228" href="#L1228">1228</a><a id="L1229" href="#L1229">1229</a><a id="L1230" href="#L1230">1230</a><a id="L1231" href="#L1231">1231</a><a id="L1232" href="#L1232">1232</a><a id="L1233" href="#L1233">1233</a><a id="L1234" href="#L1234">1234</a><a id="L1235" href="#L1235">1235</a><a id="L1236" href="#L1236">1236</a><a id="L1237" href="#L1237">1237</a><a id="L1238" href="#L1238">1238</a><a id="L1239" href="#L1239">1239</a><a id="L1240" href="#L1240">1240</a><a id="L1241" href="#L1241">1241</a><a id="L1242" href="#L1242">1242</a><a id="L1243" href="#L1243">1243</a><a id="L1244" href="#L1244">1244</a><a id="L1245" href="#L1245">1245</a><a id="L1246" href="#L1246">1246</a><a id="L1247" href="#L1247">1247</a><a id="L1248" href="#L1248">1248</a><a id="L1249" href="#L1249">1249</a><a id="L1250" href="#L1250">1250</a><a id="L1251" href="#L1251">1251</a><a id="L1252" href="#L1252">1252</a><a id="L1253" href="#L1253">1253</a><a id="L1254" href="#L1254">1254</a><a id="L1255" href="#L1255">1255</a><a id="L1256" href="#L1256">1256</a><a id="L1257" href="#L1257">1257</a><a id="L1258" href="#L1258">1258</a><a id="L1259" href="#L1259">1259</a><a id="L1260" href="#L1260">1260</a><a id="L1261" href="#L1261">1261</a><a id="L1262" href="#L1262">1262</a><a id="L1263" href="#L1263">1263</a><a id="L1264" href="#L1264">1264</a><a id="L1265" href="#L1265">1265</a><a id="L1266" href="#L1266">1266</a><a id="L1267" href="#L1267">1267</a><a id="L1268" href="#L1268">1268</a><a id="L1269" href="#L1269">1269</a><a id="L1270" href="#L1270">1270</a><a id="L1271" href="#L1271">1271</a><a id="L1272" href="#L1272">1272</a><a id="L1273" href="#L1273">1273</a><a id="L1274" href="#L1274">1274</a><a id="L1275" href="#L1275">1275</a><a id="L1276" href="#L1276">1276</a><a id="L1277" href="#L1277">1277</a><a id="L1278" href="#L1278">1278</a><a id="L1279" href="#L1279">1279</a><a id="L1280" href="#L1280">1280</a><a id="L1281" href="#L1281">1281</a><a id="L1282" href="#L1282">1282</a><a id="L1283" href="#L1283">1283</a><a id="L1284" href="#L1284">1284</a><a id="L1285" href="#L1285">1285</a><a id="L1286" href="#L1286">1286</a><a id="L1287" href="#L1287">1287</a><a id="L1288" href="#L1288">1288</a><a id="L1289" href="#L1289">1289</a><a id="L1290" href="#L1290">1290</a><a id="L1291" href="#L1291">1291</a><a id="L1292" href="#L1292">1292</a><a id="L1293" href="#L1293">1293</a><a id="L1294" href="#L1294">1294</a><a id="L1295" href="#L1295">1295</a><a id="L1296" href="#L1296">1296</a><a id="L1297" href="#L1297">1297</a><a id="L1298" href="#L1298">1298</a><a id="L1299" href="#L1299">1299</a><a id="L1300" href="#L1300">1300</a><a id="L1301" href="#L1301">1301</a><a id="L1302" href="#L1302">1302</a><a id="L1303" href="#L1303">1303</a><a id="L1304" href="#L1304">1304</a><a id="L1305" href="#L1305">1305</a><a id="L1306" href="#L1306">1306</a><a id="L1307" href="#L1307">1307</a><a id="L1308" href="#L1308">1308</a><a id="L1309" href="#L1309">1309</a><a id="L1310" href="#L1310">1310</a><a id="L1311" href="#L1311">1311</a><a id="L1312" href="#L1312">1312</a><a id="L1313" href="#L1313">1313</a><a id="L1314" href="#L1314">1314</a><a id="L1315" href="#L1315">1315</a><a id="L1316" href="#L1316">1316</a><a id="L1317" href="#L1317">1317</a><a id="L1318" href="#L1318">1318</a><a id="L1319" href="#L1319">1319</a><a id="L1320" href="#L1320">1320</a><a id="L1321" href="#L1321">1321</a><a id="L1322" href="#L1322">1322</a><a id="L1323" href="#L1323">1323</a><a id="L1324" href="#L1324">1324</a><a id="L1325" href="#L1325">1325</a><a id="L1326" href="#L1326">1326</a><a id="L1327" href="#L1327">1327</a><a id="L1328" href="#L1328">1328</a><a id="L1329" href="#L1329">1329</a><a id="L1330" href="#L1330">1330</a><a id="L1331" href="#L1331">1331</a><a id="L1332" href="#L1332">1332</a><a id="L1333" href="#L1333">1333</a><a id="L1334" href="#L1334">1334</a><a id="L1335" href="#L1335">1335</a><a id="L1336" href="#L1336">1336</a><a id="L1337" href="#L1337">1337</a><a id="L1338" href="#L1338">1338</a><a id="L1339" href="#L1339">1339</a><a id="L1340" href="#L1340">1340</a><a id="L1341" href="#L1341">1341</a><a id="L1342" href="#L1342">1342</a><a id="L1343" href="#L1343">1343</a><a id="L1344" href="#L1344">1344</a><a id="L1345" href="#L1345">1345</a><a id="L1346" href="#L1346">1346</a><a id="L1347" href="#L1347">1347</a><a id="L1348" href="#L1348">1348</a><a id="L1349" href="#L1349">1349</a><a id="L1350" href="#L1350">1350</a><a id="L1351" href="#L1351">1351</a><a id="L1352" href="#L1352">1352</a><a id="L1353" href="#L1353">1353</a><a id="L1354" href="#L1354">1354</a><a id="L1355" href="#L1355">1355</a><a id="L1356" href="#L1356">1356</a><a id="L1357" href="#L1357">1357</a><a id="L1358" href="#L1358">1358</a><a id="L1359" href="#L1359">1359</a><a id="L1360" href="#L1360">1360</a><a id="L1361" href="#L1361">1361</a><a id="L1362" href="#L1362">1362</a><a id="L1363" href="#L1363">1363</a><a id="L1364" href="#L1364">1364</a><a id="L1365" href="#L1365">1365</a><a id="L1366" href="#L1366">1366</a><a id="L1367" href="#L1367">1367</a><a id="L1368" href="#L1368">1368</a><a id="L1369" href="#L1369">1369</a><a id="L1370" href="#L1370">1370</a><a id="L1371" href="#L1371">1371</a><a id="L1372" href="#L1372">1372</a><a id="L1373" href="#L1373">1373</a><a id="L1374" href="#L1374">1374</a><a id="L1375" href="#L1375">1375</a><a id="L1376" href="#L1376">1376</a><a id="L1377" href="#L1377">1377</a><a id="L1378" href="#L1378">1378</a><a id="L1379" href="#L1379">1379</a><a id="L1380" href="#L1380">1380</a><a id="L1381" href="#L1381">1381</a><a id="L1382" href="#L1382">1382</a><a id="L1383" href="#L1383">1383</a><a id="L1384" href="#L1384">1384</a><a id="L1385" href="#L1385">1385</a><a id="L1386" href="#L1386">1386</a><a id="L1387" href="#L1387">1387</a><a id="L1388" href="#L1388">1388</a><a id="L1389" href="#L1389">1389</a><a id="L1390" href="#L1390">1390</a><a id="L1391" href="#L1391">1391</a><a id="L1392" href="#L1392">1392</a><a id="L1393" href="#L1393">1393</a><a id="L1394" href="#L1394">1394</a><a id="L1395" href="#L1395">1395</a><a id="L1396" href="#L1396">1396</a><a id="L1397" href="#L1397">1397</a><a id="L1398" href="#L1398">1398</a><a id="L1399" href="#L1399">1399</a><a id="L1400" href="#L1400">1400</a><a id="L1401" href="#L1401">1401</a><a id="L1402" href="#L1402">1402</a><a id="L1403" href="#L1403">1403</a><a id="L1404" href="#L1404">1404</a><a id="L1405" href="#L1405">1405</a><a id="L1406" href="#L1406">1406</a><a id="L1407" href="#L1407">1407</a><a id="L1408" href="#L1408">1408</a><a id="L1409" href="#L1409">1409</a><a id="L1410" href="#L1410">1410</a><a id="L1411" href="#L1411">1411</a><a id="L1412" href="#L1412">1412</a><a id="L1413" href="#L1413">1413</a><a id="L1414" href="#L1414">1414</a><a id="L1415" href="#L1415">1415</a><a id="L1416" href="#L1416">1416</a><a id="L1417" href="#L1417">1417</a><a id="L1418" href="#L1418">1418</a><a id="L1419" href="#L1419">1419</a><a id="L1420" href="#L1420">1420</a><a id="L1421" href="#L1421">1421</a><a id="L1422" href="#L1422">1422</a><a id="L1423" href="#L1423">1423</a><a id="L1424" href="#L1424">1424</a><a id="L1425" href="#L1425">1425</a><a id="L1426" href="#L1426">1426</a><a id="L1427" href="#L1427">1427</a><a id="L1428" href="#L1428">1428</a><a id="L1429" href="#L1429">1429</a><a id="L1430" href="#L1430">1430</a><a id="L1431" href="#L1431">1431</a><a id="L1432" href="#L1432">1432</a><a id="L1433" href="#L1433">1433</a><a id="L1434" href="#L1434">1434</a><a id="L1435" href="#L1435">1435</a><a id="L1436" href="#L1436">1436</a><a id="L1437" href="#L1437">1437</a><a id="L1438" href="#L1438">1438</a><a id="L1439" href="#L1439">1439</a><a id="L1440" href="#L1440">1440</a><a id="L1441" href="#L1441">1441</a><a id="L1442" href="#L1442">1442</a><a id="L1443" href="#L1443">1443</a><a id="L1444" href="#L1444">1444</a><a id="L1445" href="#L1445">1445</a><a id="L1446" href="#L1446">1446</a><a id="L1447" href="#L1447">1447</a><a id="L1448" href="#L1448">1448</a><a id="L1449" href="#L1449">1449</a><a id="L1450" href="#L1450">1450</a><a id="L1451" href="#L1451">1451</a><a id="L1452" href="#L1452">1452</a><a id="L1453" href="#L1453">1453</a><a id="L1454" href="#L1454">1454</a><a id="L1455" href="#L1455">1455</a><a id="L1456" href="#L1456">1456</a><a id="L1457" href="#L1457">1457</a><a id="L1458" href="#L1458">1458</a><a id="L1459" href="#L1459">1459</a><a id="L1460" href="#L1460">1460</a><a id="L1461" href="#L1461">1461</a><a id="L1462" href="#L1462">1462</a><a id="L1463" href="#L1463">1463</a><a id="L1464" href="#L1464">1464</a><a id="L1465" href="#L1465">1465</a><a id="L1466" href="#L1466">1466</a><a id="L1467" href="#L1467">1467</a><a id="L1468" href="#L1468">1468</a><a id="L1469" href="#L1469">1469</a><a id="L1470" href="#L1470">1470</a><a id="L1471" href="#L1471">1471</a><a id="L1472" href="#L1472">1472</a><a id="L1473" href="#L1473">1473</a><a id="L1474" href="#L1474">1474</a><a id="L1475" href="#L1475">1475</a><a id="L1476" href="#L1476">1476</a><a id="L1477" href="#L1477">1477</a><a id="L1478" href="#L1478">1478</a><a id="L1479" href="#L1479">1479</a><a id="L1480" href="#L1480">1480</a><a id="L1481" href="#L1481">1481</a><a id="L1482" href="#L1482">1482</a><a id="L1483" href="#L1483">1483</a><a id="L1484" href="#L1484">1484</a><a id="L1485" href="#L1485">1485</a><a id="L1486" href="#L1486">1486</a><a id="L1487" href="#L1487">1487</a><a id="L1488" href="#L1488">1488</a><a id="L1489" href="#L1489">1489</a><a id="L1490" href="#L1490">1490</a><a id="L1491" href="#L1491">1491</a><a id="L1492" href="#L1492">1492</a><a id="L1493" href="#L1493">1493</a><a id="L1494" href="#L1494">1494</a><a id="L1495" href="#L1495">1495</a><a id="L1496" href="#L1496">1496</a><a id="L1497" href="#L1497">1497</a><a id="L1498" href="#L1498">1498</a><a id="L1499" href="#L1499">1499</a><a id="L1500" href="#L1500">1500</a><a id="L1501" href="#L1501">1501</a><a id="L1502" href="#L1502">1502</a><a id="L1503" href="#L1503">1503</a><a id="L1504" href="#L1504">1504</a><a id="L1505" href="#L1505">1505</a><a id="L1506" href="#L1506">1506</a><a id="L1507" href="#L1507">1507</a><a id="L1508" href="#L1508">1508</a><a id="L1509" href="#L1509">1509</a><a id="L1510" href="#L1510">1510</a><a id="L1511" href="#L1511">1511</a><a id="L1512" href="#L1512">1512</a><a id="L1513" href="#L1513">1513</a><a id="L1514" href="#L1514">1514</a><a id="L1515" href="#L1515">1515</a><a id="L1516" href="#L1516">1516</a><a id="L1517" href="#L1517">1517</a><a id="L1518" href="#L1518">1518</a><a id="L1519" href="#L1519">1519</a><a id="L1520" href="#L1520">1520</a><a id="L1521" href="#L1521">1521</a><a id="L1522" href="#L1522">1522</a><a id="L1523" href="#L1523">1523</a><a id="L1524" href="#L1524">1524</a><a id="L1525" href="#L1525">1525</a><a id="L1526" href="#L1526">1526</a><a id="L1527" href="#L1527">1527</a><a id="L1528" href="#L1528">1528</a><a id="L1529" href="#L1529">1529</a><a id="L1530" href="#L1530">1530</a><a id="L1531" href="#L1531">1531</a><a id="L1532" href="#L1532">1532</a><a id="L1533" href="#L1533">1533</a><a id="L1534" href="#L1534">1534</a><a id="L1535" href="#L1535">1535</a><a id="L1536" href="#L1536">1536</a><a id="L1537" href="#L1537">1537</a><a id="L1538" href="#L1538">1538</a><a id="L1539" href="#L1539">1539</a><a id="L1540" href="#L1540">1540</a><a id="L1541" href="#L1541">1541</a><a id="L1542" href="#L1542">1542</a><a id="L1543" href="#L1543">1543</a><a id="L1544" href="#L1544">1544</a><a id="L1545" href="#L1545">1545</a><a id="L1546" href="#L1546">1546</a><a id="L1547" href="#L1547">1547</a><a id="L1548" href="#L1548">1548</a><a id="L1549" href="#L1549">1549</a><a id="L1550" href="#L1550">1550</a><a id="L1551" href="#L1551">1551</a><a id="L1552" href="#L1552">1552</a><a id="L1553" href="#L1553">1553</a><a id="L1554" href="#L1554">1554</a><a id="L1555" href="#L1555">1555</a><a id="L1556" href="#L1556">1556</a><a id="L1557" href="#L1557">1557</a><a id="L1558" href="#L1558">1558</a><a id="L1559" href="#L1559">1559</a><a id="L1560" href="#L1560">1560</a><a id="L1561" href="#L1561">1561</a><a id="L1562" href="#L1562">1562</a><a id="L1563" href="#L1563">1563</a><a id="L1564" href="#L1564">1564</a><a id="L1565" href="#L1565">1565</a><a id="L1566" href="#L1566">1566</a><a id="L1567" href="#L1567">1567</a><a id="L1568" href="#L1568">1568</a><a id="L1569" href="#L1569">1569</a><a id="L1570" href="#L1570">1570</a><a id="L1571" href="#L1571">1571</a><a id="L1572" href="#L1572">1572</a><a id="L1573" href="#L1573">1573</a><a id="L1574" href="#L1574">1574</a><a id="L1575" href="#L1575">1575</a><a id="L1576" href="#L1576">1576</a><a id="L1577" href="#L1577">1577</a><a id="L1578" href="#L1578">1578</a><a id="L1579" href="#L1579">1579</a><a id="L1580" href="#L1580">1580</a><a id="L1581" href="#L1581">1581</a><a id="L1582" href="#L1582">1582</a><a id="L1583" href="#L1583">1583</a><a id="L1584" href="#L1584">1584</a><a id="L1585" href="#L1585">1585</a><a id="L1586" href="#L1586">1586</a><a id="L1587" href="#L1587">1587</a><a id="L1588" href="#L1588">1588</a><a id="L1589" href="#L1589">1589</a><a id="L1590" href="#L1590">1590</a><a id="L1591" href="#L1591">1591</a><a id="L1592" href="#L1592">1592</a><a id="L1593" href="#L1593">1593</a><a id="L1594" href="#L1594">1594</a><a id="L1595" href="#L1595">1595</a><a id="L1596" href="#L1596">1596</a><a id="L1597" href="#L1597">1597</a><a id="L1598" href="#L1598">1598</a><a id="L1599" href="#L1599">1599</a><a id="L1600" href="#L1600">1600</a><a id="L1601" href="#L1601">1601</a><a id="L1602" href="#L1602">1602</a><a id="L1603" href="#L1603">1603</a><a id="L1604" href="#L1604">1604</a><a id="L1605" href="#L1605">1605</a><a id="L1606" href="#L1606">1606</a><a id="L1607" href="#L1607">1607</a><a id="L1608" href="#L1608">1608</a></td>
<td><td><pre class="sourcecode">
<span class="bc">/*******************************************************************************

        copyright:      Copyright (c) 2004 Kris Bell. All rights reserved

        license:        BSD style: $(LICENSE)

        version:        Apr 2004: Initial release
                        Dec 2006: South Seas version

        author:         Kris


        Placeholder for a variety of wee functions. These functions are all
        templated with the intent of being used for arrays of char, wchar,
        and dchar. However, they operate correctly with other array types
        also.

        Several of these functions return an index value, representing where
        some criteria was identified. When said criteria is not matched, the
        functions return a value representing the array length provided to
        them. That is, for those scenarios where C functions might typically
        return -1 these functions return length instead. This operate nicely
        with D slices:
        ---
        auto text = "happy:faces";
        
        assert (text[0 .. locate (text, ':')] == "happy");
        
        assert (text[0 .. locate (text, '!')] == "happy:faces");
        ---

        The contains() function is more convenient for trivial lookup
        cases:
        ---
        if (contains ("fubar", '!'))
            ...
        ---

        Note that where some functions expect a size_t as an argument, the
        D template-matching algorithm will fail where an int is provided
        instead. This is the typically the cause of "template not found"
        errors. Also note that name overloading is not supported cleanly
        by IFTI at this time, so is not applied here.


        Applying the D "import alias" mechanism to this module is highly
        recommended, in order to limit namespace pollution:
        ---
        import Util = tango.text.Util;

        auto s = Util.trim ("  foo ");
        ---
                

        Function templates:
        ---
        trim (source)                               // trim whitespace
        triml (source)                              // trim whitespace
        trimr (source)                              // trim whitespace
        strip (source, match)                       // trim elements
        stripl (source, match)                      // trim elements
        stripr (source, match)                      // trim elements
        chopl (source, match)                       // trim pattern match
        chopr (source, match)                       // trim pattern match
        delimit (src, set)                          // split on delims
        split (source, pattern)                     // split on pattern
        splitLines (source);                        // split on lines
        head (source, pattern, tail)                // split to head &amp; tail
        join (source, postfix, output)              // join text segments
        prefix (dst, prefix, content...)            // prefix text segments
        postfix (dst, postfix, content...)          // postfix text segments
        combine (dst, prefix, postfix, content...)  // combine lotsa stuff
        repeat (source, count, output)              // repeat source 
        replace (source, match, replacement)        // replace chars
        substitute (source, match, replacement)     // replace/remove matches
        count (source, match)                       // count instances
        contains (source, match)                    // has char?
        containsPattern (source, match)             // has pattern?
        index (source, match, start)                // find match index
        locate (source, match, start)               // find char
        locatePrior (source, match, start)          // find prior char
        locatePattern (source, match, start);       // find pattern
        locatePatternPrior (source, match, start);  // find prior pattern
        indexOf (s*, match, length)                 // low-level lookup
        mismatch (s1*, s2*, length)                 // low-level compare
        matching (s1*, s2*, length)                 // low-level compare
        isSpace (match)                             // is whitespace?
        unescape(source, output)                    // convert '\' prefixes
        layout (destination, format ...)            // featherweight printf
        lines (str)                                 // foreach lines
        quotes (str, set)                           // foreach quotes
        delimiters (str, set)                       // foreach delimiters
        patterns (str, pattern)                     // foreach patterns
        ---

        Please note that any 'pattern' referred to within this module
        refers to a pattern of characters, and not some kind of regex
        descriptor. Use the Regex module for regex operation.

*******************************************************************************/</span>

<span class="d Compound"><span class="d Module"><span class="k">module</span> <span class="i">tango</span>.<span class="i">text</span>.<span class="i">Util</span>;</span>

<span class="bc">/******************************************************************************

        Trim the provided array by stripping whitespace from both
        ends. Returns a slice of the original content

******************************************************************************/</span>


<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">trim</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">source</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">head</span> = <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tail</span> = <span class="e Plus"><span class="e Identifier"><span class="i">head</span></span> + <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>

        <span class="s While"><span class="k">while</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">head</span></span> &lt; <span class="e Identifier"><span class="i">tail</span></span></span> &amp;&amp; <span class="e Call"><span class="e Identifier"><span class="i">isSpace</span></span>(*<span class="i">head</span>)</span></span>)
               <span class="s Scope"><span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">head</span></span></span>;</span></span></span>

        <span class="s While"><span class="k">while</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">tail</span></span> &gt; <span class="e Identifier"><span class="i">head</span></span></span> &amp;&amp; <span class="e Call"><span class="e Identifier"><span class="i">isSpace</span></span>(*(<span class="i">tail</span>-<span class="n">1</span>))</span></span>)
               <span class="s Scope"><span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">tail</span></span></span>;</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">head</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Identifier"><span class="i">tail</span></span> - <span class="e Identifier"><span class="i">head</span></span></span>]</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Trim the provided array by stripping whitespace from the left.
        Returns a slice of the original content

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">triml</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">source</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">head</span> = <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tail</span> = <span class="e Plus"><span class="e Identifier"><span class="i">head</span></span> + <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>

        <span class="s While"><span class="k">while</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">head</span></span> &lt; <span class="e Identifier"><span class="i">tail</span></span></span> &amp;&amp; <span class="e Call"><span class="e Identifier"><span class="i">isSpace</span></span>(*<span class="i">head</span>)</span></span>)
               <span class="s Scope"><span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">head</span></span></span>;</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">head</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Identifier"><span class="i">tail</span></span> - <span class="e Identifier"><span class="i">head</span></span></span>]</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Trim the provided array by stripping whitespace from the right.
        Returns a slice of the original content

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">trimr</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">source</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">head</span> = <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tail</span> = <span class="e Plus"><span class="e Identifier"><span class="i">head</span></span> + <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>

        <span class="s While"><span class="k">while</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">tail</span></span> &gt; <span class="e Identifier"><span class="i">head</span></span></span> &amp;&amp; <span class="e Call"><span class="e Identifier"><span class="i">isSpace</span></span>(*(<span class="i">tail</span>-<span class="n">1</span>))</span></span>)
               <span class="s Scope"><span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">tail</span></span></span>;</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">head</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Identifier"><span class="i">tail</span></span> - <span class="e Identifier"><span class="i">head</span></span></span>]</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Trim the given array by stripping the provided match from
        both ends. Returns a slice of the original content

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">strip</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">S</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="i">match</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">head</span> = <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tail</span> = <span class="e Plus"><span class="e Identifier"><span class="i">head</span></span> + <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>

        <span class="s While"><span class="k">while</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">head</span></span> &lt; <span class="e Identifier"><span class="i">tail</span></span></span> &amp;&amp; <span class="e Identity"><span class="e Deref">*<span class="e Identifier"><span class="i">head</span></span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">match</span></span></span></span>)
               <span class="s Scope"><span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">head</span></span></span>;</span></span></span>

        <span class="s While"><span class="k">while</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">tail</span></span> &gt; <span class="e Identifier"><span class="i">head</span></span></span> &amp;&amp; <span class="e Identity"><span class="e Deref">*<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">tail</span></span>-<span class="e Int"><span class="n">1</span></span></span>)</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">match</span></span></span></span>)
               <span class="s Scope"><span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">tail</span></span></span>;</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">head</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Identifier"><span class="i">tail</span></span> - <span class="e Identifier"><span class="i">head</span></span></span>]</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Trim the given array by stripping the provided match from
        the left hand side. Returns a slice of the original content

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">stripl</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">S</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="i">match</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">head</span> = <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tail</span> = <span class="e Plus"><span class="e Identifier"><span class="i">head</span></span> + <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>

        <span class="s While"><span class="k">while</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">head</span></span> &lt; <span class="e Identifier"><span class="i">tail</span></span></span> &amp;&amp; <span class="e Identity"><span class="e Deref">*<span class="e Identifier"><span class="i">head</span></span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">match</span></span></span></span>)
               <span class="s Scope"><span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">head</span></span></span>;</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">head</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Identifier"><span class="i">tail</span></span> - <span class="e Identifier"><span class="i">head</span></span></span>]</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Trim the given array by stripping the provided match from
        the right hand side. Returns a slice of the original content

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">stripr</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">S</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="i">match</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">head</span> = <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tail</span> = <span class="e Plus"><span class="e Identifier"><span class="i">head</span></span> + <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>

        <span class="s While"><span class="k">while</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">tail</span></span> &gt; <span class="e Identifier"><span class="i">head</span></span></span> &amp;&amp; <span class="e Identity"><span class="e Deref">*<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">tail</span></span>-<span class="e Int"><span class="n">1</span></span></span>)</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">match</span></span></span></span>)
               <span class="s Scope"><span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">tail</span></span></span>;</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">head</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Identifier"><span class="i">tail</span></span> - <span class="e Identifier"><span class="i">head</span></span></span>]</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Chop the given source by stripping the provided match from
        the left hand side. Returns a slice of the original content

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">chopl</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">S</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="i">match</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt;= <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
            <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Slice"><span class="e Identifier"><span class="i">source</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span>]</span> == <span class="e Identifier"><span class="i">match</span></span></span>)
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">source</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">source</span></span> [<span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span> .. <span class="e Dollar">$</span>]</span></span>;</span></span></span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">source</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Chop the given source by stripping the provided match from
        the right hand side. Returns a slice of the original content

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">chopr</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">S</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="i">match</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt;= <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
            <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Slice"><span class="e Identifier"><span class="i">source</span></span>[<span class="e Minus"><span class="e Dollar">$</span>-<span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> .. <span class="e Dollar">$</span>]</span> == <span class="e Identifier"><span class="i">match</span></span></span>)
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">source</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">source</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Dollar">$</span>-<span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span></span>;</span></span></span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">source</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Replace all instances of one element with another (in place)

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">replace</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">S</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="i">replacement</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="k">ref</span> <span class="i">c</span></span></span>; <span class="e Identifier"><span class="i">source</span></span>)
                 <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">match</span></span></span>)
                     <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Identifier"><span class="i">replacement</span></span></span>;</span></span></span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">source</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Substitute all instances of match from source. Set replacement
        to null in order to remove instead of replace

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">substitute</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">replacement</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">output</span>;</span></span>

        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">s</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">patterns</span></span> (<span class="i">source</span>, <span class="i">match</span>, <span class="i">replacement</span>)</span>)
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output</span></span> ~= <span class="e Identifier"><span class="i">s</span></span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">output</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Count all instances of match within source 

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">count</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">c</span>;</span></span>

        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">s</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">patterns</span></span> (<span class="i">source</span>, <span class="i">match</span>)</span>)
                    <span class="s Scope"><span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">c</span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span>)</span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Minus"><span class="e Identifier"><span class="i">c</span></span> - <span class="e Int"><span class="n">1</span></span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Returns whether or not the provided array contains an instance
        of the given match
        
******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">contains</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span> <span class="i">match</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="i">source</span>.<span class="i">ptr</span>, <span class="i">match</span>, <span class="i">source</span>.<span class="i">length</span>)</span> != <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Returns whether or not the provided array contains an instance
        of the given match
        
******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">containsPattern</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">locatePattern</span></span> (<span class="i">source</span>, <span class="i">match</span>)</span> != <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Return the index of the next instance of 'match' starting at
        position 'start', or source.length where there is no match.

        Parameter 'start' defaults to 0

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">index</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">U</span>=<span class="t Identifier"><span class="i">size_t</span></span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">U</span></span> <span class="i">start</span>=<span class="e Int"><span class="n">0</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">index</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> (<span class="i">source</span>, <span class="i">match</span>, <span class="i">start</span>)</span>;</span>}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">index</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">start</span>=<span class="e Int"><span class="n">0</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Cond"><span class="e Paren">(<span class="e Identity"><span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span>)</span> ? <span class="e Call"><span class="e Identifier"><span class="i">locate</span></span> (<span class="i">source</span>, <span class="i">match</span>[<span class="n">0</span>], <span class="i">start</span>)</span> 
                                   : <span class="e Call"><span class="e Identifier"><span class="i">locatePattern</span></span> (<span class="i">source</span>, <span class="i">match</span>, <span class="i">start</span>)</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Return the index of the prior instance of 'match' starting
        just before 'start', or source.length where there is no match.

        Parameter 'start' defaults to source.length

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">rindex</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">U</span>=<span class="t Identifier"><span class="i">size_t</span></span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">U</span></span> <span class="i">start</span>=<span class="e Identifier"><span class="i">U</span></span>.<span class="e Identifier"><span class="i">max</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">rindex</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="i">source</span>, <span class="i">match</span>, <span class="i">start</span>)</span>;</span>}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">rindex</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">start</span>=<span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">max</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Cond"><span class="e Paren">(<span class="e Identity"><span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span>)</span> ? <span class="e Call"><span class="e Identifier"><span class="i">locatePrior</span></span> (<span class="i">source</span>, <span class="i">match</span>[<span class="n">0</span>], <span class="i">start</span>)</span> 
                                   : <span class="e Call"><span class="e Identifier"><span class="i">locatePatternPrior</span></span> (<span class="i">source</span>, <span class="i">match</span>, <span class="i">start</span>)</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Return the index of the next instance of 'match' starting at
        position 'start', or source.length where there is no match.

        Parameter 'start' defaults to 0

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">locate</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">U</span>=<span class="t Identifier"><span class="i">size_t</span></span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">U</span></span> <span class="i">start</span>=<span class="e Int"><span class="n">0</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">locate</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> (<span class="i">source</span>, <span class="i">match</span>, <span class="i">start</span>)</span>;</span>}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">locate</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">start</span>=<span class="e Int"><span class="n">0</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">start</span></span> &gt; <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span></span>
        
        <span class="s Return"><span class="k">return</span> <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="i">source</span>.<span class="i">ptr</span>+<span class="i">start</span>, <span class="i">match</span>, <span class="i">source</span>.<span class="i">length</span> - <span class="i">start</span>)</span> + <span class="e Identifier"><span class="i">start</span></span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Return the index of the prior instance of 'match' starting
        just before 'start', or source.length where there is no match.

        Parameter 'start' defaults to source.length

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">locatePrior</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">U</span>=<span class="t Identifier"><span class="i">size_t</span></span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">U</span></span> <span class="i">start</span>=<span class="e Identifier"><span class="i">U</span></span>.<span class="e Identifier"><span class="i">max</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">locatePrior</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="i">source</span>, <span class="i">match</span>, <span class="i">start</span>)</span>;</span>}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">locatePrior</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">start</span>=<span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">max</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">start</span></span> &gt; <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span></span>

        <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Identifier"><span class="i">start</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span>)
               <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Identity"><span class="e Index"><span class="e Identifier"><span class="i">source</span></span>[<span class="e PreDecr">--<span class="e Identifier"><span class="i">start</span></span></span>]</span> <span class="k">is</span> <span class="e Identifier"><span class="i">match</span></span></span>)
                   <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">start</span></span>;</span></span></span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Return the index of the next instance of 'match' starting at
        position 'start', or source.length where there is no match. 

        Parameter 'start' defaults to 0

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">locatePattern</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">U</span>=<span class="t Identifier"><span class="i">size_t</span></span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">U</span></span> <span class="i">start</span>=<span class="e Int"><span class="n">0</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">locatePattern</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> (<span class="i">source</span>, <span class="i">match</span>, <span class="i">start</span>)</span>;</span>}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">locatePattern</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">start</span>=<span class="e Int"><span class="n">0</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>    <span class="i">idx</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">p</span> = <span class="e Plus"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">ptr</span></span> + <span class="e Identifier"><span class="i">start</span></span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>    <span class="i">extent</span> = <span class="e Plus"><span class="e Minus"><span class="e Minus"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span> - <span class="e Identifier"><span class="i">start</span></span></span> - <span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> + <span class="e Int"><span class="n">1</span></span></span>;</span></span>

        <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">extent</span></span> &lt;= <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>)
            <span class="s Scope"><span class="s Compound">{
            <span class="s While"><span class="k">while</span> (<span class="e Identifier"><span class="i">extent</span></span>)
                   <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Identity"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">idx</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="i">p</span>, <span class="i">match</span>[<span class="n">0</span>], <span class="i">extent</span>)</span></span>)</span> <span class="k">is</span> <span class="e Identifier"><span class="i">extent</span></span></span>)
                        <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span>
                   <span class="k">else</span>
                      <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">matching</span></span> (<span class="i">p</span>+=<span class="i">idx</span>, <span class="i">match</span>.<span class="i">ptr</span>, <span class="i">match</span>.<span class="i">length</span>)</span>)
                          <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Minus"><span class="e Identifier"><span class="i">p</span></span> - <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">ptr</span></span></span>;</span></span>
                      <span class="k">else</span>
                         <span class="s Scope"><span class="s Compound">{
                         <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">extent</span></span> -= <span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">idx</span></span>+<span class="e Int"><span class="n">1</span></span></span>)</span></span>;</span>
                         <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">p</span></span></span>;</span>
                         }</span></span></span></span></span></span></span>
            }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span>;</span>
}</span></span></span></span></span>
   
<span class="bc">/******************************************************************************

        Return the index of the prior instance of 'match' starting
        just before 'start', or source.length where there is no match.

        Parameter 'start' defaults to source.length

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">locatePatternPrior</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">U</span>=<span class="t Identifier"><span class="i">size_t</span></span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">U</span></span> <span class="i">start</span>=<span class="e Identifier"><span class="i">U</span></span>.<span class="e Identifier"><span class="i">max</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">locatePatternPrior</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="i">source</span>, <span class="i">match</span>, <span class="i">start</span>)</span>;</span>}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">locatePatternPrior</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">start</span>=<span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">max</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">len</span> = <span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">length</span></span>;</span></span>
        
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">start</span></span> &gt; <span class="e Identifier"><span class="i">len</span></span></span>)
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Identifier"><span class="i">len</span></span></span>;</span></span></span>

        <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt;= <span class="e Identifier"><span class="i">len</span></span></span></span>)
            <span class="s Scope"><span class="s While"><span class="k">while</span> (<span class="e Identifier"><span class="i">start</span></span>)
                  <span class="s Scope"><span class="s Compound">{
                  <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">locatePrior</span></span> (<span class="i">source</span>, <span class="i">match</span>[<span class="n">0</span>], <span class="i">start</span>)</span></span>;</span>
                  <span class="s If"><span class="k">if</span> (<span class="e Identity"><span class="e Identifier"><span class="i">start</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">len</span></span></span>)
                      <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span>
                  <span class="k">else</span>
                     <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">start</span></span> + <span class="e Identifier"><span class="i">match</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)</span> &lt;= <span class="e Identifier"><span class="i">len</span></span></span>)
                          <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">matching</span></span> (<span class="i">source</span>.<span class="i">ptr</span>+<span class="i">start</span>, <span class="i">match</span>.<span class="i">ptr</span>, <span class="i">match</span>.<span class="i">length</span>)</span>)
                              <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">start</span></span>;</span></span></span></span></span></span></span>
                  }</span></span></span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">len</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Split the provided array on the first pattern instance, and 
        return the resultant head and tail. The pattern is excluded 
        from the two segments. 

        Where a segment is not found, tail will be null and the return
        value will be the original array.
        
******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">head</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">S</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span><span class="t Array">[]</span> <span class="i">pattern</span></span>, <span class="o Parameter"><span class="k">out</span> <span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">tail</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">i</span> = <span class="e Call"><span class="e Identifier"><span class="i">locatePattern</span></span> (<span class="i">src</span>, <span class="i">pattern</span>)</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> != <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
           <span class="s Scope"><span class="s Compound">{
           <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Plus"><span class="e Identifier"><span class="i">i</span></span> + <span class="e Identifier"><span class="i">pattern</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> .. <span class="e Dollar">$</span>]</span></span>;</span>
           <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">src</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">i</span></span>]</span></span>;</span>
           }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">src</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Split the provided array on the last pattern instance, and 
        return the resultant head and tail. The pattern is excluded 
        from the two segments. 

        Where a segment is not found, head will be null and the return
        value will be the original array.
        
******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">tail</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">S</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span><span class="t Array">[]</span> <span class="i">pattern</span></span>, <span class="o Parameter"><span class="k">out</span> <span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">head</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">i</span> = <span class="e Call"><span class="e Identifier"><span class="i">locatePatternPrior</span></span> (<span class="i">src</span>, <span class="i">pattern</span>)</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> != <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
           <span class="s Scope"><span class="s Compound">{
           <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">i</span></span>]</span></span>;</span>
           <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">src</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Plus"><span class="e Identifier"><span class="i">i</span></span> + <span class="e Identifier"><span class="i">pattern</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> .. <span class="e Dollar">$</span>]</span></span>;</span>
           }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">src</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Split the provided array wherever a delimiter-set instance is
        found, and return the resultant segments. The delimiters are
        excluded from each of the segments. Note that delimiters are
        matched as a set of alternates rather than as a pattern.

        Splitting on a single delimiter is considerably faster than
        splitting upon a set of alternatives. 

        Note that the src content is not duplicated by this function, 
        but is sliced instead.

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">delimit</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">M</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">M</span></span>)</span><span class="t Array">[]</span> <span class="i">set</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">result</span>;</span></span>

        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">segment</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">delimiters</span></span> (<span class="i">src</span>, <span class="i">set</span>)</span>)
                 <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">result</span></span> ~= <span class="e Identifier"><span class="i">segment</span></span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Split the provided array wherever a pattern instance is
        found, and return the resultant segments. The pattern is
        excluded from each of the segments.
        
        Note that the src content is not duplicated by this function, 
        but is sliced instead.

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">split</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">pattern</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">result</span>;</span></span>

        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">segment</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">patterns</span></span> (<span class="k">cast</span>(<span class="k">const</span>(<span class="i">T</span>)[])<span class="i">src</span>, <span class="i">pattern</span>)</span>)
                 <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">result</span></span> ~= <span class="e Identifier"><span class="i">segment</span></span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span><span class="t Array">[]</span>)<span class="e Identifier"><span class="i">result</span></span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Convert text into a set of lines, where each line is identified
        by a \n or \r\n combination. The line terminator is stripped from
        each resultant array

        Note that the src content is not duplicated by this function, but
        is sliced instead.

******************************************************************************/</span>

<span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">toLines</span></span> <span class="i">splitLines</span>;</span></span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">toLines</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">src</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">result</span>;</span></span>

        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">line</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">lines</span></span> (<span class="i">src</span>)</span>)
                 <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">result</span></span> ~= <span class="e Identifier"><span class="i">line</span></span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Return the indexed line, where each line is identified by a \n 
        or \r\n combination. The line terminator is stripped from the 
        resultant line

        Note that src content is not duplicated by this function, but
        is sliced instead.

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">lineOf</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">index</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">line</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">lines</span></span> (<span class="i">src</span>)</span>)
                 <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Identity"><span class="e PostIncr"><span class="e Identifier"><span class="i">i</span></span>++</span> <span class="k">is</span> <span class="e Identifier"><span class="i">index</span></span></span>)
                     <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">line</span></span>;</span></span></span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Combine a series of text segments together, each appended with 
        a postfix pattern. An optional output buffer can be provided to
        avoid heap activity - it should be large enough to contain the 
        entire output, otherwise the heap will be used instead.

        Returns a valid slice of the output, containing the concatenated
        text.

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">join</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span>)</span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">postfix</span>=<span class="e Null"><span class="k">null</span></span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">dst</span>=<span class="e Null"><span class="k">null</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">combine</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> (<span class="i">dst</span>, <span class="k">null</span>, <span class="i">postfix</span>, <span class="i">src</span>)</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Combine a series of text segments together, each prepended with 
        a prefix pattern. An optional output buffer can be provided to 
        avoid heap activity - it should be large enough to contain the 
        entire output, otherwise the heap will be used instead.

        Note that, unlike join(), the output buffer is specified first
        such that a set of trailing strings can be provided. 

        Returns a valid slice of the output, containing the concatenated
        text.

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">prefix</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">dst</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">prefix</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span>)</span><span class="t Array">[]</span> <span class="i">src</span>...</span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">combine</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> (<span class="i">dst</span>, <span class="i">prefix</span>, <span class="k">null</span>, <span class="i">src</span>)</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Combine a series of text segments together, each appended with an 
        optional postfix pattern. An optional output buffer can be provided
        to avoid heap activity - it should be large enough to contain the 
        entire output, otherwise the heap will be used instead.

        Note that, unlike join(), the output buffer is specified first
        such that a set of trailing strings can be provided. 

        Returns a valid slice of the output, containing the concatenated
        text.

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">postfix</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">dst</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">postfix</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span>)</span><span class="t Array">[]</span> <span class="i">src</span>...</span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">combine</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> (<span class="i">dst</span>, <span class="k">null</span>, <span class="i">postfix</span>, <span class="i">src</span>)</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Combine a series of text segments together, each prefixed and/or 
        postfixed with optional strings. An optional output buffer can be 
        provided to avoid heap activity - which should be large enough to 
        contain the entire output, otherwise the heap will be used instead.

        Note that, unlike join(), the output buffer is specified first
        such that a set of trailing strings can be provided. 

        Returns a valid slice of the output, containing the concatenated
        text.

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">combine</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">dst</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">prefix</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">postfix</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span>)</span><span class="t Array">[]</span> <span class="i">src</span> ...</span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">len</span> = <span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span> * <span class="e Identifier"><span class="i">prefix</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> + 
                   <span class="e Mul"><span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span> * <span class="e Identifier"><span class="i">postfix</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>;</span></span>

        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">segment</span></span></span>; <span class="e Identifier"><span class="i">src</span></span>)
                 <span class="s Scope"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">len</span></span> += <span class="e Identifier"><span class="i">segment</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span></span>
               
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">dst</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt; <span class="e Identifier"><span class="i">len</span></span></span>)
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">dst</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Identifier"><span class="i">len</span></span></span>;</span></span></span>
            
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">p</span> = <span class="e Identifier"><span class="i">dst</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">segment</span></span></span>; <span class="e Identifier"><span class="i">src</span></span>)
                <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">p</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">prefix</span></span>.<span class="e Identifier"><span class="i">length</span></span>]</span> = <span class="e Identifier"><span class="i">prefix</span></span></span>;</span>
                <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">p</span></span> += <span class="e Identifier"><span class="i">prefix</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">p</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">segment</span></span>.<span class="e Identifier"><span class="i">length</span></span>]</span> = <span class="e Identifier"><span class="i">segment</span></span></span>;</span>
                <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">p</span></span> += <span class="e Identifier"><span class="i">segment</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">p</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">postfix</span></span>.<span class="e Identifier"><span class="i">length</span></span>]</span> = <span class="e Identifier"><span class="i">postfix</span></span></span>;</span>
                <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">p</span></span> += <span class="e Identifier"><span class="i">postfix</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
                }</span></span></span>

        <span class="lc">// remove trailing seperator</span>
        <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">len</span></span>)
            <span class="s Scope"><span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">len</span></span> -= <span class="e Identifier"><span class="i">postfix</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">dst</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">len</span></span>]</span>;</span>       
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Repeat an array for a specific number of times. An optional output 
        buffer can be provided to avoid heap activity - it should be large 
        enough to contain the entire output, otherwise the heap will be used 
        instead.

        Returns a valid slice of the output, containing the concatenated
        text.

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">repeat</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">U</span>=<span class="t Identifier"><span class="i">size_t</span></span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">U</span></span> <span class="i">count</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">dst</span>=<span class="e Null"><span class="k">null</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">repeat</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="i">src</span>, <span class="i">count</span>, <span class="i">dst</span>)</span>;</span>}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">repeat</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">count</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">dst</span>=<span class="e Null"><span class="k">null</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">len</span> = <span class="e Mul"><span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span> * <span class="e Identifier"><span class="i">count</span></span></span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Identity"><span class="e Identifier"><span class="i">len</span></span> <span class="k">is</span> <span class="e Int"><span class="n">0</span></span></span>)
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span></span></span>

        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">dst</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt; <span class="e Identifier"><span class="i">len</span></span></span>)
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">dst</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Identifier"><span class="i">len</span></span></span>;</span></span></span>
            
        <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">p</span> = <span class="e Identifier"><span class="i">dst</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span> <span class="e PostDecr"><span class="e Identifier"><span class="i">count</span></span>--</span>; <span class="e PlusAssign"><span class="e Identifier"><span class="i">p</span></span> += <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
             <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">p</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span>]</span> = <span class="e Identifier"><span class="i">src</span></span></span>;</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">dst</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">len</span></span>]</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Is the argument a whitespace character?

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">isSpace</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">c</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identity"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span>)
                   <span class="s Return"><span class="k">return</span> <span class="e Paren">(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Int"><span class="n">32</span></span></span> &amp;&amp; <span class="e Paren">(<span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">' '</span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\t</span>'</span></span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\r</span>'</span></span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\n</span>'</span></span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\f</span>'</span></span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\v</span>'</span></span></span></span>)</span></span>)</span>;</span>
        <span class="k">else</span>
           <span class="s Return"><span class="k">return</span> <span class="e OrOr"><span class="e Paren">(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Int"><span class="n">32</span></span></span> &amp;&amp; <span class="e Paren">(<span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">' '</span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\t</span>'</span></span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\r</span>'</span></span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\n</span>'</span></span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\f</span>'</span></span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\v</span>'</span></span></span></span>)</span></span>)</span> || <span class="e Paren">(<span class="e OrOr"><span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\u2028</span>'</span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\u2029</span>'</span></span></span></span>)</span></span>;</span></span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Return whether or not the two arrays have matching content
        
******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">matching</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">U</span>=<span class="t Identifier"><span class="i">size_t</span></span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">s1</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">s2</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">U</span></span> <span class="i">length</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">matching</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> (<span class="i">s1</span>, <span class="i">s2</span>, <span class="i">length</span>)</span>;</span>}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">matching</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">s1</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">s2</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">length</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span>(<span class="i">s1</span>, <span class="i">s2</span>, <span class="i">length</span>)</span> <span class="k">is</span> <span class="e Identifier"><span class="i">length</span></span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Returns the index of the first match in str, failing once
        length is reached. Note that we return 'length' for failure
        and a 0-based index on success

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">indexOf</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">U</span>=<span class="t Identifier"><span class="i">size_t</span></span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">str</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">U</span></span> <span class="i">length</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">indexOf</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> (<span class="i">str</span>, <span class="i">match</span>, <span class="i">length</span>)</span>;</span>}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">indexOf</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">str</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span> <span class="i">match</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">length</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="lc">//assert (str);</span>

        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span> == <span class="e Int"><span class="n">1</span></span></span>)
                   <span class="s Declaration"><span class="d Enum"><span class="k">enum</span> : <span class="t Identifier"><span class="i">size_t</span></span> {<span class="d EnumMember"><span class="t Identifier"><span class="i">m1</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span>) <span class="e Int"><span class="n">0x0101010101010101</span></span></span></span>, 
                                  <span class="d EnumMember"><span class="t Identifier"><span class="i">m2</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span>) <span class="e Int"><span class="n">0x8080808080808080</span></span></span></span>}</span></span></span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span> == <span class="e Int"><span class="n">2</span></span></span>)
                   <span class="s Declaration"><span class="d Enum"><span class="k">enum</span> : <span class="t Identifier"><span class="i">size_t</span></span> {<span class="d EnumMember"><span class="t Identifier"><span class="i">m1</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span>) <span class="e Int"><span class="n">0x0001000100010001</span></span></span></span>, 
                                  <span class="d EnumMember"><span class="t Identifier"><span class="i">m2</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span>) <span class="e Int"><span class="n">0x8000800080008000</span></span></span></span>}</span></span></span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span> == <span class="e Int"><span class="n">4</span></span></span>)
                   <span class="s Declaration"><span class="d Enum"><span class="k">enum</span> : <span class="t Identifier"><span class="i">size_t</span></span> {<span class="d EnumMember"><span class="t Identifier"><span class="i">m1</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span>) <span class="e Int"><span class="n">0x0000000100000001</span></span></span></span>, 
                                  <span class="d EnumMember"><span class="t Identifier"><span class="i">m2</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span>) <span class="e Int"><span class="n">0x8000000080000000</span></span></span></span>}</span></span></span>

        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span> &lt; <span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span>)
        <span class="s Compound">{
                <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">length</span></span>)
                   <span class="s Scope"><span class="s Compound">{
                   <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">m</span> = <span class="e Identifier"><span class="i">match</span></span>;</span></span>
                   <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">m</span></span> += <span class="e LShift"><span class="e Identifier"><span class="i">m</span></span> &lt;&lt; <span class="e Paren">(<span class="e Mul"><span class="e Int"><span class="n">8</span></span> * <span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span>)</span></span></span>;</span>

                   <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span> &lt; <span class="e Div"><span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span> / <span class="e Int"><span class="n">2</span></span></span></span>)
                              <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">m</span></span> += <span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">m</span></span> &lt;&lt; <span class="e Paren">(<span class="e Mul"><span class="e Mul"><span class="e Int"><span class="n">8</span></span> * <span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span> * <span class="e Int"><span class="n">2</span></span></span>)</span></span>)</span></span>;</span></span>

                   <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span> &lt; <span class="e Div"><span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span> / <span class="e Int"><span class="n">4</span></span></span></span>)
                              <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">m</span></span> += <span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">m</span></span> &lt;&lt; <span class="e Paren">(<span class="e Mul"><span class="e Mul"><span class="e Int"><span class="n">8</span></span> * <span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span> * <span class="e Int"><span class="n">4</span></span></span>)</span></span>)</span></span>;</span></span>

                   <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">p</span> = <span class="e Identifier"><span class="i">str</span></span>;</span></span>
                   <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">e</span> = <span class="e Minus"><span class="e Plus"><span class="e Identifier"><span class="i">p</span></span> + <span class="e Identifier"><span class="i">length</span></span></span> - <span class="e Div"><span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span>/<span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span></span>;</span></span>
                   <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Identifier"><span class="i">p</span></span> &lt; <span class="e Identifier"><span class="i">e</span></span></span>)
                         <span class="s Scope"><span class="s Compound">{
                         <span class="lc">// clear matching T segments</span>
                         <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">v</span> = <span class="e Xor"><span class="e Paren">(<span class="e Deref">*<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span><span class="t Pointer">*</span>) <span class="e Identifier"><span class="i">p</span></span></span></span>)</span> ^ <span class="e Identifier"><span class="i">m</span></span></span>;</span></span>
                         <span class="lc">// test for zero, courtesy of Alan Mycroft</span>
                         <span class="s If"><span class="k">if</span> (<span class="e And"><span class="e And"><span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">v</span></span> - <span class="e Identifier"><span class="i">m1</span></span></span>)</span> &amp; <span class="e Comp">~<span class="e Identifier"><span class="i">v</span></span></span></span> &amp; <span class="e Identifier"><span class="i">m2</span></span></span>)
                              <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                         <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">p</span></span> += <span class="e Div"><span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span>/<span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span></span>;</span>
                         }</span></span></span>

                   <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">e</span></span> += <span class="e Div"><span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span>/<span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span></span>;</span>
                   <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Identifier"><span class="i">p</span></span> &lt; <span class="e Identifier"><span class="i">e</span></span></span>)
                          <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Identity"><span class="e PostIncr"><span class="e Deref">*<span class="e Identifier"><span class="i">p</span></span></span>++</span> <span class="k">is</span> <span class="e Identifier"><span class="i">match</span></span></span>)
                              <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span>) <span class="e Paren">(<span class="e Minus"><span class="e Minus"><span class="e Identifier"><span class="i">p</span></span> - <span class="e Identifier"><span class="i">str</span></span></span> - <span class="e Int"><span class="n">1</span></span></span>)</span></span>;</span></span></span></span></span>
                   }</span></span></span>
                <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">length</span></span>;</span>
        }</span>
        <span class="k">else</span>
        <span class="s Compound">{
                <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">len</span> = <span class="e Identifier"><span class="i">length</span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">p</span>=<span class="e Minus"><span class="e Identifier"><span class="i">str</span></span>-<span class="e Int"><span class="n">1</span></span></span>;</span></span> <span class="e PostDecr"><span class="e Identifier"><span class="i">len</span></span>--</span>;)
                     <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Identity"><span class="e Deref">*<span class="e PreIncr">++<span class="e Identifier"><span class="i">p</span></span></span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">match</span></span></span>)
                         <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span>) <span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">p</span></span> - <span class="e Identifier"><span class="i">str</span></span></span>)</span></span>;</span></span></span></span></span>
                <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">length</span></span>;</span>
        }</span></span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Returns the index of a mismatch between s1 &amp; s2, failing when
        length is reached. Note that we return 'length' upon failure
        (array content matches) and a 0-based index upon success.

        Use this as a faster opEquals. Also provides the basis for a
        faster opCmp, since the index of the first mismatched character
        can be used to determine the return value

******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">mismatch</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">U</span>=<span class="t Identifier"><span class="i">size_t</span></span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">s1</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">s2</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">U</span></span> <span class="i">length</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">mismatch</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="i">s1</span>, <span class="i">s2</span>, <span class="i">length</span>)</span>;</span>}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">mismatch</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">s1</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Pointer">*</span> <span class="i">s2</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">length</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Identifier"><span class="i">s1</span></span> &amp;&amp; <span class="e Identifier"><span class="i">s2</span></span></span>)</span>;</span>

        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span> &lt; <span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span>)
        <span class="s Compound">{
                <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">length</span></span>)
                   <span class="s Scope"><span class="s Compound">{
                   <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">start</span> = <span class="e Identifier"><span class="i">s1</span></span>;</span></span>
                   <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">e</span> = <span class="e Minus"><span class="e Plus"><span class="e Identifier"><span class="i">start</span></span> + <span class="e Identifier"><span class="i">length</span></span></span> - <span class="e Div"><span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span>/<span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span></span>;</span></span>

                   <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Identifier"><span class="i">s1</span></span> &lt; <span class="e Identifier"><span class="i">e</span></span></span>)
                         <span class="s Scope"><span class="s Compound">{
                         <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Deref">*<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span><span class="t Pointer">*</span>) <span class="e Identifier"><span class="i">s1</span></span></span></span> != <span class="e Deref">*<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">size_t</span></span><span class="t Pointer">*</span>) <span class="e Identifier"><span class="i">s2</span></span></span></span></span>)
                             <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                         <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">s1</span></span> += <span class="e Div"><span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span>/<span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span></span>;</span>
                         <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">s2</span></span> += <span class="e Div"><span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span>/<span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span></span>;</span>
                         }</span></span></span>

                   <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">e</span></span> += <span class="e Div"><span class="e Identifier"><span class="i">size_t</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span>/<span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">sizeof</span></span></span></span>;</span>
                   <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Identifier"><span class="i">s1</span></span> &lt; <span class="e Identifier"><span class="i">e</span></span></span>)
                          <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e PostIncr"><span class="e Deref">*<span class="e Identifier"><span class="i">s1</span></span></span>++</span> != <span class="e PostIncr"><span class="e Deref">*<span class="e Identifier"><span class="i">s2</span></span></span>++</span></span>)
                              <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Minus"><span class="e Minus"><span class="e Identifier"><span class="i">s1</span></span> - <span class="e Identifier"><span class="i">start</span></span></span> - <span class="e Int"><span class="n">1</span></span></span>;</span></span></span></span></span>
                   }</span></span></span>
                <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">length</span></span>;</span>
        }</span>
        <span class="k">else</span>
        <span class="s Compound">{
                <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">len</span> = <span class="e Identifier"><span class="i">length</span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">p</span>=<span class="e Minus"><span class="e Identifier"><span class="i">s1</span></span>-<span class="e Int"><span class="n">1</span></span></span>;</span></span> <span class="e PostDecr"><span class="e Identifier"><span class="i">len</span></span>--</span>;)
                     <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Deref">*<span class="e PreIncr">++<span class="e Identifier"><span class="i">p</span></span></span></span> != <span class="e PostIncr"><span class="e Deref">*<span class="e Identifier"><span class="i">s2</span></span></span>++</span></span>)
                         <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Minus"><span class="e Identifier"><span class="i">p</span></span> - <span class="e Identifier"><span class="i">s1</span></span></span>;</span></span></span></span></span>
                <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">length</span></span>;</span>
        }</span></span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Iterator to isolate lines.

        Converts text into a set of lines, where each line is identified
        by a \n or \r\n combination. The line terminator is stripped from
        each resultant array.

        ---
        foreach (line; lines ("one\ntwo\nthree"))
                 ...
        ---
        
******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">LineFruct</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> <span class="i">lines</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">src</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">LineFruct</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> <span class="i">lines</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">lines</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Identifier"><span class="i">src</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">lines</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Iterator to isolate text elements.

        Splits the provided array wherever a delimiter-set instance is
        found, and return the resultant segments. The delimiters are
        excluded from each of the segments. Note that delimiters are
        matched as a set of alternates rather than as a pattern.

        Splitting on a single delimiter is considerably faster than
        splitting upon a set of alternatives.

        ---
        foreach (segment; delimiters ("one,two;three", ",;"))
                 ...
        ---
        
******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">DelimFruct</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>, <span class="t Identifier"><span class="i">M</span></span>)</span></span> <span class="i">delimiters</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">M</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">M</span></span>)</span><span class="t Array">[]</span> <span class="i">set</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">DelimFruct</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>, <span class="t Identifier"><span class="i">M</span></span>)</span></span> <span class="i">elements</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">elements</span></span>.<span class="e Identifier"><span class="i">set</span></span> = <span class="e Identifier"><span class="i">set</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">elements</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Identifier"><span class="i">src</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">elements</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Iterator to isolate text elements.

        Split the provided array wherever a pattern instance is found, 
        and return the resultant segments. Pattern are excluded from
        each of the segments, and an optional sub argument enables 
        replacement.
        
        ---
        foreach (segment; patterns ("one, two, three", ", "))
                 ...
        ---
        
******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">PatternFruct</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> <span class="i">patterns</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">pattern</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">sub</span>=<span class="e Null"><span class="k">null</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">PatternFruct</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> <span class="i">elements</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">elements</span></span>.<span class="e Identifier"><span class="i">pattern</span></span> = <span class="e Identifier"><span class="i">pattern</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">elements</span></span>.<span class="e Identifier"><span class="i">sub</span></span> = <span class="e Identifier"><span class="i">sub</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">elements</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Identifier"><span class="i">src</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">elements</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Iterator to isolate optionally quoted text elements.

        As per elements(), but with the extension of being quote-aware;
        the set of delimiters is ignored inside a pair of quotes. Note
        that an unterminated quote will consume remaining content.
        
        ---
        foreach (quote; quotes ("one two 'three four' five", " "))
                 ...
        ---
        
******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">QuoteFruct</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>, <span class="t Identifier"><span class="i">M</span></span>)</span></span> <span class="i">quotes</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">M</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">M</span></span>)</span><span class="t Array">[]</span> <span class="i">set</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">QuoteFruct</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>, <span class="t Identifier"><span class="i">M</span></span>)</span></span> <span class="i">quotes</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">quotes</span></span>.<span class="e Identifier"><span class="i">set</span></span> = <span class="e Identifier"><span class="i">set</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">quotes</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Identifier"><span class="i">src</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">quotes</span></span>;</span>
}</span></span></span></span></span>

<span class="bc">/*******************************************************************************

        Arranges text strings in order, using indices to specify where
        each particular argument should be positioned within the text. 
        This is handy for collating I18N components, or as a simplistic
        and lightweight formatter. Indices range from zero through nine. 
        
        ---
        // write ordered text to the console
        char[64] tmp;

        Cout (layout (tmp, "%1 is after %0", "zero", "one")).newline;
        ---

*******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">layout</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">output</span></span>, <span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span>)</span><span class="t Array">[]</span> <span class="i">layout</span> ...</span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">badarg</span>  = <span class="e Cast"><span class="k">cast</span>(<span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span>)<span class="e String"><span class="sl">"{index out of range}"</span></span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">toosmall</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span>)<span class="e String"><span class="sl">"{output buffer too small}"</span></span></span>;</span></span>
        
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>  <span class="i">pos</span>,
                <span class="i">args</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span>    <span class="i">state</span>;</span></span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">args</span></span> = <span class="e Minus"><span class="e Identifier"><span class="i">layout</span></span>.<span class="e Identifier"><span class="i">length</span></span> - <span class="e Int"><span class="n">1</span></span></span></span>;</span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">c</span></span></span>; <span class="e Index"><span class="e Identifier"><span class="i">layout</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>)
                <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">state</span></span>)
                   <span class="s Scope"><span class="s Compound">{
                   <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">state</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
                   <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &gt;= <span class="e Char"><span class="cl">'0'</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Char"><span class="cl">'9'</span></span></span></span>)
                      <span class="s Scope"><span class="s Compound">{
                      <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">index</span> = <span class="e Minus"><span class="e Identifier"><span class="i">c</span></span> - <span class="e Char"><span class="cl">'0'</span></span></span>;</span></span>
                      <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">index</span></span> &lt; <span class="e Identifier"><span class="i">args</span></span></span>)
                         <span class="s Scope"><span class="s Compound">{
                         <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">x</span> = <span class="e Index"><span class="e Identifier"><span class="i">layout</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">index</span></span>+<span class="e Int"><span class="n">1</span></span></span>]</span>;</span></span>

                         <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">limit</span> = <span class="e Plus"><span class="e Identifier"><span class="i">pos</span></span> + <span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                         <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">limit</span></span> &lt; <span class="e Identifier"><span class="i">output</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
                            <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">output</span></span> [<span class="e Identifier"><span class="i">pos</span></span> .. <span class="e Identifier"><span class="i">limit</span></span>]</span> = <span class="e Identifier"><span class="i">x</span></span></span>;</span>
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">pos</span></span> = <span class="e Identifier"><span class="i">limit</span></span></span>;</span>
                            <span class="s Continue"><span class="k">continue</span>;</span>
                            }</span></span> 
                         <span class="k">else</span>
                            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">toosmall</span></span>.<span class="e Identifier"><span class="i">dup</span></span>;</span></span></span>
                         }</span></span>
                      <span class="k">else</span>
                         <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">badarg</span></span>.<span class="e Identifier"><span class="i">dup</span></span>;</span></span></span>
                      }</span></span></span>
                   }</span></span>
                <span class="k">else</span>
                   <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'%'</span></span></span>)
                      <span class="s Scope"><span class="s Compound">{
                      <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">state</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                      <span class="s Continue"><span class="k">continue</span>;</span>
                      }</span></span></span></span></span>

                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">pos</span></span> &lt; <span class="e Identifier"><span class="i">output</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
                   <span class="s Scope"><span class="s Compound">{
                   <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">output</span></span>[<span class="e Identifier"><span class="i">pos</span></span>]</span> = <span class="e Identifier"><span class="i">c</span></span></span>;</span>
                   <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">pos</span></span></span>;</span>
                   }</span></span>
                <span class="k">else</span>     
                   <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">toosmall</span></span>.<span class="e Identifier"><span class="i">dup</span></span>;</span></span></span>
                }</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">output</span></span> [<span class="e Int"><span class="n">0</span></span>..<span class="e Identifier"><span class="i">pos</span></span>]</span>;</span>
}</span></span></span></span></span>

<span class="bc">/******************************************************************************

        Convert 'escaped' chars to normal ones: \t =&gt; ^t for example.
        Supports \" \' \\ \a \b \f \n \r \t \v
        
******************************************************************************/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">unescape</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">src</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">dst</span> = <span class="e Null"><span class="k">null</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">delta</span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">s</span> = <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">len</span> = <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span>;</span></span>

        <span class="lc">// take a peek first to see if there's anything</span>
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">delta</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="i">s</span>, <span class="cl">'<span class="es">\\</span>'</span>, <span class="i">len</span>)</span></span>)</span> &lt; <span class="e Identifier"><span class="i">len</span></span></span>)
           <span class="s Scope"><span class="s Compound">{
           <span class="lc">// make some room if not enough provided</span>
           <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">dst</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt; <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
               <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">dst</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span></span>
           <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">d</span> = <span class="e Identifier"><span class="i">dst</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span>

           <span class="lc">// copy segments over, a chunk at a time</span>
           <span class="s DoWhile"><span class="k">do</span> <span class="s Scope"><span class="s Compound">{
              <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">d</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">delta</span></span>]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">s</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">delta</span></span>]</span></span>;</span>
              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">len</span></span> -= <span class="e Identifier"><span class="i">delta</span></span></span>;</span>
              <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">s</span></span> += <span class="e Identifier"><span class="i">delta</span></span></span>;</span>
              <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">d</span></span> += <span class="e Identifier"><span class="i">delta</span></span></span>;</span>

              <span class="lc">// bogus trailing '\'</span>
              <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">len</span></span> &lt; <span class="e Int"><span class="n">2</span></span></span>)
                 <span class="s Scope"><span class="s Compound">{
                 <span class="s Expression"><span class="e Assign"><span class="e PostIncr"><span class="e Deref">*<span class="e Identifier"><span class="i">d</span></span></span>++</span> = <span class="e Char"><span class="cl">'<span class="es">\\</span>'</span></span></span>;</span>
                 <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">len</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
                 <span class="s Break"><span class="k">break</span>;</span>
                 }</span></span></span>

              <span class="lc">// translate \char</span>
              <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">c</span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>[<span class="e Int"><span class="n">1</span></span>]</span>;</span></span>
              <span class="s Switch"><span class="k">switch</span> (<span class="e Identifier"><span class="i">c</span></span>)
                     <span class="s Scope"><span class="s Compound">{
                      <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'<span class="es">\\</span>'</span></span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Break"><span class="k">break</span>;</span></span></span></span>
                      <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'<span class="es">\'</span>'</span></span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\'</span>'</span></span></span>;</span>
                           <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                      <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'"'</span></span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'"'</span></span></span>;</span>
                           <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                      <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'a'</span></span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\a</span>'</span></span></span>;</span>
                           <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                      <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'b'</span></span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\b</span>'</span></span></span>;</span>
                           <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                      <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'f'</span></span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\f</span>'</span></span></span>;</span>
                           <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                      <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'n'</span></span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\n</span>'</span></span></span>;</span>
                           <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                      <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'r'</span></span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\r</span>'</span></span></span>;</span>
                           <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                      <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'t'</span></span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\t</span>'</span></span></span>;</span>
                           <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                      <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'v'</span></span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\v</span>'</span></span></span>;</span>
                           <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                      <span class="s Default"><span class="k">default</span>:
                           <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e PostIncr"><span class="e Deref">*<span class="e Identifier"><span class="i">d</span></span></span>++</span> = <span class="e Char"><span class="cl">'<span class="es">\\</span>'</span></span></span>;</span></span></span></span>
                     }</span></span></span>
              <span class="s Expression"><span class="e Assign"><span class="e PostIncr"><span class="e Deref">*<span class="e Identifier"><span class="i">d</span></span></span>++</span> = <span class="e Identifier"><span class="i">c</span></span></span>;</span>  
              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">len</span></span> -= <span class="e Int"><span class="n">2</span></span></span>;</span>           
              <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">s</span></span> += <span class="e Int"><span class="n">2</span></span></span>;</span>
              }</span></span> <span class="k">while</span> (<span class="e Rel"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">delta</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="i">s</span>, <span class="cl">'<span class="es">\\</span>'</span>, <span class="i">len</span>)</span></span>)</span> &lt; <span class="e Identifier"><span class="i">len</span></span></span>)</span><span class="s Empty">;</span>

           <span class="lc">// copy tail too</span>
           <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">d</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">len</span></span>]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">s</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">len</span></span>]</span></span>;</span>
           <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Inout"><span class="k">inout</span></span>)<span class="e Paren">(<span class="e Slice"><span class="e Identifier"><span class="i">dst</span></span> [<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">d</span></span> + <span class="e Identifier"><span class="i">len</span></span></span>)</span> - <span class="e Identifier"><span class="i">dst</span></span>.<span class="e Identifier"><span class="i">ptr</span></span></span>]</span>)</span></span>;</span>
           }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">src</span></span>;</span>
}</span></span></span></span></span>


<span class="bc">/******************************************************************************

        jhash() -- hash a variable-length key into a 32-bit value

          k     : the key (the unaligned variable-length array of bytes)
          len   : the length of the key, counting by bytes
          level : can be any 4-byte value

        Returns a 32-bit value.  Every bit of the key affects every bit of
        the return value.  Every 1-bit and 2-bit delta achieves avalanche.

        About 4.3*len + 80 X86 instructions, with excellent pipelining

        The best hash table sizes are powers of 2.  There is no need to do
        mod a prime (mod is sooo slow!).  If you need less than 32 bits,
        use a bitmask.  For example, if you need only 10 bits, do

                    h = (h &amp; hashmask(10));

        In which case, the hash table should have hashsize(10) elements.
        If you are hashing n strings (ub1 **)k, do it like this:

                    for (i=0, h=0; i&lt;n; ++i) h = hash( k[i], len[i], h);

        By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use 
        this code any way you wish, private, educational, or commercial.  
        It's free.

        See http://burtleburtle.net/bob/hash/evahash.html
        Use for hash table lookup, or anything where one collision in 2^32 
        is acceptable. Do NOT use for cryptographic purposes.

******************************************************************************/</span>

<span class="d StorageClass">@<span class="i">trusted</span></span> <span class="d StorageClass"><span class="k">nothrow</span></span> <span class="d StorageClass"><span class="k">pure</span></span>
<span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">jhash</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">ubyte</span></span>)</span><span class="t Pointer">*</span> <span class="i">k</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">len</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">c</span> = <span class="e Int"><span class="n">0</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">a</span> = <span class="e Int"><span class="n">0x9e3779b9</span></span>,
             <span class="i">b</span> = <span class="e Int"><span class="n">0x9e3779b9</span></span>,
             <span class="i">i</span> = <span class="e Identifier"><span class="i">len</span></span>;</span></span>

        <span class="lc">// handle most of the key </span>
        <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &gt;= <span class="e Int"><span class="n">12</span></span></span>) 
              <span class="s Scope"><span class="s Compound">{
              <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">a</span></span> += <span class="e Deref">*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span> <span class="t Pointer">*</span>)<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">k</span></span>+<span class="e Int"><span class="n">0</span></span></span>)</span></span></span></span>;</span>
              <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">b</span></span> += <span class="e Deref">*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span> <span class="t Pointer">*</span>)<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">k</span></span>+<span class="e Int"><span class="n">4</span></span></span>)</span></span></span></span>;</span>
              <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">c</span></span> += <span class="e Deref">*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span> <span class="t Pointer">*</span>)<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">k</span></span>+<span class="e Int"><span class="n">8</span></span></span>)</span></span></span></span>;</span>

              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">a</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span>&gt;&gt;<span class="e Int"><span class="n">13</span></span></span>)</span></span>;</span> 
              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">b</span></span> ^= <span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">a</span></span>&lt;&lt;<span class="e Int"><span class="n">8</span></span></span>)</span></span>;</span> 
              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">c</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">b</span></span>&gt;&gt;<span class="e Int"><span class="n">13</span></span></span>)</span></span>;</span> 
              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">a</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span>&gt;&gt;<span class="e Int"><span class="n">12</span></span></span>)</span></span>;</span>  
              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">b</span></span> ^= <span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">a</span></span>&lt;&lt;<span class="e Int"><span class="n">16</span></span></span>)</span></span>;</span> 
              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">c</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">b</span></span>&gt;&gt;<span class="e Int"><span class="n">5</span></span></span>)</span></span>;</span> 
              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">a</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span>&gt;&gt;<span class="e Int"><span class="n">3</span></span></span>)</span></span>;</span>  
              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">b</span></span> ^= <span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">a</span></span>&lt;&lt;<span class="e Int"><span class="n">10</span></span></span>)</span></span>;</span> 
              <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">c</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">b</span></span>&gt;&gt;<span class="e Int"><span class="n">15</span></span></span>)</span></span>;</span> 
              <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">k</span></span> += <span class="e Int"><span class="n">12</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">i</span></span> -= <span class="e Int"><span class="n">12</span></span></span>;</span>
              }</span></span></span>

        <span class="lc">// handle the last 11 bytes </span>
        <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">c</span></span> += <span class="e Identifier"><span class="i">len</span></span></span>;</span>
        <span class="s Switch"><span class="k">switch</span> (<span class="e Identifier"><span class="i">i</span></span>)
               <span class="s Scope"><span class="s Compound">{
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">11</span></span>: <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">c</span></span>+=<span class="e Paren">(<span class="e LShift"><span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">10</span></span>]</span>&lt;&lt;<span class="e Int"><span class="n">24</span></span></span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">case</span>;</span></span></span></span>
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">10</span></span>: <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">c</span></span>+=<span class="e Paren">(<span class="e LShift"><span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">9</span></span>]</span>&lt;&lt;<span class="e Int"><span class="n">16</span></span></span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">case</span>;</span></span></span></span>
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">9</span></span> : <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">c</span></span>+=<span class="e Paren">(<span class="e LShift"><span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">8</span></span>]</span>&lt;&lt;<span class="e Int"><span class="n">8</span></span></span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">case</span>;</span></span></span></span>
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">8</span></span> : <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">b</span></span>+=<span class="e Paren">(<span class="e LShift"><span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">7</span></span>]</span>&lt;&lt;<span class="e Int"><span class="n">24</span></span></span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">case</span>;</span></span></span></span>
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">7</span></span> : <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">b</span></span>+=<span class="e Paren">(<span class="e LShift"><span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">6</span></span>]</span>&lt;&lt;<span class="e Int"><span class="n">16</span></span></span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">case</span>;</span></span></span></span>
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">6</span></span> : <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">b</span></span>+=<span class="e Paren">(<span class="e LShift"><span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">5</span></span>]</span>&lt;&lt;<span class="e Int"><span class="n">8</span></span></span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">case</span>;</span></span></span></span>
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">5</span></span> : <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">b</span></span>+=<span class="e Paren">(<span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">4</span></span>]</span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">case</span>;</span></span></span></span>
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">4</span></span> : <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">a</span></span>+=<span class="e Paren">(<span class="e LShift"><span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">3</span></span>]</span>&lt;&lt;<span class="e Int"><span class="n">24</span></span></span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">case</span>;</span></span></span></span>
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">3</span></span> : <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">a</span></span>+=<span class="e Paren">(<span class="e LShift"><span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">2</span></span>]</span>&lt;&lt;<span class="e Int"><span class="n">16</span></span></span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">case</span>;</span></span></span></span>
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">2</span></span> : <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">a</span></span>+=<span class="e Paren">(<span class="e LShift"><span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">1</span></span>]</span>&lt;&lt;<span class="e Int"><span class="n">8</span></span></span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">case</span>;</span></span></span></span>
               <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">1</span></span> : <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">a</span></span>+=<span class="e Paren">(<span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">k</span></span></span>[<span class="e Int"><span class="n">0</span></span>]</span>)</span></span>;</span> <span class="s Goto"><span class="k">goto</span> <span class="k">default</span>;</span></span></span></span>
               <span class="s Default"><span class="k">default</span><span class="s Scope"><span class="s Compound">:</span></span></span>
               }</span></span></span>

        <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">a</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span>&gt;&gt;<span class="e Int"><span class="n">13</span></span></span>)</span></span>;</span> 
        <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">b</span></span> ^= <span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">a</span></span>&lt;&lt;<span class="e Int"><span class="n">8</span></span></span>)</span></span>;</span> 
        <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">c</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">b</span></span>&gt;&gt;<span class="e Int"><span class="n">13</span></span></span>)</span></span>;</span> 
        <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">a</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span>&gt;&gt;<span class="e Int"><span class="n">12</span></span></span>)</span></span>;</span>  
        <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">b</span></span> ^= <span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">a</span></span>&lt;&lt;<span class="e Int"><span class="n">16</span></span></span>)</span></span>;</span> 
        <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">c</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">b</span></span>&gt;&gt;<span class="e Int"><span class="n">5</span></span></span>)</span></span>;</span> 
        <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">a</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">a</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span>&gt;&gt;<span class="e Int"><span class="n">3</span></span></span>)</span></span>;</span>  
        <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">c</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">b</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">b</span></span> ^= <span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">a</span></span>&lt;&lt;<span class="e Int"><span class="n">10</span></span></span>)</span></span>;</span> 
        <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">a</span></span></span>;</span> <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">c</span></span> -= <span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="s Expression"><span class="e XorAssign"><span class="e Identifier"><span class="i">c</span></span> ^= <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">b</span></span>&gt;&gt;<span class="e Int"><span class="n">15</span></span></span>)</span></span>;</span> 

        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">c</span></span>;</span>
}</span></span></span>

<span class="lc">/// ditto</span>
<span class="d StorageClass">@<span class="i">trusted</span></span> <span class="d StorageClass"><span class="k">nothrow</span></span> <span class="d StorageClass"><span class="k">pure</span></span>
<span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">jhash</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">void</span></span>)</span><span class="t Array">[]</span> <span class="i">x</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">c</span> = <span class="e Int"><span class="n">0</span></span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">jhash</span></span> (<span class="k">cast</span>(<span class="k">ubyte</span>*) <span class="i">x</span>.<span class="i">ptr</span>, <span class="i">x</span>.<span class="i">length</span>, <span class="i">c</span>)</span>;</span>
}</span></span></span>


<span class="bc">/******************************************************************************
      
        Helper fruct for iterator lines(). A fruct is a low 
        impact mechanism for capturing context relating to an 
        opApply (conjunction of the names struct and foreach)
        
******************************************************************************/</span>

<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">LineFruct</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span>
<span class="d Compound">{
        <span class="d Protection"><span class="k">private</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">src</span>;</span>

        <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opApply</span> <span class="o Parameters">(<span class="o Parameter"><span class="k">scope</span> <span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span> <span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">line</span></span>)</span></span> <span class="i">dg</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span>        <span class="i">ret</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>     <span class="i">pos</span>,
                           <span class="i">mark</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">line</span>;</span></span>

                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">nl</span> = <span class="e Char"><span class="cl">'<span class="es">\n</span>'</span></span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">cr</span> = <span class="e Char"><span class="cl">'<span class="es">\r</span>'</span></span>;</span></span>

                <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">pos</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">locate</span></span> (<span class="i">src</span>, <span class="i">nl</span>, <span class="i">mark</span>)</span></span>)</span> &lt; <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
                      <span class="s Scope"><span class="s Compound">{
                      <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">end</span> = <span class="e Identifier"><span class="i">pos</span></span>;</span></span>
                      <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Identifier"><span class="i">end</span></span> &amp;&amp; <span class="e Identity"><span class="e Index"><span class="e Identifier"><span class="i">src</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">end</span></span>-<span class="e Int"><span class="n">1</span></span></span>]</span> <span class="k">is</span> <span class="e Identifier"><span class="i">cr</span></span></span></span>)
                          <span class="s Scope"><span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">end</span></span></span>;</span></span></span>

                      <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">line</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Identifier"><span class="i">mark</span></span> .. <span class="e Identifier"><span class="i">end</span></span>]</span></span>;</span>
                      <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">ret</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span> (<span class="i">line</span>)</span></span>)</span> != <span class="e Int"><span class="n">0</span></span></span>)
                           <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span></span></span>
                      <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">mark</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">pos</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
                      }</span></span></span>

                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">line</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Identifier"><span class="i">mark</span></span> .. <span class="e Dollar">$</span>]</span></span>;</span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">mark</span></span> &lt;= <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ret</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span> (<span class="i">line</span>)</span></span>;</span></span></span>

                <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span>
        }</span></span></span>
}</span></span></span></span>

<span class="bc">/******************************************************************************

        Helper fruct for iterator delims(). A fruct is a low 
        impact mechanism for capturing context relating to an 
        opApply (conjunction of the names struct and foreach)
        
******************************************************************************/</span>

<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">DelimFruct</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">M</span></span>)</span>
<span class="d Compound">{
        <span class="d Protection"><span class="k">private</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">src</span>;</span>
        <span class="d Protection"><span class="k">private</span></span> <span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">M</span></span>)</span><span class="t Array">[]</span> <span class="i">set</span>;</span>

        <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opApply</span> <span class="o Parameters">(<span class="o Parameter"><span class="k">scope</span> <span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span> <span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">token</span></span>)</span></span> <span class="i">dg</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span>     <span class="i">ret</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>  <span class="i">pos</span>,
                        <span class="i">mark</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span>     <span class="i">token</span>;</span></span>

                <span class="lc">// optimize for single delimiter case</span>
                <span class="s If"><span class="k">if</span> (<span class="e Identity"><span class="e Identifier"><span class="i">set</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span>)
                    <span class="s Scope"><span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">pos</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">locate</span></span> (<span class="i">src</span>, <span class="i">set</span>[<span class="n">0</span>], <span class="i">mark</span>)</span></span>)</span> &lt; <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
                          <span class="s Scope"><span class="s Compound">{
                          <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">token</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Identifier"><span class="i">mark</span></span> .. <span class="e Identifier"><span class="i">pos</span></span>]</span></span>;</span>
                          <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">ret</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span> (<span class="i">token</span>)</span></span>)</span> != <span class="e Int"><span class="n">0</span></span></span>)
                               <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span></span></span>
                          <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">mark</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">pos</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
                          }</span></span></span></span>
                <span class="k">else</span>
                   <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">set</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Int"><span class="n">1</span></span></span>)
                       <span class="s Scope"><span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>, <span class="o Parameter"><span class="i">elem</span></span></span>; <span class="e Identifier"><span class="i">src</span></span>)
                                <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">contains</span></span> (<span class="i">set</span>, <span class="i">elem</span>)</span>)
                                   <span class="s Scope"><span class="s Compound">{
                                   <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">token</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Identifier"><span class="i">mark</span></span> .. <span class="e Identifier"><span class="i">i</span></span>]</span></span>;</span>
                                   <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">ret</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span> (<span class="i">token</span>)</span></span>)</span> != <span class="e Int"><span class="n">0</span></span></span>)
                                        <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span></span></span>
                                   <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">mark</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">i</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
                                   }</span></span></span></span></span></span></span></span></span>

                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">token</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Identifier"><span class="i">mark</span></span> .. <span class="e Dollar">$</span>]</span></span>;</span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">mark</span></span> &lt;= <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ret</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span> (<span class="i">token</span>)</span></span>;</span></span></span>

                <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span>
        }</span></span></span>
}</span></span></span></span>

<span class="bc">/******************************************************************************

        Helper fruct for iterator patterns(). A fruct is a low 
        impact mechanism for capturing context relating to an 
        opApply (conjunction of the names struct and foreach)
        
******************************************************************************/</span>

<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">PatternFruct</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span>
<span class="d Compound">{
        <span class="d Protection"><span class="k">private</span></span> <span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">src</span>,
                           <span class="i">sub</span>,
                           <span class="i">pattern</span>;</span>

        <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opApply</span> <span class="o Parameters">(<span class="o Parameter"><span class="k">scope</span> <span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span> <span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">token</span></span>)</span></span> <span class="i">dg</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span>        <span class="i">ret</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>     <span class="i">pos</span>,
                           <span class="i">mark</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">token</span>;</span></span>

                <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">pos</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">index</span></span> (<span class="i">src</span>, <span class="i">pattern</span>, <span class="i">mark</span>)</span></span>)</span> &lt; <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
                      <span class="s Scope"><span class="s Compound">{
                      <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">token</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Identifier"><span class="i">mark</span></span> .. <span class="e Identifier"><span class="i">pos</span></span>]</span></span>;</span>
                      <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">ret</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span>(<span class="i">token</span>)</span></span>)</span> != <span class="e Int"><span class="n">0</span></span></span>)
                           <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span></span></span>
                      <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Identifier"><span class="i">sub</span></span>.<span class="e Identifier"><span class="i">ptr</span></span> &amp;&amp; <span class="e Equal"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">ret</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span>(<span class="i">sub</span>)</span></span>)</span> != <span class="e Int"><span class="n">0</span></span></span></span>)
                          <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span></span></span>
                      <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">mark</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">pos</span></span> + <span class="e Identifier"><span class="i">pattern</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>;</span>
                      }</span></span></span>

                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">token</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Identifier"><span class="i">mark</span></span> .. <span class="e Dollar">$</span>]</span></span>;</span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">mark</span></span> &lt;= <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ret</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span> (<span class="i">token</span>)</span></span>;</span></span></span>

                <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span>
        }</span></span></span>
}</span></span></span></span>

<span class="bc">/******************************************************************************

        Helper fruct for iterator quotes(). A fruct is a low 
        impact mechanism for capturing context relating to an 
        opApply (conjunction of the names struct and foreach)
        
******************************************************************************/</span>

<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">QuoteFruct</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>, <span class="o TemplateTypeParam"><span class="i">M</span></span>)</span>
<span class="d Compound">{
        <span class="d Protection"><span class="k">private</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span>        <span class="i">src</span>;</span>
        <span class="d Protection"><span class="k">private</span></span> <span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">M</span></span>)</span><span class="t Array">[]</span> <span class="i">set</span>;</span>
        
        <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opApply</span> <span class="o Parameters">(<span class="o Parameter"><span class="k">scope</span> <span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span> <span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span> <span class="i">token</span></span>)</span></span> <span class="i">dg</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span>     <span class="i">ret</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>  <span class="i">mark</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span>)</span><span class="t Array">[]</span>     <span class="i">token</span>;</span></span>

                <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">set</span></span>.<span class="e Identifier"><span class="i">length</span></span>)
                    <span class="s Scope"><span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>)
                        <span class="s Scope"><span class="s Compound">{
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">c</span> = <span class="e Index"><span class="e Identifier"><span class="i">src</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>;</span></span>
                        <span class="s If"><span class="k">if</span> (<span class="e OrOr"><span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'"'</span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">c</span></span> <span class="k">is</span> <span class="e Char"><span class="cl">'<span class="es">\'</span>'</span></span></span></span>)
                            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">i</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">locate</span></span> (<span class="i">src</span>, <span class="i">c</span>, <span class="i">i</span>+<span class="n">1</span>)</span></span>;</span></span>
                        <span class="k">else</span>
                           <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">contains</span></span> (<span class="i">set</span>, <span class="i">c</span>)</span>)
                              <span class="s Scope"><span class="s Compound">{
                              <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">token</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Identifier"><span class="i">mark</span></span> .. <span class="e Identifier"><span class="i">i</span></span>]</span></span>;</span>
                              <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Paren">(<span class="e Assign"><span class="e Identifier"><span class="i">ret</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span> (<span class="i">token</span>)</span></span>)</span> != <span class="e Int"><span class="n">0</span></span></span>)
                                   <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span></span></span>
                              <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">mark</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">i</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
                              }</span></span></span></span></span>
                        }</span></span></span></span></span>
                
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">token</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">src</span></span> [<span class="e Identifier"><span class="i">mark</span></span> .. <span class="e Dollar">$</span>]</span></span>;</span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">mark</span></span> &lt;= <span class="e Identifier"><span class="i">src</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ret</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span> (<span class="i">token</span>)</span></span>;</span></span></span>

                <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span>
        }</span></span></span>
}</span></span></span></span>


<span class="bc">/******************************************************************************

******************************************************************************/</span>

<span class="d Debug"><span class="k">debug</span> (<span class="i">UnitTest</span>)
<span class="d Compound">{    
        <span class="d Unittest"><span class="k">unittest</span>
        <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">char</span></span><span class="t Array">[<span class="e Int"><span class="n">64</span></span>]</span> <span class="i">tmp</span>;</span></span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Call"><span class="e Identifier"><span class="i">isSpace</span></span> (<span class="cl">' '</span>)</span> &amp;&amp; <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">isSpace</span></span></span> (<span class="cl">'d'</span>)</span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="cl">'a'</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">0</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="cl">'b'</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="cl">'c'</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="cl">'d'</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">"abcabcabc"</span>.<span class="i">ptr</span>, <span class="cl">'d'</span>, <span class="n">9</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">9</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">"abc"d</span>.<span class="i">ptr</span>, <span class="k">cast</span>(<span class="k">dchar</span>)<span class="cl">'c'</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">"abc"d</span>.<span class="i">ptr</span>, <span class="k">cast</span>(<span class="k">dchar</span>)<span class="cl">'d'</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
                                
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">"abc"w</span>.<span class="i">ptr</span>, <span class="k">cast</span>(<span class="k">wchar</span>)<span class="cl">'c'</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">"abc"w</span>.<span class="i">ptr</span>, <span class="k">cast</span>(<span class="k">wchar</span>)<span class="cl">'d'</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">"abcdefghijklmnopqrstuvwxyz"w</span>.<span class="i">ptr</span>, <span class="k">cast</span>(<span class="k">wchar</span>)<span class="cl">'x'</span>, <span class="n">25</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">23</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span> (<span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span> (<span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="sl">"abd"</span>.<span class="i">ptr</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span> (<span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="sl">"acc"</span>.<span class="i">ptr</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span> (<span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="sl">"ccc"</span>.<span class="i">ptr</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">0</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span> (<span class="sl">"abc"w</span>.<span class="i">ptr</span>, <span class="sl">"abc"w</span>.<span class="i">ptr</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span> (<span class="sl">"abc"w</span>.<span class="i">ptr</span>, <span class="sl">"acc"w</span>.<span class="i">ptr</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span>)</span>;</span>
                                                
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span> (<span class="sl">"abc"d</span>.<span class="i">ptr</span>, <span class="sl">"abc"d</span>.<span class="i">ptr</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span> (<span class="sl">"abc"d</span>.<span class="i">ptr</span>, <span class="sl">"acc"d</span>.<span class="i">ptr</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Call"><span class="e Identifier"><span class="i">matching</span></span> (<span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="n">3</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">matching</span></span> (<span class="sl">"abc"</span>.<span class="i">ptr</span>, <span class="sl">"abb"</span>.<span class="i">ptr</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Bool"><span class="k">false</span></span></span>)</span>;</span>
        
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Call"><span class="e Identifier"><span class="i">contains</span></span> (<span class="sl">"abc"</span>, <span class="cl">'a'</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Call"><span class="e Identifier"><span class="i">contains</span></span> (<span class="sl">"abc"</span>, <span class="cl">'b'</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Call"><span class="e Identifier"><span class="i">contains</span></span> (<span class="sl">"abc"</span>, <span class="cl">'c'</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">contains</span></span> (<span class="sl">"abc"</span>, <span class="cl">'d'</span>)</span> <span class="k">is</span> <span class="e Bool"><span class="k">false</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Call"><span class="e Identifier"><span class="i">containsPattern</span></span> (<span class="sl">"abc"</span>, <span class="sl">"ab"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Call"><span class="e Identifier"><span class="i">containsPattern</span></span> (<span class="sl">"abc"</span>, <span class="sl">"bc"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Call"><span class="e Identifier"><span class="i">containsPattern</span></span> (<span class="sl">"abc"</span>, <span class="sl">"abc"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">containsPattern</span></span> (<span class="sl">"abc"</span>, <span class="sl">"zabc"</span>)</span> <span class="k">is</span> <span class="e Bool"><span class="k">false</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">containsPattern</span></span> (<span class="sl">"abc"</span>, <span class="sl">"abcd"</span>)</span> <span class="k">is</span> <span class="e Bool"><span class="k">false</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">containsPattern</span></span> (<span class="sl">"abc"</span>, <span class="sl">"za"</span>)</span> <span class="k">is</span> <span class="e Bool"><span class="k">false</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">containsPattern</span></span> (<span class="sl">"abc"</span>, <span class="sl">"cd"</span>)</span> <span class="k">is</span> <span class="e Bool"><span class="k">false</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">trim</span></span> (<span class="sl">""</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">trim</span></span> (<span class="sl">" abc  "</span>)</span> == <span class="e String"><span class="sl">"abc"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">trim</span></span> (<span class="sl">"   "</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">strip</span></span> (<span class="sl">""</span>, <span class="cl">'%'</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">strip</span></span> (<span class="sl">"%abc%%%"</span>, <span class="cl">'%'</span>)</span> == <span class="e String"><span class="sl">"abc"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">strip</span></span> (<span class="sl">"#####"</span>, <span class="cl">'#'</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">stripl</span></span> (<span class="sl">"#####"</span>, <span class="cl">'#'</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">stripl</span></span> (<span class="sl">" ###"</span>, <span class="cl">' '</span>)</span> == <span class="e String"><span class="sl">"###"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">stripl</span></span> (<span class="sl">"#####"</span>, <span class="cl">'s'</span>)</span> == <span class="e String"><span class="sl">"#####"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">stripr</span></span> (<span class="sl">"#####"</span>, <span class="cl">'#'</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">stripr</span></span> (<span class="sl">"### "</span>, <span class="cl">' '</span>)</span> == <span class="e String"><span class="sl">"###"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">stripr</span></span> (<span class="sl">"#####"</span>, <span class="cl">'s'</span>)</span> == <span class="e String"><span class="sl">"#####"</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">replace</span></span> (<span class="sl">"abc"</span>.<span class="i">dup</span>, <span class="cl">'b'</span>, <span class="cl">':'</span>)</span> == <span class="e String"><span class="sl">"a:c"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">substitute</span></span> (<span class="sl">"abc"</span>.<span class="i">dup</span>, <span class="sl">"bc"</span>, <span class="sl">"x"</span>)</span> == <span class="e String"><span class="sl">"ax"</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locate</span></span> (<span class="sl">"abc"</span>, <span class="cl">'c'</span>, <span class="n">1</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locate</span></span> (<span class="sl">"abc"</span>, <span class="cl">'c'</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locate</span></span> (<span class="sl">"abc"</span>, <span class="cl">'a'</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">0</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locate</span></span> (<span class="sl">"abc"</span>, <span class="cl">'d'</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locate</span></span> (<span class="sl">""</span>, <span class="cl">'c'</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">0</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePrior</span></span> (<span class="sl">"abce"</span>, <span class="cl">'c'</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePrior</span></span> (<span class="sl">"abce"</span>, <span class="cl">'a'</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">0</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePrior</span></span> (<span class="sl">"abce"</span>, <span class="cl">'d'</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">4</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePrior</span></span> (<span class="sl">"abce"</span>, <span class="cl">'c'</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePrior</span></span> (<span class="sl">"abce"</span>, <span class="cl">'c'</span>, <span class="n">2</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">4</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePrior</span></span> (<span class="sl">""</span>, <span class="cl">'c'</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">0</span></span></span>)</span>;</span>

        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">x</span> = <span class="e Call"><span class="e Identifier"><span class="i">delimit</span></span> (<span class="sl">"::b"</span>, <span class="sl">":"</span>)</span>;</span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">""</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e String"><span class="sl">""</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e String"><span class="sl">"b"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">delimit</span></span> (<span class="sl">"a:bc:d"</span>, <span class="sl">":"</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"a"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e String"><span class="sl">"bc"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e String"><span class="sl">"d"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">delimit</span></span> (<span class="sl">"abcd"</span>, <span class="sl">":"</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"abcd"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">delimit</span></span> (<span class="sl">"abcd:"</span>, <span class="sl">":"</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"abcd"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e String"><span class="sl">""</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">delimit</span></span> (<span class="sl">"a;b$c#d:e@f"</span>, <span class="sl">";:$#@"</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">6</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>==<span class="e String"><span class="sl">"a"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">1</span></span>]</span>==<span class="e String"><span class="sl">"b"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">2</span></span>]</span>==<span class="e String"><span class="sl">"c"</span></span></span></span> &amp;&amp;
                                 <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">3</span></span>]</span>==<span class="e String"><span class="sl">"d"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">4</span></span>]</span>==<span class="e String"><span class="sl">"e"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">5</span></span>]</span>==<span class="e String"><span class="sl">"f"</span></span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePattern</span></span> (<span class="sl">"abcdefg"</span>, <span class="sl">""</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">7</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePattern</span></span> (<span class="sl">"abcdefg"</span>, <span class="sl">"g"</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">6</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePattern</span></span> (<span class="sl">"abcdefg"</span>, <span class="sl">"abcdefg"</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">0</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePattern</span></span> (<span class="sl">"abcdefg"</span>, <span class="sl">"abcdefgx"</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">7</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePattern</span></span> (<span class="sl">"abcdefg"</span>, <span class="sl">"cce"</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">7</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePattern</span></span> (<span class="sl">"abcdefg"</span>, <span class="sl">"cde"</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePattern</span></span> (<span class="sl">"abcdefgcde"</span>, <span class="sl">"cde"</span>, <span class="n">3</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">7</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePatternPrior</span></span> (<span class="sl">"abcdefg"</span>, <span class="sl">""</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">7</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePatternPrior</span></span> (<span class="sl">"abcdefg"</span>, <span class="sl">"cce"</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">7</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePatternPrior</span></span> (<span class="sl">"abcdefg"</span>, <span class="sl">"cde"</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePatternPrior</span></span> (<span class="sl">"abcdefgcde"</span>, <span class="sl">"cde"</span>, <span class="n">6</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePatternPrior</span></span> (<span class="sl">"abcdefgcde"</span>, <span class="sl">"cde"</span>, <span class="n">4</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Call"><span class="e Identifier"><span class="i">locatePatternPrior</span></span> (<span class="sl">"abcdefg"</span>, <span class="sl">"abcdefgx"</span>)</span> <span class="k">is</span> <span class="e Int"><span class="n">7</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">splitLines</span></span> (<span class="sl">"a<span class="es">\n</span>b<span class="es">\n</span>"</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"a"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e String"><span class="sl">"b"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e String"><span class="sl">""</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">splitLines</span></span> (<span class="sl">"a<span class="es">\r</span><span class="es">\n</span>"</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">2</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"a"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e String"><span class="sl">""</span></span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">splitLines</span></span> (<span class="sl">"a"</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"a"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">splitLines</span></span> (<span class="sl">""</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span>)</span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">q</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">element</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">quotes</span></span> (<span class="sl">"1 'avcc   cc ' 3"</span>, <span class="sl">" "</span>)</span>)
                 <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">q</span></span> ~= <span class="e Identifier"><span class="i">element</span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">q</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">q</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"1"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">q</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e String"><span class="sl">"'avcc   cc '"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">q</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e String"><span class="sl">"3"</span></span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">layout</span></span> (<span class="i">tmp</span>, <span class="sl">"%1,%%%c %0"</span>, <span class="sl">"abc"</span>, <span class="sl">"efg"</span>)</span> == <span class="e String"><span class="sl">"efg,%c abc"</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">split</span></span> (<span class="sl">"one, two, three"</span>, <span class="sl">","</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"one"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e String"><span class="sl">" two"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e String"><span class="sl">" three"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">split</span></span> (<span class="sl">"one, two, three"</span>, <span class="sl">", "</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"one"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e String"><span class="sl">"two"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e String"><span class="sl">"three"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">split</span></span> (<span class="sl">"one, two, three"</span>, <span class="sl">",,"</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">1</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"one, two, three"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">split</span></span> (<span class="sl">"one,,"</span>, <span class="sl">","</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span> <span class="k">is</span> <span class="e Int"><span class="n">3</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"one"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e String"><span class="sl">""</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">x</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e String"><span class="sl">""</span></span></span></span>)</span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Immutable"><span class="k">immutable</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">h</span>, <span class="i">t</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">h</span></span> =  <span class="e Call"><span class="e Identifier"><span class="i">head</span></span> (<span class="sl">"one:two:three"</span>, <span class="sl">":"</span>, <span class="i">t</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">h</span></span> == <span class="e String"><span class="sl">"one"</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span> == <span class="e String"><span class="sl">"two:three"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">h</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">head</span></span> (<span class="sl">"one:::two:three"</span>, <span class="sl">":::"</span>, <span class="i">t</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">h</span></span> == <span class="e String"><span class="sl">"one"</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span> == <span class="e String"><span class="sl">"two:three"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">h</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">head</span></span> (<span class="sl">"one:two:three"</span>, <span class="sl">"*"</span>, <span class="i">t</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">h</span></span> == <span class="e String"><span class="sl">"one:two:three"</span></span></span> &amp;&amp; <span class="e Identity"><span class="e Identifier"><span class="i">t</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> =  <span class="e Call"><span class="e Identifier"><span class="i">tail</span></span> (<span class="sl">"one:two:three"</span>, <span class="sl">":"</span>, <span class="i">h</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">h</span></span> == <span class="e String"><span class="sl">"one:two"</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span> == <span class="e String"><span class="sl">"three"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">tail</span></span> (<span class="sl">"one:::two:three"</span>, <span class="sl">":::"</span>, <span class="i">h</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">h</span></span> == <span class="e String"><span class="sl">"one"</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span> == <span class="e String"><span class="sl">"two:three"</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">tail</span></span> (<span class="sl">"one:two:three"</span>, <span class="sl">"*"</span>, <span class="i">h</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">t</span></span> == <span class="e String"><span class="sl">"one:two:three"</span></span></span> &amp;&amp; <span class="e Identity"><span class="e Identifier"><span class="i">h</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">chopl</span></span>(<span class="sl">"hello world"</span>, <span class="sl">"hello "</span>)</span> == <span class="e String"><span class="sl">"world"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">chopl</span></span>(<span class="sl">"hello"</span>, <span class="sl">"hello"</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">chopl</span></span>(<span class="sl">"hello world"</span>, <span class="sl">" "</span>)</span> == <span class="e String"><span class="sl">"hello world"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">chopl</span></span>(<span class="sl">"hello world"</span>, <span class="sl">""</span>)</span> == <span class="e String"><span class="sl">"hello world"</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">chopr</span></span>(<span class="sl">"hello world"</span>, <span class="sl">" world"</span>)</span> == <span class="e String"><span class="sl">"hello"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">chopr</span></span>(<span class="sl">"hello"</span>, <span class="sl">"hello"</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">chopr</span></span>(<span class="sl">"hello world"</span>, <span class="sl">" "</span>)</span> == <span class="e String"><span class="sl">"hello world"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">chopr</span></span>(<span class="sl">"hello world"</span>, <span class="sl">""</span>)</span> == <span class="e String"><span class="sl">"hello world"</span></span></span>)</span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">foo</span> = <span class="e ArrayInit">[<span class="e String"><span class="sl">"one"</span></span>, <span class="e String"><span class="sl">"two"</span></span>, <span class="e String"><span class="sl">"three"</span></span>]</span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">j</span> = <span class="e Call"><span class="e Identifier"><span class="i">join</span></span> (<span class="i">foo</span>)</span>;</span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Identifier"><span class="i">j</span></span> == <span class="e String"><span class="sl">"onetwothree"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">j</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">join</span></span> (<span class="i">foo</span>, <span class="sl">", "</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Identifier"><span class="i">j</span></span> == <span class="e String"><span class="sl">"one, two, three"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">j</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">join</span></span> (<span class="i">foo</span>, <span class="sl">" "</span>, <span class="i">tmp</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Identifier"><span class="i">j</span></span> == <span class="e String"><span class="sl">"one two three"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Identity"><span class="e Identifier"><span class="i">j</span></span>.<span class="e Identifier"><span class="i">ptr</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">ptr</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">repeat</span></span> (<span class="sl">"abc"</span>, <span class="n">0</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">repeat</span></span> (<span class="sl">"abc"</span>, <span class="n">1</span>)</span> == <span class="e String"><span class="sl">"abc"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">repeat</span></span> (<span class="sl">"abc"</span>, <span class="n">2</span>)</span> == <span class="e String"><span class="sl">"abcabc"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">repeat</span></span> (<span class="sl">"abc"</span>, <span class="n">4</span>)</span> == <span class="e String"><span class="sl">"abcabcabcabc"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">repeat</span></span> (<span class="sl">""</span>, <span class="n">4</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">char</span></span><span class="t Array">[<span class="e Int"><span class="n">10</span></span>]</span> <span class="i">rep</span>;</span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">repeat</span></span> (<span class="sl">"abc"</span>, <span class="n">0</span>, <span class="i">rep</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">repeat</span></span> (<span class="sl">"abc"</span>, <span class="n">1</span>, <span class="i">rep</span>)</span> == <span class="e String"><span class="sl">"abc"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">repeat</span></span> (<span class="sl">"abc"</span>, <span class="n">2</span>, <span class="i">rep</span>)</span> == <span class="e String"><span class="sl">"abcabc"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">repeat</span></span> (<span class="sl">""</span>, <span class="n">4</span>, <span class="i">rep</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">unescape</span></span> (<span class="sl">"abc"</span>)</span> == <span class="e String"><span class="sl">"abc"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">unescape</span></span> (<span class="sl">"abc<span class="es">\\</span>"</span>)</span> == <span class="e String"><span class="sl">"abc<span class="es">\\</span>"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">unescape</span></span> (<span class="sl">"abc<span class="es">\\</span>t"</span>)</span> == <span class="e String"><span class="sl">"abc<span class="es">\t</span>"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">unescape</span></span> (<span class="sl">"abc<span class="es">\\</span>tc"</span>)</span> == <span class="e String"><span class="sl">"abc<span class="es">\t</span>c"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">unescape</span></span> (<span class="sl">"<span class="es">\\</span>t"</span>)</span> == <span class="e String"><span class="sl">"<span class="es">\t</span>"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">unescape</span></span> (<span class="sl">"<span class="es">\\</span>tx"</span>)</span> == <span class="e String"><span class="sl">"<span class="es">\t</span>x"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">unescape</span></span> (<span class="sl">"<span class="es">\\</span>v<span class="es">\\</span>vx"</span>)</span> == <span class="e String"><span class="sl">"<span class="es">\v</span><span class="es">\v</span>x"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span> (<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">unescape</span></span> (<span class="sl">"abc<span class="es">\\</span>t<span class="es">\\</span>a<span class="es">\\</span>bc"</span>)</span> == <span class="e String"><span class="sl">"abc<span class="es">\t</span><span class="es">\a</span><span class="es">\b</span>c"</span></span></span>)</span>;</span>
        }</span></span></span>
}</span></span>



<span class="d Debug"><span class="k">debug</span> (<span class="i">Util</span>)
<span class="d Compound">{
        <span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">x</span> = <span class="e Import"><span class="k">import</span>(<span class="e String"><span class="sl">"Util.d"</span></span>)</span>;</span>
        
        <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">main</span><span class="o Parameters">()</span>
        <span class="s FuncBody"><span class="s Compound">{
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span> (<span class="sl">""</span>.<span class="i">ptr</span>, <span class="i">S</span>(<span class="i">x</span>).<span class="i">ptr</span>, <span class="n">0</span>)</span>;</span>
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span> (<span class="sl">""</span>.<span class="i">ptr</span>, <span class="cl">'@'</span>, <span class="n">0</span>)</span>;</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">char</span></span><span class="t Array">[]</span> <span class="i">s</span>;</span></span>
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">split</span></span> (<span class="i">s</span>, <span class="sl">" "</span>)</span>;</span>
                <span class="lc">//indexOf (s.ptr, '@', 0);</span>

        }</span></span></span>
}</span></span></span>

</pre></td>
</tr></table>
</body>
</html>