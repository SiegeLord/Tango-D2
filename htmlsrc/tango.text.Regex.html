<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>tango.text.Regex</title>
  <style type="text/css">
  .linescolumn > a { display: block; }
  td { vertical-align: top; }
  </style>
  <link href="html.css" rel="stylesheet" type="text/css">
</head>
<body>
<table><tr><td class="linescolumn"><a id="L1" href="#L1">1</a><a id="L2" href="#L2">2</a><a id="L3" href="#L3">3</a><a id="L4" href="#L4">4</a><a id="L5" href="#L5">5</a><a id="L6" href="#L6">6</a><a id="L7" href="#L7">7</a><a id="L8" href="#L8">8</a><a id="L9" href="#L9">9</a><a id="L10" href="#L10">10</a><a id="L11" href="#L11">11</a><a id="L12" href="#L12">12</a><a id="L13" href="#L13">13</a><a id="L14" href="#L14">14</a><a id="L15" href="#L15">15</a><a id="L16" href="#L16">16</a><a id="L17" href="#L17">17</a><a id="L18" href="#L18">18</a><a id="L19" href="#L19">19</a><a id="L20" href="#L20">20</a><a id="L21" href="#L21">21</a><a id="L22" href="#L22">22</a><a id="L23" href="#L23">23</a><a id="L24" href="#L24">24</a><a id="L25" href="#L25">25</a><a id="L26" href="#L26">26</a><a id="L27" href="#L27">27</a><a id="L28" href="#L28">28</a><a id="L29" href="#L29">29</a><a id="L30" href="#L30">30</a><a id="L31" href="#L31">31</a><a id="L32" href="#L32">32</a><a id="L33" href="#L33">33</a><a id="L34" href="#L34">34</a><a id="L35" href="#L35">35</a><a id="L36" href="#L36">36</a><a id="L37" href="#L37">37</a><a id="L38" href="#L38">38</a><a id="L39" href="#L39">39</a><a id="L40" href="#L40">40</a><a id="L41" href="#L41">41</a><a id="L42" href="#L42">42</a><a id="L43" href="#L43">43</a><a id="L44" href="#L44">44</a><a id="L45" href="#L45">45</a><a id="L46" href="#L46">46</a><a id="L47" href="#L47">47</a><a id="L48" href="#L48">48</a><a id="L49" href="#L49">49</a><a id="L50" href="#L50">50</a><a id="L51" href="#L51">51</a><a id="L52" href="#L52">52</a><a id="L53" href="#L53">53</a><a id="L54" href="#L54">54</a><a id="L55" href="#L55">55</a><a id="L56" href="#L56">56</a><a id="L57" href="#L57">57</a><a id="L58" href="#L58">58</a><a id="L59" href="#L59">59</a><a id="L60" href="#L60">60</a><a id="L61" href="#L61">61</a><a id="L62" href="#L62">62</a><a id="L63" href="#L63">63</a><a id="L64" href="#L64">64</a><a id="L65" href="#L65">65</a><a id="L66" href="#L66">66</a><a id="L67" href="#L67">67</a><a id="L68" href="#L68">68</a><a id="L69" href="#L69">69</a><a id="L70" href="#L70">70</a><a id="L71" href="#L71">71</a><a id="L72" href="#L72">72</a><a id="L73" href="#L73">73</a><a id="L74" href="#L74">74</a><a id="L75" href="#L75">75</a><a id="L76" href="#L76">76</a><a id="L77" href="#L77">77</a><a id="L78" href="#L78">78</a><a id="L79" href="#L79">79</a><a id="L80" href="#L80">80</a><a id="L81" href="#L81">81</a><a id="L82" href="#L82">82</a><a id="L83" href="#L83">83</a><a id="L84" href="#L84">84</a><a id="L85" href="#L85">85</a><a id="L86" href="#L86">86</a><a id="L87" href="#L87">87</a><a id="L88" href="#L88">88</a><a id="L89" href="#L89">89</a><a id="L90" href="#L90">90</a><a id="L91" href="#L91">91</a><a id="L92" href="#L92">92</a><a id="L93" href="#L93">93</a><a id="L94" href="#L94">94</a><a id="L95" href="#L95">95</a><a id="L96" href="#L96">96</a><a id="L97" href="#L97">97</a><a id="L98" href="#L98">98</a><a id="L99" href="#L99">99</a><a id="L100" href="#L100">100</a><a id="L101" href="#L101">101</a><a id="L102" href="#L102">102</a><a id="L103" href="#L103">103</a><a id="L104" href="#L104">104</a><a id="L105" href="#L105">105</a><a id="L106" href="#L106">106</a><a id="L107" href="#L107">107</a><a id="L108" href="#L108">108</a><a id="L109" href="#L109">109</a><a id="L110" href="#L110">110</a><a id="L111" href="#L111">111</a><a id="L112" href="#L112">112</a><a id="L113" href="#L113">113</a><a id="L114" href="#L114">114</a><a id="L115" href="#L115">115</a><a id="L116" href="#L116">116</a><a id="L117" href="#L117">117</a><a id="L118" href="#L118">118</a><a id="L119" href="#L119">119</a><a id="L120" href="#L120">120</a><a id="L121" href="#L121">121</a><a id="L122" href="#L122">122</a><a id="L123" href="#L123">123</a><a id="L124" href="#L124">124</a><a id="L125" href="#L125">125</a><a id="L126" href="#L126">126</a><a id="L127" href="#L127">127</a><a id="L128" href="#L128">128</a><a id="L129" href="#L129">129</a><a id="L130" href="#L130">130</a><a id="L131" href="#L131">131</a><a id="L132" href="#L132">132</a><a id="L133" href="#L133">133</a><a id="L134" href="#L134">134</a><a id="L135" href="#L135">135</a><a id="L136" href="#L136">136</a><a id="L137" href="#L137">137</a><a id="L138" href="#L138">138</a><a id="L139" href="#L139">139</a><a id="L140" href="#L140">140</a><a id="L141" href="#L141">141</a><a id="L142" href="#L142">142</a><a id="L143" href="#L143">143</a><a id="L144" href="#L144">144</a><a id="L145" href="#L145">145</a><a id="L146" href="#L146">146</a><a id="L147" href="#L147">147</a><a id="L148" href="#L148">148</a><a id="L149" href="#L149">149</a><a id="L150" href="#L150">150</a><a id="L151" href="#L151">151</a><a id="L152" href="#L152">152</a><a id="L153" href="#L153">153</a><a id="L154" href="#L154">154</a><a id="L155" href="#L155">155</a><a id="L156" href="#L156">156</a><a id="L157" href="#L157">157</a><a id="L158" href="#L158">158</a><a id="L159" href="#L159">159</a><a id="L160" href="#L160">160</a><a id="L161" href="#L161">161</a><a id="L162" href="#L162">162</a><a id="L163" href="#L163">163</a><a id="L164" href="#L164">164</a><a id="L165" href="#L165">165</a><a id="L166" href="#L166">166</a><a id="L167" href="#L167">167</a><a id="L168" href="#L168">168</a><a id="L169" href="#L169">169</a><a id="L170" href="#L170">170</a><a id="L171" href="#L171">171</a><a id="L172" href="#L172">172</a><a id="L173" href="#L173">173</a><a id="L174" href="#L174">174</a><a id="L175" href="#L175">175</a><a id="L176" href="#L176">176</a><a id="L177" href="#L177">177</a><a id="L178" href="#L178">178</a><a id="L179" href="#L179">179</a><a id="L180" href="#L180">180</a><a id="L181" href="#L181">181</a><a id="L182" href="#L182">182</a><a id="L183" href="#L183">183</a><a id="L184" href="#L184">184</a><a id="L185" href="#L185">185</a><a id="L186" href="#L186">186</a><a id="L187" href="#L187">187</a><a id="L188" href="#L188">188</a><a id="L189" href="#L189">189</a><a id="L190" href="#L190">190</a><a id="L191" href="#L191">191</a><a id="L192" href="#L192">192</a><a id="L193" href="#L193">193</a><a id="L194" href="#L194">194</a><a id="L195" href="#L195">195</a><a id="L196" href="#L196">196</a><a id="L197" href="#L197">197</a><a id="L198" href="#L198">198</a><a id="L199" href="#L199">199</a><a id="L200" href="#L200">200</a><a id="L201" href="#L201">201</a><a id="L202" href="#L202">202</a><a id="L203" href="#L203">203</a><a id="L204" href="#L204">204</a><a id="L205" href="#L205">205</a><a id="L206" href="#L206">206</a><a id="L207" href="#L207">207</a><a id="L208" href="#L208">208</a><a id="L209" href="#L209">209</a><a id="L210" href="#L210">210</a><a id="L211" href="#L211">211</a><a id="L212" href="#L212">212</a><a id="L213" href="#L213">213</a><a id="L214" href="#L214">214</a><a id="L215" href="#L215">215</a><a id="L216" href="#L216">216</a><a id="L217" href="#L217">217</a><a id="L218" href="#L218">218</a><a id="L219" href="#L219">219</a><a id="L220" href="#L220">220</a><a id="L221" href="#L221">221</a><a id="L222" href="#L222">222</a><a id="L223" href="#L223">223</a><a id="L224" href="#L224">224</a><a id="L225" href="#L225">225</a><a id="L226" href="#L226">226</a><a id="L227" href="#L227">227</a><a id="L228" href="#L228">228</a><a id="L229" href="#L229">229</a><a id="L230" href="#L230">230</a><a id="L231" href="#L231">231</a><a id="L232" href="#L232">232</a><a id="L233" href="#L233">233</a><a id="L234" href="#L234">234</a><a id="L235" href="#L235">235</a><a id="L236" href="#L236">236</a><a id="L237" href="#L237">237</a><a id="L238" href="#L238">238</a><a id="L239" href="#L239">239</a><a id="L240" href="#L240">240</a><a id="L241" href="#L241">241</a><a id="L242" href="#L242">242</a><a id="L243" href="#L243">243</a><a id="L244" href="#L244">244</a><a id="L245" href="#L245">245</a><a id="L246" href="#L246">246</a><a id="L247" href="#L247">247</a><a id="L248" href="#L248">248</a><a id="L249" href="#L249">249</a><a id="L250" href="#L250">250</a><a id="L251" href="#L251">251</a><a id="L252" href="#L252">252</a><a id="L253" href="#L253">253</a><a id="L254" href="#L254">254</a><a id="L255" href="#L255">255</a><a id="L256" href="#L256">256</a><a id="L257" href="#L257">257</a><a id="L258" href="#L258">258</a><a id="L259" href="#L259">259</a><a id="L260" href="#L260">260</a><a id="L261" href="#L261">261</a><a id="L262" href="#L262">262</a><a id="L263" href="#L263">263</a><a id="L264" href="#L264">264</a><a id="L265" href="#L265">265</a><a id="L266" href="#L266">266</a><a id="L267" href="#L267">267</a><a id="L268" href="#L268">268</a><a id="L269" href="#L269">269</a><a id="L270" href="#L270">270</a><a id="L271" href="#L271">271</a><a id="L272" href="#L272">272</a><a id="L273" href="#L273">273</a><a id="L274" href="#L274">274</a><a id="L275" href="#L275">275</a><a id="L276" href="#L276">276</a><a id="L277" href="#L277">277</a><a id="L278" href="#L278">278</a><a id="L279" href="#L279">279</a><a id="L280" href="#L280">280</a><a id="L281" href="#L281">281</a><a id="L282" href="#L282">282</a><a id="L283" href="#L283">283</a><a id="L284" href="#L284">284</a><a id="L285" href="#L285">285</a><a id="L286" href="#L286">286</a><a id="L287" href="#L287">287</a><a id="L288" href="#L288">288</a><a id="L289" href="#L289">289</a><a id="L290" href="#L290">290</a><a id="L291" href="#L291">291</a><a id="L292" href="#L292">292</a><a id="L293" href="#L293">293</a><a id="L294" href="#L294">294</a><a id="L295" href="#L295">295</a><a id="L296" href="#L296">296</a><a id="L297" href="#L297">297</a><a id="L298" href="#L298">298</a><a id="L299" href="#L299">299</a><a id="L300" href="#L300">300</a><a id="L301" href="#L301">301</a><a id="L302" href="#L302">302</a><a id="L303" href="#L303">303</a><a id="L304" href="#L304">304</a><a id="L305" href="#L305">305</a><a id="L306" href="#L306">306</a><a id="L307" href="#L307">307</a><a id="L308" href="#L308">308</a><a id="L309" href="#L309">309</a><a id="L310" href="#L310">310</a><a id="L311" href="#L311">311</a><a id="L312" href="#L312">312</a><a id="L313" href="#L313">313</a><a id="L314" href="#L314">314</a><a id="L315" href="#L315">315</a><a id="L316" href="#L316">316</a><a id="L317" href="#L317">317</a><a id="L318" href="#L318">318</a><a id="L319" href="#L319">319</a><a id="L320" href="#L320">320</a><a id="L321" href="#L321">321</a><a id="L322" href="#L322">322</a><a id="L323" href="#L323">323</a><a id="L324" href="#L324">324</a><a id="L325" href="#L325">325</a><a id="L326" href="#L326">326</a><a id="L327" href="#L327">327</a><a id="L328" href="#L328">328</a><a id="L329" href="#L329">329</a><a id="L330" href="#L330">330</a><a id="L331" href="#L331">331</a><a id="L332" href="#L332">332</a><a id="L333" href="#L333">333</a><a id="L334" href="#L334">334</a><a id="L335" href="#L335">335</a><a id="L336" href="#L336">336</a><a id="L337" href="#L337">337</a><a id="L338" href="#L338">338</a><a id="L339" href="#L339">339</a><a id="L340" href="#L340">340</a><a id="L341" href="#L341">341</a><a id="L342" href="#L342">342</a><a id="L343" href="#L343">343</a><a id="L344" href="#L344">344</a><a id="L345" href="#L345">345</a><a id="L346" href="#L346">346</a><a id="L347" href="#L347">347</a><a id="L348" href="#L348">348</a><a id="L349" href="#L349">349</a><a id="L350" href="#L350">350</a><a id="L351" href="#L351">351</a><a id="L352" href="#L352">352</a><a id="L353" href="#L353">353</a><a id="L354" href="#L354">354</a><a id="L355" href="#L355">355</a><a id="L356" href="#L356">356</a><a id="L357" href="#L357">357</a><a id="L358" href="#L358">358</a><a id="L359" href="#L359">359</a><a id="L360" href="#L360">360</a><a id="L361" href="#L361">361</a><a id="L362" href="#L362">362</a><a id="L363" href="#L363">363</a><a id="L364" href="#L364">364</a><a id="L365" href="#L365">365</a><a id="L366" href="#L366">366</a><a id="L367" href="#L367">367</a><a id="L368" href="#L368">368</a><a id="L369" href="#L369">369</a><a id="L370" href="#L370">370</a><a id="L371" href="#L371">371</a><a id="L372" href="#L372">372</a><a id="L373" href="#L373">373</a><a id="L374" href="#L374">374</a><a id="L375" href="#L375">375</a><a id="L376" href="#L376">376</a><a id="L377" href="#L377">377</a><a id="L378" href="#L378">378</a><a id="L379" href="#L379">379</a><a id="L380" href="#L380">380</a><a id="L381" href="#L381">381</a><a id="L382" href="#L382">382</a><a id="L383" href="#L383">383</a><a id="L384" href="#L384">384</a><a id="L385" href="#L385">385</a><a id="L386" href="#L386">386</a><a id="L387" href="#L387">387</a><a id="L388" href="#L388">388</a><a id="L389" href="#L389">389</a><a id="L390" href="#L390">390</a><a id="L391" href="#L391">391</a><a id="L392" href="#L392">392</a><a id="L393" href="#L393">393</a><a id="L394" href="#L394">394</a><a id="L395" href="#L395">395</a><a id="L396" href="#L396">396</a><a id="L397" href="#L397">397</a><a id="L398" href="#L398">398</a><a id="L399" href="#L399">399</a><a id="L400" href="#L400">400</a><a id="L401" href="#L401">401</a><a id="L402" href="#L402">402</a><a id="L403" href="#L403">403</a><a id="L404" href="#L404">404</a><a id="L405" href="#L405">405</a><a id="L406" href="#L406">406</a><a id="L407" href="#L407">407</a><a id="L408" href="#L408">408</a><a id="L409" href="#L409">409</a><a id="L410" href="#L410">410</a><a id="L411" href="#L411">411</a><a id="L412" href="#L412">412</a><a id="L413" href="#L413">413</a><a id="L414" href="#L414">414</a><a id="L415" href="#L415">415</a><a id="L416" href="#L416">416</a><a id="L417" href="#L417">417</a><a id="L418" href="#L418">418</a><a id="L419" href="#L419">419</a><a id="L420" href="#L420">420</a><a id="L421" href="#L421">421</a><a id="L422" href="#L422">422</a><a id="L423" href="#L423">423</a><a id="L424" href="#L424">424</a><a id="L425" href="#L425">425</a><a id="L426" href="#L426">426</a><a id="L427" href="#L427">427</a><a id="L428" href="#L428">428</a><a id="L429" href="#L429">429</a><a id="L430" href="#L430">430</a><a id="L431" href="#L431">431</a><a id="L432" href="#L432">432</a><a id="L433" href="#L433">433</a><a id="L434" href="#L434">434</a><a id="L435" href="#L435">435</a><a id="L436" href="#L436">436</a><a id="L437" href="#L437">437</a><a id="L438" href="#L438">438</a><a id="L439" href="#L439">439</a><a id="L440" href="#L440">440</a><a id="L441" href="#L441">441</a><a id="L442" href="#L442">442</a><a id="L443" href="#L443">443</a><a id="L444" href="#L444">444</a><a id="L445" href="#L445">445</a><a id="L446" href="#L446">446</a><a id="L447" href="#L447">447</a><a id="L448" href="#L448">448</a><a id="L449" href="#L449">449</a><a id="L450" href="#L450">450</a><a id="L451" href="#L451">451</a><a id="L452" href="#L452">452</a><a id="L453" href="#L453">453</a><a id="L454" href="#L454">454</a><a id="L455" href="#L455">455</a><a id="L456" href="#L456">456</a><a id="L457" href="#L457">457</a><a id="L458" href="#L458">458</a><a id="L459" href="#L459">459</a><a id="L460" href="#L460">460</a><a id="L461" href="#L461">461</a><a id="L462" href="#L462">462</a><a id="L463" href="#L463">463</a><a id="L464" href="#L464">464</a><a id="L465" href="#L465">465</a><a id="L466" href="#L466">466</a><a id="L467" href="#L467">467</a><a id="L468" href="#L468">468</a><a id="L469" href="#L469">469</a><a id="L470" href="#L470">470</a><a id="L471" href="#L471">471</a><a id="L472" href="#L472">472</a><a id="L473" href="#L473">473</a><a id="L474" href="#L474">474</a><a id="L475" href="#L475">475</a><a id="L476" href="#L476">476</a><a id="L477" href="#L477">477</a><a id="L478" href="#L478">478</a><a id="L479" href="#L479">479</a><a id="L480" href="#L480">480</a><a id="L481" href="#L481">481</a><a id="L482" href="#L482">482</a><a id="L483" href="#L483">483</a><a id="L484" href="#L484">484</a><a id="L485" href="#L485">485</a><a id="L486" href="#L486">486</a><a id="L487" href="#L487">487</a><a id="L488" href="#L488">488</a><a id="L489" href="#L489">489</a><a id="L490" href="#L490">490</a><a id="L491" href="#L491">491</a><a id="L492" href="#L492">492</a><a id="L493" href="#L493">493</a><a id="L494" href="#L494">494</a><a id="L495" href="#L495">495</a><a id="L496" href="#L496">496</a><a id="L497" href="#L497">497</a><a id="L498" href="#L498">498</a><a id="L499" href="#L499">499</a><a id="L500" href="#L500">500</a><a id="L501" href="#L501">501</a><a id="L502" href="#L502">502</a><a id="L503" href="#L503">503</a><a id="L504" href="#L504">504</a><a id="L505" href="#L505">505</a><a id="L506" href="#L506">506</a><a id="L507" href="#L507">507</a><a id="L508" href="#L508">508</a><a id="L509" href="#L509">509</a><a id="L510" href="#L510">510</a><a id="L511" href="#L511">511</a><a id="L512" href="#L512">512</a><a id="L513" href="#L513">513</a><a id="L514" href="#L514">514</a><a id="L515" href="#L515">515</a><a id="L516" href="#L516">516</a><a id="L517" href="#L517">517</a><a id="L518" href="#L518">518</a><a id="L519" href="#L519">519</a><a id="L520" href="#L520">520</a><a id="L521" href="#L521">521</a><a id="L522" href="#L522">522</a><a id="L523" href="#L523">523</a><a id="L524" href="#L524">524</a><a id="L525" href="#L525">525</a><a id="L526" href="#L526">526</a><a id="L527" href="#L527">527</a><a id="L528" href="#L528">528</a><a id="L529" href="#L529">529</a><a id="L530" href="#L530">530</a><a id="L531" href="#L531">531</a><a id="L532" href="#L532">532</a><a id="L533" href="#L533">533</a><a id="L534" href="#L534">534</a><a id="L535" href="#L535">535</a><a id="L536" href="#L536">536</a><a id="L537" href="#L537">537</a><a id="L538" href="#L538">538</a><a id="L539" href="#L539">539</a><a id="L540" href="#L540">540</a><a id="L541" href="#L541">541</a><a id="L542" href="#L542">542</a><a id="L543" href="#L543">543</a><a id="L544" href="#L544">544</a><a id="L545" href="#L545">545</a><a id="L546" href="#L546">546</a><a id="L547" href="#L547">547</a><a id="L548" href="#L548">548</a><a id="L549" href="#L549">549</a><a id="L550" href="#L550">550</a><a id="L551" href="#L551">551</a><a id="L552" href="#L552">552</a><a id="L553" href="#L553">553</a><a id="L554" href="#L554">554</a><a id="L555" href="#L555">555</a><a id="L556" href="#L556">556</a><a id="L557" href="#L557">557</a><a id="L558" href="#L558">558</a><a id="L559" href="#L559">559</a><a id="L560" href="#L560">560</a><a id="L561" href="#L561">561</a><a id="L562" href="#L562">562</a><a id="L563" href="#L563">563</a><a id="L564" href="#L564">564</a><a id="L565" href="#L565">565</a><a id="L566" href="#L566">566</a><a id="L567" href="#L567">567</a><a id="L568" href="#L568">568</a><a id="L569" href="#L569">569</a><a id="L570" href="#L570">570</a><a id="L571" href="#L571">571</a><a id="L572" href="#L572">572</a><a id="L573" href="#L573">573</a><a id="L574" href="#L574">574</a><a id="L575" href="#L575">575</a><a id="L576" href="#L576">576</a><a id="L577" href="#L577">577</a><a id="L578" href="#L578">578</a><a id="L579" href="#L579">579</a><a id="L580" href="#L580">580</a><a id="L581" href="#L581">581</a><a id="L582" href="#L582">582</a><a id="L583" href="#L583">583</a><a id="L584" href="#L584">584</a><a id="L585" href="#L585">585</a><a id="L586" href="#L586">586</a><a id="L587" href="#L587">587</a><a id="L588" href="#L588">588</a><a id="L589" href="#L589">589</a><a id="L590" href="#L590">590</a><a id="L591" href="#L591">591</a><a id="L592" href="#L592">592</a><a id="L593" href="#L593">593</a><a id="L594" href="#L594">594</a><a id="L595" href="#L595">595</a><a id="L596" href="#L596">596</a><a id="L597" href="#L597">597</a><a id="L598" href="#L598">598</a><a id="L599" href="#L599">599</a><a id="L600" href="#L600">600</a><a id="L601" href="#L601">601</a><a id="L602" href="#L602">602</a><a id="L603" href="#L603">603</a><a id="L604" href="#L604">604</a><a id="L605" href="#L605">605</a><a id="L606" href="#L606">606</a><a id="L607" href="#L607">607</a><a id="L608" href="#L608">608</a><a id="L609" href="#L609">609</a><a id="L610" href="#L610">610</a><a id="L611" href="#L611">611</a><a id="L612" href="#L612">612</a><a id="L613" href="#L613">613</a><a id="L614" href="#L614">614</a><a id="L615" href="#L615">615</a><a id="L616" href="#L616">616</a><a id="L617" href="#L617">617</a><a id="L618" href="#L618">618</a><a id="L619" href="#L619">619</a><a id="L620" href="#L620">620</a><a id="L621" href="#L621">621</a><a id="L622" href="#L622">622</a><a id="L623" href="#L623">623</a><a id="L624" href="#L624">624</a><a id="L625" href="#L625">625</a><a id="L626" href="#L626">626</a><a id="L627" href="#L627">627</a><a id="L628" href="#L628">628</a><a id="L629" href="#L629">629</a><a id="L630" href="#L630">630</a><a id="L631" href="#L631">631</a><a id="L632" href="#L632">632</a><a id="L633" href="#L633">633</a><a id="L634" href="#L634">634</a><a id="L635" href="#L635">635</a><a id="L636" href="#L636">636</a><a id="L637" href="#L637">637</a><a id="L638" href="#L638">638</a><a id="L639" href="#L639">639</a><a id="L640" href="#L640">640</a><a id="L641" href="#L641">641</a><a id="L642" href="#L642">642</a><a id="L643" href="#L643">643</a><a id="L644" href="#L644">644</a><a id="L645" href="#L645">645</a><a id="L646" href="#L646">646</a><a id="L647" href="#L647">647</a><a id="L648" href="#L648">648</a><a id="L649" href="#L649">649</a><a id="L650" href="#L650">650</a><a id="L651" href="#L651">651</a><a id="L652" href="#L652">652</a><a id="L653" href="#L653">653</a><a id="L654" href="#L654">654</a><a id="L655" href="#L655">655</a><a id="L656" href="#L656">656</a><a id="L657" href="#L657">657</a><a id="L658" href="#L658">658</a><a id="L659" href="#L659">659</a><a id="L660" href="#L660">660</a><a id="L661" href="#L661">661</a><a id="L662" href="#L662">662</a><a id="L663" href="#L663">663</a><a id="L664" href="#L664">664</a><a id="L665" href="#L665">665</a><a id="L666" href="#L666">666</a><a id="L667" href="#L667">667</a><a id="L668" href="#L668">668</a><a id="L669" href="#L669">669</a><a id="L670" href="#L670">670</a><a id="L671" href="#L671">671</a><a id="L672" href="#L672">672</a><a id="L673" href="#L673">673</a><a id="L674" href="#L674">674</a><a id="L675" href="#L675">675</a><a id="L676" href="#L676">676</a><a id="L677" href="#L677">677</a><a id="L678" href="#L678">678</a><a id="L679" href="#L679">679</a><a id="L680" href="#L680">680</a><a id="L681" href="#L681">681</a><a id="L682" href="#L682">682</a><a id="L683" href="#L683">683</a><a id="L684" href="#L684">684</a><a id="L685" href="#L685">685</a><a id="L686" href="#L686">686</a><a id="L687" href="#L687">687</a><a id="L688" href="#L688">688</a><a id="L689" href="#L689">689</a><a id="L690" href="#L690">690</a><a id="L691" href="#L691">691</a><a id="L692" href="#L692">692</a><a id="L693" href="#L693">693</a><a id="L694" href="#L694">694</a><a id="L695" href="#L695">695</a><a id="L696" href="#L696">696</a><a id="L697" href="#L697">697</a><a id="L698" href="#L698">698</a><a id="L699" href="#L699">699</a><a id="L700" href="#L700">700</a><a id="L701" href="#L701">701</a><a id="L702" href="#L702">702</a><a id="L703" href="#L703">703</a><a id="L704" href="#L704">704</a><a id="L705" href="#L705">705</a><a id="L706" href="#L706">706</a><a id="L707" href="#L707">707</a><a id="L708" href="#L708">708</a><a id="L709" href="#L709">709</a><a id="L710" href="#L710">710</a><a id="L711" href="#L711">711</a><a id="L712" href="#L712">712</a><a id="L713" href="#L713">713</a><a id="L714" href="#L714">714</a><a id="L715" href="#L715">715</a><a id="L716" href="#L716">716</a><a id="L717" href="#L717">717</a><a id="L718" href="#L718">718</a><a id="L719" href="#L719">719</a><a id="L720" href="#L720">720</a><a id="L721" href="#L721">721</a><a id="L722" href="#L722">722</a><a id="L723" href="#L723">723</a><a id="L724" href="#L724">724</a><a id="L725" href="#L725">725</a><a id="L726" href="#L726">726</a><a id="L727" href="#L727">727</a><a id="L728" href="#L728">728</a><a id="L729" href="#L729">729</a><a id="L730" href="#L730">730</a><a id="L731" href="#L731">731</a><a id="L732" href="#L732">732</a><a id="L733" href="#L733">733</a><a id="L734" href="#L734">734</a><a id="L735" href="#L735">735</a><a id="L736" href="#L736">736</a><a id="L737" href="#L737">737</a><a id="L738" href="#L738">738</a><a id="L739" href="#L739">739</a><a id="L740" href="#L740">740</a><a id="L741" href="#L741">741</a><a id="L742" href="#L742">742</a><a id="L743" href="#L743">743</a><a id="L744" href="#L744">744</a><a id="L745" href="#L745">745</a><a id="L746" href="#L746">746</a><a id="L747" href="#L747">747</a><a id="L748" href="#L748">748</a><a id="L749" href="#L749">749</a><a id="L750" href="#L750">750</a><a id="L751" href="#L751">751</a><a id="L752" href="#L752">752</a><a id="L753" href="#L753">753</a><a id="L754" href="#L754">754</a><a id="L755" href="#L755">755</a><a id="L756" href="#L756">756</a><a id="L757" href="#L757">757</a><a id="L758" href="#L758">758</a><a id="L759" href="#L759">759</a><a id="L760" href="#L760">760</a><a id="L761" href="#L761">761</a><a id="L762" href="#L762">762</a><a id="L763" href="#L763">763</a><a id="L764" href="#L764">764</a><a id="L765" href="#L765">765</a><a id="L766" href="#L766">766</a><a id="L767" href="#L767">767</a><a id="L768" href="#L768">768</a><a id="L769" href="#L769">769</a><a id="L770" href="#L770">770</a><a id="L771" href="#L771">771</a><a id="L772" href="#L772">772</a><a id="L773" href="#L773">773</a><a id="L774" href="#L774">774</a><a id="L775" href="#L775">775</a><a id="L776" href="#L776">776</a><a id="L777" href="#L777">777</a><a id="L778" href="#L778">778</a><a id="L779" href="#L779">779</a><a id="L780" href="#L780">780</a><a id="L781" href="#L781">781</a><a id="L782" href="#L782">782</a><a id="L783" href="#L783">783</a><a id="L784" href="#L784">784</a><a id="L785" href="#L785">785</a><a id="L786" href="#L786">786</a><a id="L787" href="#L787">787</a><a id="L788" href="#L788">788</a><a id="L789" href="#L789">789</a><a id="L790" href="#L790">790</a><a id="L791" href="#L791">791</a><a id="L792" href="#L792">792</a><a id="L793" href="#L793">793</a><a id="L794" href="#L794">794</a><a id="L795" href="#L795">795</a><a id="L796" href="#L796">796</a><a id="L797" href="#L797">797</a><a id="L798" href="#L798">798</a><a id="L799" href="#L799">799</a><a id="L800" href="#L800">800</a><a id="L801" href="#L801">801</a><a id="L802" href="#L802">802</a><a id="L803" href="#L803">803</a><a id="L804" href="#L804">804</a><a id="L805" href="#L805">805</a><a id="L806" href="#L806">806</a><a id="L807" href="#L807">807</a><a id="L808" href="#L808">808</a><a id="L809" href="#L809">809</a><a id="L810" href="#L810">810</a><a id="L811" href="#L811">811</a><a id="L812" href="#L812">812</a><a id="L813" href="#L813">813</a><a id="L814" href="#L814">814</a><a id="L815" href="#L815">815</a><a id="L816" href="#L816">816</a><a id="L817" href="#L817">817</a><a id="L818" href="#L818">818</a><a id="L819" href="#L819">819</a><a id="L820" href="#L820">820</a><a id="L821" href="#L821">821</a><a id="L822" href="#L822">822</a><a id="L823" href="#L823">823</a><a id="L824" href="#L824">824</a><a id="L825" href="#L825">825</a><a id="L826" href="#L826">826</a><a id="L827" href="#L827">827</a><a id="L828" href="#L828">828</a><a id="L829" href="#L829">829</a><a id="L830" href="#L830">830</a><a id="L831" href="#L831">831</a><a id="L832" href="#L832">832</a><a id="L833" href="#L833">833</a><a id="L834" href="#L834">834</a><a id="L835" href="#L835">835</a><a id="L836" href="#L836">836</a><a id="L837" href="#L837">837</a><a id="L838" href="#L838">838</a><a id="L839" href="#L839">839</a><a id="L840" href="#L840">840</a><a id="L841" href="#L841">841</a><a id="L842" href="#L842">842</a><a id="L843" href="#L843">843</a><a id="L844" href="#L844">844</a><a id="L845" href="#L845">845</a><a id="L846" href="#L846">846</a><a id="L847" href="#L847">847</a><a id="L848" href="#L848">848</a><a id="L849" href="#L849">849</a><a id="L850" href="#L850">850</a><a id="L851" href="#L851">851</a><a id="L852" href="#L852">852</a><a id="L853" href="#L853">853</a><a id="L854" href="#L854">854</a><a id="L855" href="#L855">855</a><a id="L856" href="#L856">856</a><a id="L857" href="#L857">857</a><a id="L858" href="#L858">858</a><a id="L859" href="#L859">859</a><a id="L860" href="#L860">860</a><a id="L861" href="#L861">861</a><a id="L862" href="#L862">862</a><a id="L863" href="#L863">863</a><a id="L864" href="#L864">864</a><a id="L865" href="#L865">865</a><a id="L866" href="#L866">866</a><a id="L867" href="#L867">867</a><a id="L868" href="#L868">868</a><a id="L869" href="#L869">869</a><a id="L870" href="#L870">870</a><a id="L871" href="#L871">871</a><a id="L872" href="#L872">872</a><a id="L873" href="#L873">873</a><a id="L874" href="#L874">874</a><a id="L875" href="#L875">875</a><a id="L876" href="#L876">876</a><a id="L877" href="#L877">877</a><a id="L878" href="#L878">878</a><a id="L879" href="#L879">879</a><a id="L880" href="#L880">880</a><a id="L881" href="#L881">881</a><a id="L882" href="#L882">882</a><a id="L883" href="#L883">883</a><a id="L884" href="#L884">884</a><a id="L885" href="#L885">885</a><a id="L886" href="#L886">886</a><a id="L887" href="#L887">887</a><a id="L888" href="#L888">888</a><a id="L889" href="#L889">889</a><a id="L890" href="#L890">890</a><a id="L891" href="#L891">891</a><a id="L892" href="#L892">892</a><a id="L893" href="#L893">893</a><a id="L894" href="#L894">894</a><a id="L895" href="#L895">895</a><a id="L896" href="#L896">896</a><a id="L897" href="#L897">897</a><a id="L898" href="#L898">898</a><a id="L899" href="#L899">899</a><a id="L900" href="#L900">900</a><a id="L901" href="#L901">901</a><a id="L902" href="#L902">902</a><a id="L903" href="#L903">903</a><a id="L904" href="#L904">904</a><a id="L905" href="#L905">905</a><a id="L906" href="#L906">906</a><a id="L907" href="#L907">907</a><a id="L908" href="#L908">908</a><a id="L909" href="#L909">909</a><a id="L910" href="#L910">910</a><a id="L911" href="#L911">911</a><a id="L912" href="#L912">912</a><a id="L913" href="#L913">913</a><a id="L914" href="#L914">914</a><a id="L915" href="#L915">915</a><a id="L916" href="#L916">916</a><a id="L917" href="#L917">917</a><a id="L918" href="#L918">918</a><a id="L919" href="#L919">919</a><a id="L920" href="#L920">920</a><a id="L921" href="#L921">921</a><a id="L922" href="#L922">922</a><a id="L923" href="#L923">923</a><a id="L924" href="#L924">924</a><a id="L925" href="#L925">925</a><a id="L926" href="#L926">926</a><a id="L927" href="#L927">927</a><a id="L928" href="#L928">928</a><a id="L929" href="#L929">929</a><a id="L930" href="#L930">930</a><a id="L931" href="#L931">931</a><a id="L932" href="#L932">932</a><a id="L933" href="#L933">933</a><a id="L934" href="#L934">934</a><a id="L935" href="#L935">935</a><a id="L936" href="#L936">936</a><a id="L937" href="#L937">937</a><a id="L938" href="#L938">938</a><a id="L939" href="#L939">939</a><a id="L940" href="#L940">940</a><a id="L941" href="#L941">941</a><a id="L942" href="#L942">942</a><a id="L943" href="#L943">943</a><a id="L944" href="#L944">944</a><a id="L945" href="#L945">945</a><a id="L946" href="#L946">946</a><a id="L947" href="#L947">947</a><a id="L948" href="#L948">948</a><a id="L949" href="#L949">949</a><a id="L950" href="#L950">950</a><a id="L951" href="#L951">951</a><a id="L952" href="#L952">952</a><a id="L953" href="#L953">953</a><a id="L954" href="#L954">954</a><a id="L955" href="#L955">955</a><a id="L956" href="#L956">956</a><a id="L957" href="#L957">957</a><a id="L958" href="#L958">958</a><a id="L959" href="#L959">959</a><a id="L960" href="#L960">960</a><a id="L961" href="#L961">961</a><a id="L962" href="#L962">962</a><a id="L963" href="#L963">963</a><a id="L964" href="#L964">964</a><a id="L965" href="#L965">965</a><a id="L966" href="#L966">966</a><a id="L967" href="#L967">967</a><a id="L968" href="#L968">968</a><a id="L969" href="#L969">969</a><a id="L970" href="#L970">970</a><a id="L971" href="#L971">971</a><a id="L972" href="#L972">972</a><a id="L973" href="#L973">973</a><a id="L974" href="#L974">974</a><a id="L975" href="#L975">975</a><a id="L976" href="#L976">976</a><a id="L977" href="#L977">977</a><a id="L978" href="#L978">978</a><a id="L979" href="#L979">979</a><a id="L980" href="#L980">980</a><a id="L981" href="#L981">981</a><a id="L982" href="#L982">982</a><a id="L983" href="#L983">983</a><a id="L984" href="#L984">984</a><a id="L985" href="#L985">985</a><a id="L986" href="#L986">986</a><a id="L987" href="#L987">987</a><a id="L988" href="#L988">988</a><a id="L989" href="#L989">989</a><a id="L990" href="#L990">990</a><a id="L991" href="#L991">991</a><a id="L992" href="#L992">992</a><a id="L993" href="#L993">993</a><a id="L994" href="#L994">994</a><a id="L995" href="#L995">995</a><a id="L996" href="#L996">996</a><a id="L997" href="#L997">997</a><a id="L998" href="#L998">998</a><a id="L999" href="#L999">999</a><a id="L1000" href="#L1000">1000</a><a id="L1001" href="#L1001">1001</a><a id="L1002" href="#L1002">1002</a><a id="L1003" href="#L1003">1003</a><a id="L1004" href="#L1004">1004</a><a id="L1005" href="#L1005">1005</a><a id="L1006" href="#L1006">1006</a><a id="L1007" href="#L1007">1007</a><a id="L1008" href="#L1008">1008</a><a id="L1009" href="#L1009">1009</a><a id="L1010" href="#L1010">1010</a><a id="L1011" href="#L1011">1011</a><a id="L1012" href="#L1012">1012</a><a id="L1013" href="#L1013">1013</a><a id="L1014" href="#L1014">1014</a><a id="L1015" href="#L1015">1015</a><a id="L1016" href="#L1016">1016</a><a id="L1017" href="#L1017">1017</a><a id="L1018" href="#L1018">1018</a><a id="L1019" href="#L1019">1019</a><a id="L1020" href="#L1020">1020</a><a id="L1021" href="#L1021">1021</a><a id="L1022" href="#L1022">1022</a><a id="L1023" href="#L1023">1023</a><a id="L1024" href="#L1024">1024</a><a id="L1025" href="#L1025">1025</a><a id="L1026" href="#L1026">1026</a><a id="L1027" href="#L1027">1027</a><a id="L1028" href="#L1028">1028</a><a id="L1029" href="#L1029">1029</a><a id="L1030" href="#L1030">1030</a><a id="L1031" href="#L1031">1031</a><a id="L1032" href="#L1032">1032</a><a id="L1033" href="#L1033">1033</a><a id="L1034" href="#L1034">1034</a><a id="L1035" href="#L1035">1035</a><a id="L1036" href="#L1036">1036</a><a id="L1037" href="#L1037">1037</a><a id="L1038" href="#L1038">1038</a><a id="L1039" href="#L1039">1039</a><a id="L1040" href="#L1040">1040</a><a id="L1041" href="#L1041">1041</a><a id="L1042" href="#L1042">1042</a><a id="L1043" href="#L1043">1043</a><a id="L1044" href="#L1044">1044</a><a id="L1045" href="#L1045">1045</a><a id="L1046" href="#L1046">1046</a><a id="L1047" href="#L1047">1047</a><a id="L1048" href="#L1048">1048</a><a id="L1049" href="#L1049">1049</a><a id="L1050" href="#L1050">1050</a><a id="L1051" href="#L1051">1051</a><a id="L1052" href="#L1052">1052</a><a id="L1053" href="#L1053">1053</a><a id="L1054" href="#L1054">1054</a><a id="L1055" href="#L1055">1055</a><a id="L1056" href="#L1056">1056</a><a id="L1057" href="#L1057">1057</a><a id="L1058" href="#L1058">1058</a><a id="L1059" href="#L1059">1059</a><a id="L1060" href="#L1060">1060</a><a id="L1061" href="#L1061">1061</a><a id="L1062" href="#L1062">1062</a><a id="L1063" href="#L1063">1063</a><a id="L1064" href="#L1064">1064</a><a id="L1065" href="#L1065">1065</a><a id="L1066" href="#L1066">1066</a><a id="L1067" href="#L1067">1067</a><a id="L1068" href="#L1068">1068</a><a id="L1069" href="#L1069">1069</a><a id="L1070" href="#L1070">1070</a><a id="L1071" href="#L1071">1071</a><a id="L1072" href="#L1072">1072</a><a id="L1073" href="#L1073">1073</a><a id="L1074" href="#L1074">1074</a><a id="L1075" href="#L1075">1075</a><a id="L1076" href="#L1076">1076</a><a id="L1077" href="#L1077">1077</a><a id="L1078" href="#L1078">1078</a><a id="L1079" href="#L1079">1079</a><a id="L1080" href="#L1080">1080</a><a id="L1081" href="#L1081">1081</a><a id="L1082" href="#L1082">1082</a><a id="L1083" href="#L1083">1083</a><a id="L1084" href="#L1084">1084</a><a id="L1085" href="#L1085">1085</a><a id="L1086" href="#L1086">1086</a><a id="L1087" href="#L1087">1087</a><a id="L1088" href="#L1088">1088</a><a id="L1089" href="#L1089">1089</a><a id="L1090" href="#L1090">1090</a><a id="L1091" href="#L1091">1091</a><a id="L1092" href="#L1092">1092</a><a id="L1093" href="#L1093">1093</a><a id="L1094" href="#L1094">1094</a><a id="L1095" href="#L1095">1095</a><a id="L1096" href="#L1096">1096</a><a id="L1097" href="#L1097">1097</a><a id="L1098" href="#L1098">1098</a><a id="L1099" href="#L1099">1099</a><a id="L1100" href="#L1100">1100</a><a id="L1101" href="#L1101">1101</a><a id="L1102" href="#L1102">1102</a><a id="L1103" href="#L1103">1103</a><a id="L1104" href="#L1104">1104</a><a id="L1105" href="#L1105">1105</a><a id="L1106" href="#L1106">1106</a><a id="L1107" href="#L1107">1107</a><a id="L1108" href="#L1108">1108</a><a id="L1109" href="#L1109">1109</a><a id="L1110" href="#L1110">1110</a><a id="L1111" href="#L1111">1111</a><a id="L1112" href="#L1112">1112</a><a id="L1113" href="#L1113">1113</a><a id="L1114" href="#L1114">1114</a><a id="L1115" href="#L1115">1115</a><a id="L1116" href="#L1116">1116</a><a id="L1117" href="#L1117">1117</a><a id="L1118" href="#L1118">1118</a><a id="L1119" href="#L1119">1119</a><a id="L1120" href="#L1120">1120</a><a id="L1121" href="#L1121">1121</a><a id="L1122" href="#L1122">1122</a><a id="L1123" href="#L1123">1123</a><a id="L1124" href="#L1124">1124</a><a id="L1125" href="#L1125">1125</a><a id="L1126" href="#L1126">1126</a><a id="L1127" href="#L1127">1127</a><a id="L1128" href="#L1128">1128</a><a id="L1129" href="#L1129">1129</a><a id="L1130" href="#L1130">1130</a><a id="L1131" href="#L1131">1131</a><a id="L1132" href="#L1132">1132</a><a id="L1133" href="#L1133">1133</a><a id="L1134" href="#L1134">1134</a><a id="L1135" href="#L1135">1135</a><a id="L1136" href="#L1136">1136</a><a id="L1137" href="#L1137">1137</a><a id="L1138" href="#L1138">1138</a><a id="L1139" href="#L1139">1139</a><a id="L1140" href="#L1140">1140</a><a id="L1141" href="#L1141">1141</a><a id="L1142" href="#L1142">1142</a><a id="L1143" href="#L1143">1143</a><a id="L1144" href="#L1144">1144</a><a id="L1145" href="#L1145">1145</a><a id="L1146" href="#L1146">1146</a><a id="L1147" href="#L1147">1147</a><a id="L1148" href="#L1148">1148</a><a id="L1149" href="#L1149">1149</a><a id="L1150" href="#L1150">1150</a><a id="L1151" href="#L1151">1151</a><a id="L1152" href="#L1152">1152</a><a id="L1153" href="#L1153">1153</a><a id="L1154" href="#L1154">1154</a><a id="L1155" href="#L1155">1155</a><a id="L1156" href="#L1156">1156</a><a id="L1157" href="#L1157">1157</a><a id="L1158" href="#L1158">1158</a><a id="L1159" href="#L1159">1159</a><a id="L1160" href="#L1160">1160</a><a id="L1161" href="#L1161">1161</a><a id="L1162" href="#L1162">1162</a><a id="L1163" href="#L1163">1163</a><a id="L1164" href="#L1164">1164</a><a id="L1165" href="#L1165">1165</a><a id="L1166" href="#L1166">1166</a><a id="L1167" href="#L1167">1167</a><a id="L1168" href="#L1168">1168</a><a id="L1169" href="#L1169">1169</a><a id="L1170" href="#L1170">1170</a><a id="L1171" href="#L1171">1171</a><a id="L1172" href="#L1172">1172</a><a id="L1173" href="#L1173">1173</a><a id="L1174" href="#L1174">1174</a><a id="L1175" href="#L1175">1175</a><a id="L1176" href="#L1176">1176</a><a id="L1177" href="#L1177">1177</a><a id="L1178" href="#L1178">1178</a><a id="L1179" href="#L1179">1179</a><a id="L1180" href="#L1180">1180</a><a id="L1181" href="#L1181">1181</a><a id="L1182" href="#L1182">1182</a><a id="L1183" href="#L1183">1183</a><a id="L1184" href="#L1184">1184</a><a id="L1185" href="#L1185">1185</a><a id="L1186" href="#L1186">1186</a><a id="L1187" href="#L1187">1187</a><a id="L1188" href="#L1188">1188</a><a id="L1189" href="#L1189">1189</a><a id="L1190" href="#L1190">1190</a><a id="L1191" href="#L1191">1191</a><a id="L1192" href="#L1192">1192</a><a id="L1193" href="#L1193">1193</a><a id="L1194" href="#L1194">1194</a><a id="L1195" href="#L1195">1195</a><a id="L1196" href="#L1196">1196</a><a id="L1197" href="#L1197">1197</a><a id="L1198" href="#L1198">1198</a><a id="L1199" href="#L1199">1199</a><a id="L1200" href="#L1200">1200</a><a id="L1201" href="#L1201">1201</a><a id="L1202" href="#L1202">1202</a><a id="L1203" href="#L1203">1203</a><a id="L1204" href="#L1204">1204</a><a id="L1205" href="#L1205">1205</a><a id="L1206" href="#L1206">1206</a><a id="L1207" href="#L1207">1207</a><a id="L1208" href="#L1208">1208</a><a id="L1209" href="#L1209">1209</a><a id="L1210" href="#L1210">1210</a><a id="L1211" href="#L1211">1211</a><a id="L1212" href="#L1212">1212</a><a id="L1213" href="#L1213">1213</a><a id="L1214" href="#L1214">1214</a><a id="L1215" href="#L1215">1215</a><a id="L1216" href="#L1216">1216</a><a id="L1217" href="#L1217">1217</a><a id="L1218" href="#L1218">1218</a><a id="L1219" href="#L1219">1219</a><a id="L1220" href="#L1220">1220</a><a id="L1221" href="#L1221">1221</a><a id="L1222" href="#L1222">1222</a><a id="L1223" href="#L1223">1223</a><a id="L1224" href="#L1224">1224</a><a id="L1225" href="#L1225">1225</a><a id="L1226" href="#L1226">1226</a><a id="L1227" href="#L1227">1227</a><a id="L1228" href="#L1228">1228</a><a id="L1229" href="#L1229">1229</a><a id="L1230" href="#L1230">1230</a><a id="L1231" href="#L1231">1231</a><a id="L1232" href="#L1232">1232</a><a id="L1233" href="#L1233">1233</a><a id="L1234" href="#L1234">1234</a><a id="L1235" href="#L1235">1235</a><a id="L1236" href="#L1236">1236</a><a id="L1237" href="#L1237">1237</a><a id="L1238" href="#L1238">1238</a><a id="L1239" href="#L1239">1239</a><a id="L1240" href="#L1240">1240</a><a id="L1241" href="#L1241">1241</a><a id="L1242" href="#L1242">1242</a><a id="L1243" href="#L1243">1243</a><a id="L1244" href="#L1244">1244</a><a id="L1245" href="#L1245">1245</a><a id="L1246" href="#L1246">1246</a><a id="L1247" href="#L1247">1247</a><a id="L1248" href="#L1248">1248</a><a id="L1249" href="#L1249">1249</a><a id="L1250" href="#L1250">1250</a><a id="L1251" href="#L1251">1251</a><a id="L1252" href="#L1252">1252</a><a id="L1253" href="#L1253">1253</a><a id="L1254" href="#L1254">1254</a><a id="L1255" href="#L1255">1255</a><a id="L1256" href="#L1256">1256</a><a id="L1257" href="#L1257">1257</a><a id="L1258" href="#L1258">1258</a><a id="L1259" href="#L1259">1259</a><a id="L1260" href="#L1260">1260</a><a id="L1261" href="#L1261">1261</a><a id="L1262" href="#L1262">1262</a><a id="L1263" href="#L1263">1263</a><a id="L1264" href="#L1264">1264</a><a id="L1265" href="#L1265">1265</a><a id="L1266" href="#L1266">1266</a><a id="L1267" href="#L1267">1267</a><a id="L1268" href="#L1268">1268</a><a id="L1269" href="#L1269">1269</a><a id="L1270" href="#L1270">1270</a><a id="L1271" href="#L1271">1271</a><a id="L1272" href="#L1272">1272</a><a id="L1273" href="#L1273">1273</a><a id="L1274" href="#L1274">1274</a><a id="L1275" href="#L1275">1275</a><a id="L1276" href="#L1276">1276</a><a id="L1277" href="#L1277">1277</a><a id="L1278" href="#L1278">1278</a><a id="L1279" href="#L1279">1279</a><a id="L1280" href="#L1280">1280</a><a id="L1281" href="#L1281">1281</a><a id="L1282" href="#L1282">1282</a><a id="L1283" href="#L1283">1283</a><a id="L1284" href="#L1284">1284</a><a id="L1285" href="#L1285">1285</a><a id="L1286" href="#L1286">1286</a><a id="L1287" href="#L1287">1287</a><a id="L1288" href="#L1288">1288</a><a id="L1289" href="#L1289">1289</a><a id="L1290" href="#L1290">1290</a><a id="L1291" href="#L1291">1291</a><a id="L1292" href="#L1292">1292</a><a id="L1293" href="#L1293">1293</a><a id="L1294" href="#L1294">1294</a><a id="L1295" href="#L1295">1295</a><a id="L1296" href="#L1296">1296</a><a id="L1297" href="#L1297">1297</a><a id="L1298" href="#L1298">1298</a><a id="L1299" href="#L1299">1299</a><a id="L1300" href="#L1300">1300</a><a id="L1301" href="#L1301">1301</a><a id="L1302" href="#L1302">1302</a><a id="L1303" href="#L1303">1303</a><a id="L1304" href="#L1304">1304</a><a id="L1305" href="#L1305">1305</a><a id="L1306" href="#L1306">1306</a><a id="L1307" href="#L1307">1307</a><a id="L1308" href="#L1308">1308</a><a id="L1309" href="#L1309">1309</a><a id="L1310" href="#L1310">1310</a><a id="L1311" href="#L1311">1311</a><a id="L1312" href="#L1312">1312</a><a id="L1313" href="#L1313">1313</a><a id="L1314" href="#L1314">1314</a><a id="L1315" href="#L1315">1315</a><a id="L1316" href="#L1316">1316</a><a id="L1317" href="#L1317">1317</a><a id="L1318" href="#L1318">1318</a><a id="L1319" href="#L1319">1319</a><a id="L1320" href="#L1320">1320</a><a id="L1321" href="#L1321">1321</a><a id="L1322" href="#L1322">1322</a><a id="L1323" href="#L1323">1323</a><a id="L1324" href="#L1324">1324</a><a id="L1325" href="#L1325">1325</a><a id="L1326" href="#L1326">1326</a><a id="L1327" href="#L1327">1327</a><a id="L1328" href="#L1328">1328</a><a id="L1329" href="#L1329">1329</a><a id="L1330" href="#L1330">1330</a><a id="L1331" href="#L1331">1331</a><a id="L1332" href="#L1332">1332</a><a id="L1333" href="#L1333">1333</a><a id="L1334" href="#L1334">1334</a><a id="L1335" href="#L1335">1335</a><a id="L1336" href="#L1336">1336</a><a id="L1337" href="#L1337">1337</a><a id="L1338" href="#L1338">1338</a><a id="L1339" href="#L1339">1339</a><a id="L1340" href="#L1340">1340</a><a id="L1341" href="#L1341">1341</a><a id="L1342" href="#L1342">1342</a><a id="L1343" href="#L1343">1343</a><a id="L1344" href="#L1344">1344</a><a id="L1345" href="#L1345">1345</a><a id="L1346" href="#L1346">1346</a><a id="L1347" href="#L1347">1347</a><a id="L1348" href="#L1348">1348</a><a id="L1349" href="#L1349">1349</a><a id="L1350" href="#L1350">1350</a><a id="L1351" href="#L1351">1351</a><a id="L1352" href="#L1352">1352</a><a id="L1353" href="#L1353">1353</a><a id="L1354" href="#L1354">1354</a><a id="L1355" href="#L1355">1355</a><a id="L1356" href="#L1356">1356</a><a id="L1357" href="#L1357">1357</a><a id="L1358" href="#L1358">1358</a><a id="L1359" href="#L1359">1359</a><a id="L1360" href="#L1360">1360</a><a id="L1361" href="#L1361">1361</a><a id="L1362" href="#L1362">1362</a><a id="L1363" href="#L1363">1363</a><a id="L1364" href="#L1364">1364</a><a id="L1365" href="#L1365">1365</a><a id="L1366" href="#L1366">1366</a><a id="L1367" href="#L1367">1367</a><a id="L1368" href="#L1368">1368</a><a id="L1369" href="#L1369">1369</a><a id="L1370" href="#L1370">1370</a><a id="L1371" href="#L1371">1371</a><a id="L1372" href="#L1372">1372</a><a id="L1373" href="#L1373">1373</a><a id="L1374" href="#L1374">1374</a><a id="L1375" href="#L1375">1375</a><a id="L1376" href="#L1376">1376</a><a id="L1377" href="#L1377">1377</a><a id="L1378" href="#L1378">1378</a><a id="L1379" href="#L1379">1379</a><a id="L1380" href="#L1380">1380</a><a id="L1381" href="#L1381">1381</a><a id="L1382" href="#L1382">1382</a><a id="L1383" href="#L1383">1383</a><a id="L1384" href="#L1384">1384</a><a id="L1385" href="#L1385">1385</a><a id="L1386" href="#L1386">1386</a><a id="L1387" href="#L1387">1387</a><a id="L1388" href="#L1388">1388</a><a id="L1389" href="#L1389">1389</a><a id="L1390" href="#L1390">1390</a><a id="L1391" href="#L1391">1391</a><a id="L1392" href="#L1392">1392</a><a id="L1393" href="#L1393">1393</a><a id="L1394" href="#L1394">1394</a><a id="L1395" href="#L1395">1395</a><a id="L1396" href="#L1396">1396</a><a id="L1397" href="#L1397">1397</a><a id="L1398" href="#L1398">1398</a><a id="L1399" href="#L1399">1399</a><a id="L1400" href="#L1400">1400</a><a id="L1401" href="#L1401">1401</a><a id="L1402" href="#L1402">1402</a><a id="L1403" href="#L1403">1403</a><a id="L1404" href="#L1404">1404</a><a id="L1405" href="#L1405">1405</a><a id="L1406" href="#L1406">1406</a><a id="L1407" href="#L1407">1407</a><a id="L1408" href="#L1408">1408</a><a id="L1409" href="#L1409">1409</a><a id="L1410" href="#L1410">1410</a><a id="L1411" href="#L1411">1411</a><a id="L1412" href="#L1412">1412</a><a id="L1413" href="#L1413">1413</a><a id="L1414" href="#L1414">1414</a><a id="L1415" href="#L1415">1415</a><a id="L1416" href="#L1416">1416</a><a id="L1417" href="#L1417">1417</a><a id="L1418" href="#L1418">1418</a><a id="L1419" href="#L1419">1419</a><a id="L1420" href="#L1420">1420</a><a id="L1421" href="#L1421">1421</a><a id="L1422" href="#L1422">1422</a><a id="L1423" href="#L1423">1423</a><a id="L1424" href="#L1424">1424</a><a id="L1425" href="#L1425">1425</a><a id="L1426" href="#L1426">1426</a><a id="L1427" href="#L1427">1427</a><a id="L1428" href="#L1428">1428</a><a id="L1429" href="#L1429">1429</a><a id="L1430" href="#L1430">1430</a><a id="L1431" href="#L1431">1431</a><a id="L1432" href="#L1432">1432</a><a id="L1433" href="#L1433">1433</a><a id="L1434" href="#L1434">1434</a><a id="L1435" href="#L1435">1435</a><a id="L1436" href="#L1436">1436</a><a id="L1437" href="#L1437">1437</a><a id="L1438" href="#L1438">1438</a><a id="L1439" href="#L1439">1439</a><a id="L1440" href="#L1440">1440</a><a id="L1441" href="#L1441">1441</a><a id="L1442" href="#L1442">1442</a><a id="L1443" href="#L1443">1443</a><a id="L1444" href="#L1444">1444</a><a id="L1445" href="#L1445">1445</a><a id="L1446" href="#L1446">1446</a><a id="L1447" href="#L1447">1447</a><a id="L1448" href="#L1448">1448</a><a id="L1449" href="#L1449">1449</a><a id="L1450" href="#L1450">1450</a><a id="L1451" href="#L1451">1451</a><a id="L1452" href="#L1452">1452</a><a id="L1453" href="#L1453">1453</a><a id="L1454" href="#L1454">1454</a><a id="L1455" href="#L1455">1455</a><a id="L1456" href="#L1456">1456</a><a id="L1457" href="#L1457">1457</a><a id="L1458" href="#L1458">1458</a><a id="L1459" href="#L1459">1459</a><a id="L1460" href="#L1460">1460</a><a id="L1461" href="#L1461">1461</a><a id="L1462" href="#L1462">1462</a><a id="L1463" href="#L1463">1463</a><a id="L1464" href="#L1464">1464</a><a id="L1465" href="#L1465">1465</a><a id="L1466" href="#L1466">1466</a><a id="L1467" href="#L1467">1467</a><a id="L1468" href="#L1468">1468</a><a id="L1469" href="#L1469">1469</a><a id="L1470" href="#L1470">1470</a><a id="L1471" href="#L1471">1471</a><a id="L1472" href="#L1472">1472</a><a id="L1473" href="#L1473">1473</a><a id="L1474" href="#L1474">1474</a><a id="L1475" href="#L1475">1475</a><a id="L1476" href="#L1476">1476</a><a id="L1477" href="#L1477">1477</a><a id="L1478" href="#L1478">1478</a><a id="L1479" href="#L1479">1479</a><a id="L1480" href="#L1480">1480</a><a id="L1481" href="#L1481">1481</a><a id="L1482" href="#L1482">1482</a><a id="L1483" href="#L1483">1483</a><a id="L1484" href="#L1484">1484</a><a id="L1485" href="#L1485">1485</a><a id="L1486" href="#L1486">1486</a><a id="L1487" href="#L1487">1487</a><a id="L1488" href="#L1488">1488</a><a id="L1489" href="#L1489">1489</a><a id="L1490" href="#L1490">1490</a><a id="L1491" href="#L1491">1491</a><a id="L1492" href="#L1492">1492</a><a id="L1493" href="#L1493">1493</a><a id="L1494" href="#L1494">1494</a><a id="L1495" href="#L1495">1495</a><a id="L1496" href="#L1496">1496</a><a id="L1497" href="#L1497">1497</a><a id="L1498" href="#L1498">1498</a><a id="L1499" href="#L1499">1499</a><a id="L1500" href="#L1500">1500</a><a id="L1501" href="#L1501">1501</a><a id="L1502" href="#L1502">1502</a><a id="L1503" href="#L1503">1503</a><a id="L1504" href="#L1504">1504</a><a id="L1505" href="#L1505">1505</a><a id="L1506" href="#L1506">1506</a><a id="L1507" href="#L1507">1507</a><a id="L1508" href="#L1508">1508</a><a id="L1509" href="#L1509">1509</a><a id="L1510" href="#L1510">1510</a><a id="L1511" href="#L1511">1511</a><a id="L1512" href="#L1512">1512</a><a id="L1513" href="#L1513">1513</a><a id="L1514" href="#L1514">1514</a><a id="L1515" href="#L1515">1515</a><a id="L1516" href="#L1516">1516</a><a id="L1517" href="#L1517">1517</a><a id="L1518" href="#L1518">1518</a><a id="L1519" href="#L1519">1519</a><a id="L1520" href="#L1520">1520</a><a id="L1521" href="#L1521">1521</a><a id="L1522" href="#L1522">1522</a><a id="L1523" href="#L1523">1523</a><a id="L1524" href="#L1524">1524</a><a id="L1525" href="#L1525">1525</a><a id="L1526" href="#L1526">1526</a><a id="L1527" href="#L1527">1527</a><a id="L1528" href="#L1528">1528</a><a id="L1529" href="#L1529">1529</a><a id="L1530" href="#L1530">1530</a><a id="L1531" href="#L1531">1531</a><a id="L1532" href="#L1532">1532</a><a id="L1533" href="#L1533">1533</a><a id="L1534" href="#L1534">1534</a><a id="L1535" href="#L1535">1535</a><a id="L1536" href="#L1536">1536</a><a id="L1537" href="#L1537">1537</a><a id="L1538" href="#L1538">1538</a><a id="L1539" href="#L1539">1539</a><a id="L1540" href="#L1540">1540</a><a id="L1541" href="#L1541">1541</a><a id="L1542" href="#L1542">1542</a><a id="L1543" href="#L1543">1543</a><a id="L1544" href="#L1544">1544</a><a id="L1545" href="#L1545">1545</a><a id="L1546" href="#L1546">1546</a><a id="L1547" href="#L1547">1547</a><a id="L1548" href="#L1548">1548</a><a id="L1549" href="#L1549">1549</a><a id="L1550" href="#L1550">1550</a><a id="L1551" href="#L1551">1551</a><a id="L1552" href="#L1552">1552</a><a id="L1553" href="#L1553">1553</a><a id="L1554" href="#L1554">1554</a><a id="L1555" href="#L1555">1555</a><a id="L1556" href="#L1556">1556</a><a id="L1557" href="#L1557">1557</a><a id="L1558" href="#L1558">1558</a><a id="L1559" href="#L1559">1559</a><a id="L1560" href="#L1560">1560</a><a id="L1561" href="#L1561">1561</a><a id="L1562" href="#L1562">1562</a><a id="L1563" href="#L1563">1563</a><a id="L1564" href="#L1564">1564</a><a id="L1565" href="#L1565">1565</a><a id="L1566" href="#L1566">1566</a><a id="L1567" href="#L1567">1567</a><a id="L1568" href="#L1568">1568</a><a id="L1569" href="#L1569">1569</a><a id="L1570" href="#L1570">1570</a><a id="L1571" href="#L1571">1571</a><a id="L1572" href="#L1572">1572</a><a id="L1573" href="#L1573">1573</a><a id="L1574" href="#L1574">1574</a><a id="L1575" href="#L1575">1575</a><a id="L1576" href="#L1576">1576</a><a id="L1577" href="#L1577">1577</a><a id="L1578" href="#L1578">1578</a><a id="L1579" href="#L1579">1579</a><a id="L1580" href="#L1580">1580</a><a id="L1581" href="#L1581">1581</a><a id="L1582" href="#L1582">1582</a><a id="L1583" href="#L1583">1583</a><a id="L1584" href="#L1584">1584</a><a id="L1585" href="#L1585">1585</a><a id="L1586" href="#L1586">1586</a><a id="L1587" href="#L1587">1587</a><a id="L1588" href="#L1588">1588</a><a id="L1589" href="#L1589">1589</a><a id="L1590" href="#L1590">1590</a><a id="L1591" href="#L1591">1591</a><a id="L1592" href="#L1592">1592</a><a id="L1593" href="#L1593">1593</a><a id="L1594" href="#L1594">1594</a><a id="L1595" href="#L1595">1595</a><a id="L1596" href="#L1596">1596</a><a id="L1597" href="#L1597">1597</a><a id="L1598" href="#L1598">1598</a><a id="L1599" href="#L1599">1599</a><a id="L1600" href="#L1600">1600</a><a id="L1601" href="#L1601">1601</a><a id="L1602" href="#L1602">1602</a><a id="L1603" href="#L1603">1603</a><a id="L1604" href="#L1604">1604</a><a id="L1605" href="#L1605">1605</a><a id="L1606" href="#L1606">1606</a><a id="L1607" href="#L1607">1607</a><a id="L1608" href="#L1608">1608</a><a id="L1609" href="#L1609">1609</a><a id="L1610" href="#L1610">1610</a><a id="L1611" href="#L1611">1611</a><a id="L1612" href="#L1612">1612</a><a id="L1613" href="#L1613">1613</a><a id="L1614" href="#L1614">1614</a><a id="L1615" href="#L1615">1615</a><a id="L1616" href="#L1616">1616</a><a id="L1617" href="#L1617">1617</a><a id="L1618" href="#L1618">1618</a><a id="L1619" href="#L1619">1619</a><a id="L1620" href="#L1620">1620</a><a id="L1621" href="#L1621">1621</a><a id="L1622" href="#L1622">1622</a><a id="L1623" href="#L1623">1623</a><a id="L1624" href="#L1624">1624</a><a id="L1625" href="#L1625">1625</a><a id="L1626" href="#L1626">1626</a><a id="L1627" href="#L1627">1627</a><a id="L1628" href="#L1628">1628</a><a id="L1629" href="#L1629">1629</a><a id="L1630" href="#L1630">1630</a><a id="L1631" href="#L1631">1631</a><a id="L1632" href="#L1632">1632</a><a id="L1633" href="#L1633">1633</a><a id="L1634" href="#L1634">1634</a><a id="L1635" href="#L1635">1635</a><a id="L1636" href="#L1636">1636</a><a id="L1637" href="#L1637">1637</a><a id="L1638" href="#L1638">1638</a><a id="L1639" href="#L1639">1639</a><a id="L1640" href="#L1640">1640</a><a id="L1641" href="#L1641">1641</a><a id="L1642" href="#L1642">1642</a><a id="L1643" href="#L1643">1643</a><a id="L1644" href="#L1644">1644</a><a id="L1645" href="#L1645">1645</a><a id="L1646" href="#L1646">1646</a><a id="L1647" href="#L1647">1647</a><a id="L1648" href="#L1648">1648</a><a id="L1649" href="#L1649">1649</a><a id="L1650" href="#L1650">1650</a><a id="L1651" href="#L1651">1651</a><a id="L1652" href="#L1652">1652</a><a id="L1653" href="#L1653">1653</a><a id="L1654" href="#L1654">1654</a><a id="L1655" href="#L1655">1655</a><a id="L1656" href="#L1656">1656</a><a id="L1657" href="#L1657">1657</a><a id="L1658" href="#L1658">1658</a><a id="L1659" href="#L1659">1659</a><a id="L1660" href="#L1660">1660</a><a id="L1661" href="#L1661">1661</a><a id="L1662" href="#L1662">1662</a><a id="L1663" href="#L1663">1663</a><a id="L1664" href="#L1664">1664</a><a id="L1665" href="#L1665">1665</a><a id="L1666" href="#L1666">1666</a><a id="L1667" href="#L1667">1667</a><a id="L1668" href="#L1668">1668</a><a id="L1669" href="#L1669">1669</a><a id="L1670" href="#L1670">1670</a><a id="L1671" href="#L1671">1671</a><a id="L1672" href="#L1672">1672</a><a id="L1673" href="#L1673">1673</a><a id="L1674" href="#L1674">1674</a><a id="L1675" href="#L1675">1675</a><a id="L1676" href="#L1676">1676</a><a id="L1677" href="#L1677">1677</a><a id="L1678" href="#L1678">1678</a><a id="L1679" href="#L1679">1679</a><a id="L1680" href="#L1680">1680</a><a id="L1681" href="#L1681">1681</a><a id="L1682" href="#L1682">1682</a><a id="L1683" href="#L1683">1683</a><a id="L1684" href="#L1684">1684</a><a id="L1685" href="#L1685">1685</a><a id="L1686" href="#L1686">1686</a><a id="L1687" href="#L1687">1687</a><a id="L1688" href="#L1688">1688</a><a id="L1689" href="#L1689">1689</a><a id="L1690" href="#L1690">1690</a><a id="L1691" href="#L1691">1691</a><a id="L1692" href="#L1692">1692</a><a id="L1693" href="#L1693">1693</a><a id="L1694" href="#L1694">1694</a><a id="L1695" href="#L1695">1695</a><a id="L1696" href="#L1696">1696</a><a id="L1697" href="#L1697">1697</a><a id="L1698" href="#L1698">1698</a><a id="L1699" href="#L1699">1699</a><a id="L1700" href="#L1700">1700</a><a id="L1701" href="#L1701">1701</a><a id="L1702" href="#L1702">1702</a><a id="L1703" href="#L1703">1703</a><a id="L1704" href="#L1704">1704</a><a id="L1705" href="#L1705">1705</a><a id="L1706" href="#L1706">1706</a><a id="L1707" href="#L1707">1707</a><a id="L1708" href="#L1708">1708</a><a id="L1709" href="#L1709">1709</a><a id="L1710" href="#L1710">1710</a><a id="L1711" href="#L1711">1711</a><a id="L1712" href="#L1712">1712</a><a id="L1713" href="#L1713">1713</a><a id="L1714" href="#L1714">1714</a><a id="L1715" href="#L1715">1715</a><a id="L1716" href="#L1716">1716</a><a id="L1717" href="#L1717">1717</a><a id="L1718" href="#L1718">1718</a><a id="L1719" href="#L1719">1719</a><a id="L1720" href="#L1720">1720</a><a id="L1721" href="#L1721">1721</a><a id="L1722" href="#L1722">1722</a><a id="L1723" href="#L1723">1723</a><a id="L1724" href="#L1724">1724</a><a id="L1725" href="#L1725">1725</a><a id="L1726" href="#L1726">1726</a><a id="L1727" href="#L1727">1727</a><a id="L1728" href="#L1728">1728</a><a id="L1729" href="#L1729">1729</a><a id="L1730" href="#L1730">1730</a><a id="L1731" href="#L1731">1731</a><a id="L1732" href="#L1732">1732</a><a id="L1733" href="#L1733">1733</a><a id="L1734" href="#L1734">1734</a><a id="L1735" href="#L1735">1735</a><a id="L1736" href="#L1736">1736</a><a id="L1737" href="#L1737">1737</a><a id="L1738" href="#L1738">1738</a><a id="L1739" href="#L1739">1739</a><a id="L1740" href="#L1740">1740</a><a id="L1741" href="#L1741">1741</a><a id="L1742" href="#L1742">1742</a><a id="L1743" href="#L1743">1743</a><a id="L1744" href="#L1744">1744</a><a id="L1745" href="#L1745">1745</a><a id="L1746" href="#L1746">1746</a><a id="L1747" href="#L1747">1747</a><a id="L1748" href="#L1748">1748</a><a id="L1749" href="#L1749">1749</a><a id="L1750" href="#L1750">1750</a><a id="L1751" href="#L1751">1751</a><a id="L1752" href="#L1752">1752</a><a id="L1753" href="#L1753">1753</a><a id="L1754" href="#L1754">1754</a><a id="L1755" href="#L1755">1755</a><a id="L1756" href="#L1756">1756</a><a id="L1757" href="#L1757">1757</a><a id="L1758" href="#L1758">1758</a><a id="L1759" href="#L1759">1759</a><a id="L1760" href="#L1760">1760</a><a id="L1761" href="#L1761">1761</a><a id="L1762" href="#L1762">1762</a><a id="L1763" href="#L1763">1763</a><a id="L1764" href="#L1764">1764</a><a id="L1765" href="#L1765">1765</a><a id="L1766" href="#L1766">1766</a><a id="L1767" href="#L1767">1767</a><a id="L1768" href="#L1768">1768</a><a id="L1769" href="#L1769">1769</a><a id="L1770" href="#L1770">1770</a><a id="L1771" href="#L1771">1771</a><a id="L1772" href="#L1772">1772</a><a id="L1773" href="#L1773">1773</a><a id="L1774" href="#L1774">1774</a><a id="L1775" href="#L1775">1775</a><a id="L1776" href="#L1776">1776</a><a id="L1777" href="#L1777">1777</a><a id="L1778" href="#L1778">1778</a><a id="L1779" href="#L1779">1779</a><a id="L1780" href="#L1780">1780</a><a id="L1781" href="#L1781">1781</a><a id="L1782" href="#L1782">1782</a><a id="L1783" href="#L1783">1783</a><a id="L1784" href="#L1784">1784</a><a id="L1785" href="#L1785">1785</a><a id="L1786" href="#L1786">1786</a><a id="L1787" href="#L1787">1787</a><a id="L1788" href="#L1788">1788</a><a id="L1789" href="#L1789">1789</a><a id="L1790" href="#L1790">1790</a><a id="L1791" href="#L1791">1791</a><a id="L1792" href="#L1792">1792</a><a id="L1793" href="#L1793">1793</a><a id="L1794" href="#L1794">1794</a><a id="L1795" href="#L1795">1795</a><a id="L1796" href="#L1796">1796</a><a id="L1797" href="#L1797">1797</a><a id="L1798" href="#L1798">1798</a><a id="L1799" href="#L1799">1799</a><a id="L1800" href="#L1800">1800</a><a id="L1801" href="#L1801">1801</a><a id="L1802" href="#L1802">1802</a><a id="L1803" href="#L1803">1803</a><a id="L1804" href="#L1804">1804</a><a id="L1805" href="#L1805">1805</a><a id="L1806" href="#L1806">1806</a><a id="L1807" href="#L1807">1807</a><a id="L1808" href="#L1808">1808</a><a id="L1809" href="#L1809">1809</a><a id="L1810" href="#L1810">1810</a><a id="L1811" href="#L1811">1811</a><a id="L1812" href="#L1812">1812</a><a id="L1813" href="#L1813">1813</a><a id="L1814" href="#L1814">1814</a><a id="L1815" href="#L1815">1815</a><a id="L1816" href="#L1816">1816</a><a id="L1817" href="#L1817">1817</a><a id="L1818" href="#L1818">1818</a><a id="L1819" href="#L1819">1819</a><a id="L1820" href="#L1820">1820</a><a id="L1821" href="#L1821">1821</a><a id="L1822" href="#L1822">1822</a><a id="L1823" href="#L1823">1823</a><a id="L1824" href="#L1824">1824</a><a id="L1825" href="#L1825">1825</a><a id="L1826" href="#L1826">1826</a><a id="L1827" href="#L1827">1827</a><a id="L1828" href="#L1828">1828</a><a id="L1829" href="#L1829">1829</a><a id="L1830" href="#L1830">1830</a><a id="L1831" href="#L1831">1831</a><a id="L1832" href="#L1832">1832</a><a id="L1833" href="#L1833">1833</a><a id="L1834" href="#L1834">1834</a><a id="L1835" href="#L1835">1835</a><a id="L1836" href="#L1836">1836</a><a id="L1837" href="#L1837">1837</a><a id="L1838" href="#L1838">1838</a><a id="L1839" href="#L1839">1839</a><a id="L1840" href="#L1840">1840</a><a id="L1841" href="#L1841">1841</a><a id="L1842" href="#L1842">1842</a><a id="L1843" href="#L1843">1843</a><a id="L1844" href="#L1844">1844</a><a id="L1845" href="#L1845">1845</a><a id="L1846" href="#L1846">1846</a><a id="L1847" href="#L1847">1847</a><a id="L1848" href="#L1848">1848</a><a id="L1849" href="#L1849">1849</a><a id="L1850" href="#L1850">1850</a><a id="L1851" href="#L1851">1851</a><a id="L1852" href="#L1852">1852</a><a id="L1853" href="#L1853">1853</a><a id="L1854" href="#L1854">1854</a><a id="L1855" href="#L1855">1855</a><a id="L1856" href="#L1856">1856</a><a id="L1857" href="#L1857">1857</a><a id="L1858" href="#L1858">1858</a><a id="L1859" href="#L1859">1859</a><a id="L1860" href="#L1860">1860</a><a id="L1861" href="#L1861">1861</a><a id="L1862" href="#L1862">1862</a><a id="L1863" href="#L1863">1863</a><a id="L1864" href="#L1864">1864</a><a id="L1865" href="#L1865">1865</a><a id="L1866" href="#L1866">1866</a><a id="L1867" href="#L1867">1867</a><a id="L1868" href="#L1868">1868</a><a id="L1869" href="#L1869">1869</a><a id="L1870" href="#L1870">1870</a><a id="L1871" href="#L1871">1871</a><a id="L1872" href="#L1872">1872</a><a id="L1873" href="#L1873">1873</a><a id="L1874" href="#L1874">1874</a><a id="L1875" href="#L1875">1875</a><a id="L1876" href="#L1876">1876</a><a id="L1877" href="#L1877">1877</a><a id="L1878" href="#L1878">1878</a><a id="L1879" href="#L1879">1879</a><a id="L1880" href="#L1880">1880</a><a id="L1881" href="#L1881">1881</a><a id="L1882" href="#L1882">1882</a><a id="L1883" href="#L1883">1883</a><a id="L1884" href="#L1884">1884</a><a id="L1885" href="#L1885">1885</a><a id="L1886" href="#L1886">1886</a><a id="L1887" href="#L1887">1887</a><a id="L1888" href="#L1888">1888</a><a id="L1889" href="#L1889">1889</a><a id="L1890" href="#L1890">1890</a><a id="L1891" href="#L1891">1891</a><a id="L1892" href="#L1892">1892</a><a id="L1893" href="#L1893">1893</a><a id="L1894" href="#L1894">1894</a><a id="L1895" href="#L1895">1895</a><a id="L1896" href="#L1896">1896</a><a id="L1897" href="#L1897">1897</a><a id="L1898" href="#L1898">1898</a><a id="L1899" href="#L1899">1899</a><a id="L1900" href="#L1900">1900</a><a id="L1901" href="#L1901">1901</a><a id="L1902" href="#L1902">1902</a><a id="L1903" href="#L1903">1903</a><a id="L1904" href="#L1904">1904</a><a id="L1905" href="#L1905">1905</a><a id="L1906" href="#L1906">1906</a><a id="L1907" href="#L1907">1907</a><a id="L1908" href="#L1908">1908</a><a id="L1909" href="#L1909">1909</a><a id="L1910" href="#L1910">1910</a><a id="L1911" href="#L1911">1911</a><a id="L1912" href="#L1912">1912</a><a id="L1913" href="#L1913">1913</a><a id="L1914" href="#L1914">1914</a><a id="L1915" href="#L1915">1915</a><a id="L1916" href="#L1916">1916</a><a id="L1917" href="#L1917">1917</a><a id="L1918" href="#L1918">1918</a><a id="L1919" href="#L1919">1919</a><a id="L1920" href="#L1920">1920</a><a id="L1921" href="#L1921">1921</a><a id="L1922" href="#L1922">1922</a><a id="L1923" href="#L1923">1923</a><a id="L1924" href="#L1924">1924</a><a id="L1925" href="#L1925">1925</a><a id="L1926" href="#L1926">1926</a><a id="L1927" href="#L1927">1927</a><a id="L1928" href="#L1928">1928</a><a id="L1929" href="#L1929">1929</a><a id="L1930" href="#L1930">1930</a><a id="L1931" href="#L1931">1931</a><a id="L1932" href="#L1932">1932</a><a id="L1933" href="#L1933">1933</a><a id="L1934" href="#L1934">1934</a><a id="L1935" href="#L1935">1935</a><a id="L1936" href="#L1936">1936</a><a id="L1937" href="#L1937">1937</a><a id="L1938" href="#L1938">1938</a><a id="L1939" href="#L1939">1939</a><a id="L1940" href="#L1940">1940</a><a id="L1941" href="#L1941">1941</a><a id="L1942" href="#L1942">1942</a><a id="L1943" href="#L1943">1943</a><a id="L1944" href="#L1944">1944</a><a id="L1945" href="#L1945">1945</a><a id="L1946" href="#L1946">1946</a><a id="L1947" href="#L1947">1947</a><a id="L1948" href="#L1948">1948</a><a id="L1949" href="#L1949">1949</a><a id="L1950" href="#L1950">1950</a><a id="L1951" href="#L1951">1951</a><a id="L1952" href="#L1952">1952</a><a id="L1953" href="#L1953">1953</a><a id="L1954" href="#L1954">1954</a><a id="L1955" href="#L1955">1955</a><a id="L1956" href="#L1956">1956</a><a id="L1957" href="#L1957">1957</a><a id="L1958" href="#L1958">1958</a><a id="L1959" href="#L1959">1959</a><a id="L1960" href="#L1960">1960</a><a id="L1961" href="#L1961">1961</a><a id="L1962" href="#L1962">1962</a><a id="L1963" href="#L1963">1963</a><a id="L1964" href="#L1964">1964</a><a id="L1965" href="#L1965">1965</a><a id="L1966" href="#L1966">1966</a><a id="L1967" href="#L1967">1967</a><a id="L1968" href="#L1968">1968</a><a id="L1969" href="#L1969">1969</a><a id="L1970" href="#L1970">1970</a><a id="L1971" href="#L1971">1971</a><a id="L1972" href="#L1972">1972</a><a id="L1973" href="#L1973">1973</a><a id="L1974" href="#L1974">1974</a><a id="L1975" href="#L1975">1975</a><a id="L1976" href="#L1976">1976</a><a id="L1977" href="#L1977">1977</a><a id="L1978" href="#L1978">1978</a><a id="L1979" href="#L1979">1979</a><a id="L1980" href="#L1980">1980</a><a id="L1981" href="#L1981">1981</a><a id="L1982" href="#L1982">1982</a><a id="L1983" href="#L1983">1983</a><a id="L1984" href="#L1984">1984</a><a id="L1985" href="#L1985">1985</a><a id="L1986" href="#L1986">1986</a><a id="L1987" href="#L1987">1987</a><a id="L1988" href="#L1988">1988</a><a id="L1989" href="#L1989">1989</a><a id="L1990" href="#L1990">1990</a><a id="L1991" href="#L1991">1991</a><a id="L1992" href="#L1992">1992</a><a id="L1993" href="#L1993">1993</a><a id="L1994" href="#L1994">1994</a><a id="L1995" href="#L1995">1995</a><a id="L1996" href="#L1996">1996</a><a id="L1997" href="#L1997">1997</a><a id="L1998" href="#L1998">1998</a><a id="L1999" href="#L1999">1999</a><a id="L2000" href="#L2000">2000</a><a id="L2001" href="#L2001">2001</a><a id="L2002" href="#L2002">2002</a><a id="L2003" href="#L2003">2003</a><a id="L2004" href="#L2004">2004</a><a id="L2005" href="#L2005">2005</a><a id="L2006" href="#L2006">2006</a><a id="L2007" href="#L2007">2007</a><a id="L2008" href="#L2008">2008</a><a id="L2009" href="#L2009">2009</a><a id="L2010" href="#L2010">2010</a><a id="L2011" href="#L2011">2011</a><a id="L2012" href="#L2012">2012</a><a id="L2013" href="#L2013">2013</a><a id="L2014" href="#L2014">2014</a><a id="L2015" href="#L2015">2015</a><a id="L2016" href="#L2016">2016</a><a id="L2017" href="#L2017">2017</a><a id="L2018" href="#L2018">2018</a><a id="L2019" href="#L2019">2019</a><a id="L2020" href="#L2020">2020</a><a id="L2021" href="#L2021">2021</a><a id="L2022" href="#L2022">2022</a><a id="L2023" href="#L2023">2023</a><a id="L2024" href="#L2024">2024</a><a id="L2025" href="#L2025">2025</a><a id="L2026" href="#L2026">2026</a><a id="L2027" href="#L2027">2027</a><a id="L2028" href="#L2028">2028</a><a id="L2029" href="#L2029">2029</a><a id="L2030" href="#L2030">2030</a><a id="L2031" href="#L2031">2031</a><a id="L2032" href="#L2032">2032</a><a id="L2033" href="#L2033">2033</a><a id="L2034" href="#L2034">2034</a><a id="L2035" href="#L2035">2035</a><a id="L2036" href="#L2036">2036</a><a id="L2037" href="#L2037">2037</a><a id="L2038" href="#L2038">2038</a><a id="L2039" href="#L2039">2039</a><a id="L2040" href="#L2040">2040</a><a id="L2041" href="#L2041">2041</a><a id="L2042" href="#L2042">2042</a><a id="L2043" href="#L2043">2043</a><a id="L2044" href="#L2044">2044</a><a id="L2045" href="#L2045">2045</a><a id="L2046" href="#L2046">2046</a><a id="L2047" href="#L2047">2047</a><a id="L2048" href="#L2048">2048</a><a id="L2049" href="#L2049">2049</a><a id="L2050" href="#L2050">2050</a><a id="L2051" href="#L2051">2051</a><a id="L2052" href="#L2052">2052</a><a id="L2053" href="#L2053">2053</a><a id="L2054" href="#L2054">2054</a><a id="L2055" href="#L2055">2055</a><a id="L2056" href="#L2056">2056</a><a id="L2057" href="#L2057">2057</a><a id="L2058" href="#L2058">2058</a><a id="L2059" href="#L2059">2059</a><a id="L2060" href="#L2060">2060</a><a id="L2061" href="#L2061">2061</a><a id="L2062" href="#L2062">2062</a><a id="L2063" href="#L2063">2063</a><a id="L2064" href="#L2064">2064</a><a id="L2065" href="#L2065">2065</a><a id="L2066" href="#L2066">2066</a><a id="L2067" href="#L2067">2067</a><a id="L2068" href="#L2068">2068</a><a id="L2069" href="#L2069">2069</a><a id="L2070" href="#L2070">2070</a><a id="L2071" href="#L2071">2071</a><a id="L2072" href="#L2072">2072</a><a id="L2073" href="#L2073">2073</a><a id="L2074" href="#L2074">2074</a><a id="L2075" href="#L2075">2075</a><a id="L2076" href="#L2076">2076</a><a id="L2077" href="#L2077">2077</a><a id="L2078" href="#L2078">2078</a><a id="L2079" href="#L2079">2079</a><a id="L2080" href="#L2080">2080</a><a id="L2081" href="#L2081">2081</a><a id="L2082" href="#L2082">2082</a><a id="L2083" href="#L2083">2083</a><a id="L2084" href="#L2084">2084</a><a id="L2085" href="#L2085">2085</a><a id="L2086" href="#L2086">2086</a><a id="L2087" href="#L2087">2087</a><a id="L2088" href="#L2088">2088</a><a id="L2089" href="#L2089">2089</a><a id="L2090" href="#L2090">2090</a><a id="L2091" href="#L2091">2091</a><a id="L2092" href="#L2092">2092</a><a id="L2093" href="#L2093">2093</a><a id="L2094" href="#L2094">2094</a><a id="L2095" href="#L2095">2095</a><a id="L2096" href="#L2096">2096</a><a id="L2097" href="#L2097">2097</a><a id="L2098" href="#L2098">2098</a><a id="L2099" href="#L2099">2099</a><a id="L2100" href="#L2100">2100</a><a id="L2101" href="#L2101">2101</a><a id="L2102" href="#L2102">2102</a><a id="L2103" href="#L2103">2103</a><a id="L2104" href="#L2104">2104</a><a id="L2105" href="#L2105">2105</a><a id="L2106" href="#L2106">2106</a><a id="L2107" href="#L2107">2107</a><a id="L2108" href="#L2108">2108</a><a id="L2109" href="#L2109">2109</a><a id="L2110" href="#L2110">2110</a><a id="L2111" href="#L2111">2111</a><a id="L2112" href="#L2112">2112</a><a id="L2113" href="#L2113">2113</a><a id="L2114" href="#L2114">2114</a><a id="L2115" href="#L2115">2115</a><a id="L2116" href="#L2116">2116</a><a id="L2117" href="#L2117">2117</a><a id="L2118" href="#L2118">2118</a><a id="L2119" href="#L2119">2119</a><a id="L2120" href="#L2120">2120</a><a id="L2121" href="#L2121">2121</a><a id="L2122" href="#L2122">2122</a><a id="L2123" href="#L2123">2123</a><a id="L2124" href="#L2124">2124</a><a id="L2125" href="#L2125">2125</a><a id="L2126" href="#L2126">2126</a><a id="L2127" href="#L2127">2127</a><a id="L2128" href="#L2128">2128</a><a id="L2129" href="#L2129">2129</a><a id="L2130" href="#L2130">2130</a><a id="L2131" href="#L2131">2131</a><a id="L2132" href="#L2132">2132</a><a id="L2133" href="#L2133">2133</a><a id="L2134" href="#L2134">2134</a><a id="L2135" href="#L2135">2135</a><a id="L2136" href="#L2136">2136</a><a id="L2137" href="#L2137">2137</a><a id="L2138" href="#L2138">2138</a><a id="L2139" href="#L2139">2139</a><a id="L2140" href="#L2140">2140</a><a id="L2141" href="#L2141">2141</a><a id="L2142" href="#L2142">2142</a><a id="L2143" href="#L2143">2143</a><a id="L2144" href="#L2144">2144</a><a id="L2145" href="#L2145">2145</a><a id="L2146" href="#L2146">2146</a><a id="L2147" href="#L2147">2147</a><a id="L2148" href="#L2148">2148</a><a id="L2149" href="#L2149">2149</a><a id="L2150" href="#L2150">2150</a><a id="L2151" href="#L2151">2151</a><a id="L2152" href="#L2152">2152</a><a id="L2153" href="#L2153">2153</a><a id="L2154" href="#L2154">2154</a><a id="L2155" href="#L2155">2155</a><a id="L2156" href="#L2156">2156</a><a id="L2157" href="#L2157">2157</a><a id="L2158" href="#L2158">2158</a><a id="L2159" href="#L2159">2159</a><a id="L2160" href="#L2160">2160</a><a id="L2161" href="#L2161">2161</a><a id="L2162" href="#L2162">2162</a><a id="L2163" href="#L2163">2163</a><a id="L2164" href="#L2164">2164</a><a id="L2165" href="#L2165">2165</a><a id="L2166" href="#L2166">2166</a><a id="L2167" href="#L2167">2167</a><a id="L2168" href="#L2168">2168</a><a id="L2169" href="#L2169">2169</a><a id="L2170" href="#L2170">2170</a><a id="L2171" href="#L2171">2171</a><a id="L2172" href="#L2172">2172</a><a id="L2173" href="#L2173">2173</a><a id="L2174" href="#L2174">2174</a><a id="L2175" href="#L2175">2175</a><a id="L2176" href="#L2176">2176</a><a id="L2177" href="#L2177">2177</a><a id="L2178" href="#L2178">2178</a><a id="L2179" href="#L2179">2179</a><a id="L2180" href="#L2180">2180</a><a id="L2181" href="#L2181">2181</a><a id="L2182" href="#L2182">2182</a><a id="L2183" href="#L2183">2183</a><a id="L2184" href="#L2184">2184</a><a id="L2185" href="#L2185">2185</a><a id="L2186" href="#L2186">2186</a><a id="L2187" href="#L2187">2187</a><a id="L2188" href="#L2188">2188</a><a id="L2189" href="#L2189">2189</a><a id="L2190" href="#L2190">2190</a><a id="L2191" href="#L2191">2191</a><a id="L2192" href="#L2192">2192</a><a id="L2193" href="#L2193">2193</a><a id="L2194" href="#L2194">2194</a><a id="L2195" href="#L2195">2195</a><a id="L2196" href="#L2196">2196</a><a id="L2197" href="#L2197">2197</a><a id="L2198" href="#L2198">2198</a><a id="L2199" href="#L2199">2199</a><a id="L2200" href="#L2200">2200</a><a id="L2201" href="#L2201">2201</a><a id="L2202" href="#L2202">2202</a><a id="L2203" href="#L2203">2203</a><a id="L2204" href="#L2204">2204</a><a id="L2205" href="#L2205">2205</a><a id="L2206" href="#L2206">2206</a><a id="L2207" href="#L2207">2207</a><a id="L2208" href="#L2208">2208</a><a id="L2209" href="#L2209">2209</a><a id="L2210" href="#L2210">2210</a><a id="L2211" href="#L2211">2211</a><a id="L2212" href="#L2212">2212</a><a id="L2213" href="#L2213">2213</a><a id="L2214" href="#L2214">2214</a><a id="L2215" href="#L2215">2215</a><a id="L2216" href="#L2216">2216</a><a id="L2217" href="#L2217">2217</a><a id="L2218" href="#L2218">2218</a><a id="L2219" href="#L2219">2219</a><a id="L2220" href="#L2220">2220</a><a id="L2221" href="#L2221">2221</a><a id="L2222" href="#L2222">2222</a><a id="L2223" href="#L2223">2223</a><a id="L2224" href="#L2224">2224</a><a id="L2225" href="#L2225">2225</a><a id="L2226" href="#L2226">2226</a><a id="L2227" href="#L2227">2227</a><a id="L2228" href="#L2228">2228</a><a id="L2229" href="#L2229">2229</a><a id="L2230" href="#L2230">2230</a><a id="L2231" href="#L2231">2231</a><a id="L2232" href="#L2232">2232</a><a id="L2233" href="#L2233">2233</a><a id="L2234" href="#L2234">2234</a><a id="L2235" href="#L2235">2235</a><a id="L2236" href="#L2236">2236</a><a id="L2237" href="#L2237">2237</a><a id="L2238" href="#L2238">2238</a><a id="L2239" href="#L2239">2239</a><a id="L2240" href="#L2240">2240</a><a id="L2241" href="#L2241">2241</a><a id="L2242" href="#L2242">2242</a><a id="L2243" href="#L2243">2243</a><a id="L2244" href="#L2244">2244</a><a id="L2245" href="#L2245">2245</a><a id="L2246" href="#L2246">2246</a><a id="L2247" href="#L2247">2247</a><a id="L2248" href="#L2248">2248</a><a id="L2249" href="#L2249">2249</a><a id="L2250" href="#L2250">2250</a><a id="L2251" href="#L2251">2251</a><a id="L2252" href="#L2252">2252</a><a id="L2253" href="#L2253">2253</a><a id="L2254" href="#L2254">2254</a><a id="L2255" href="#L2255">2255</a><a id="L2256" href="#L2256">2256</a><a id="L2257" href="#L2257">2257</a><a id="L2258" href="#L2258">2258</a><a id="L2259" href="#L2259">2259</a><a id="L2260" href="#L2260">2260</a><a id="L2261" href="#L2261">2261</a><a id="L2262" href="#L2262">2262</a><a id="L2263" href="#L2263">2263</a><a id="L2264" href="#L2264">2264</a><a id="L2265" href="#L2265">2265</a><a id="L2266" href="#L2266">2266</a><a id="L2267" href="#L2267">2267</a><a id="L2268" href="#L2268">2268</a><a id="L2269" href="#L2269">2269</a><a id="L2270" href="#L2270">2270</a><a id="L2271" href="#L2271">2271</a><a id="L2272" href="#L2272">2272</a><a id="L2273" href="#L2273">2273</a><a id="L2274" href="#L2274">2274</a><a id="L2275" href="#L2275">2275</a><a id="L2276" href="#L2276">2276</a><a id="L2277" href="#L2277">2277</a><a id="L2278" href="#L2278">2278</a><a id="L2279" href="#L2279">2279</a><a id="L2280" href="#L2280">2280</a><a id="L2281" href="#L2281">2281</a><a id="L2282" href="#L2282">2282</a><a id="L2283" href="#L2283">2283</a><a id="L2284" href="#L2284">2284</a><a id="L2285" href="#L2285">2285</a><a id="L2286" href="#L2286">2286</a><a id="L2287" href="#L2287">2287</a><a id="L2288" href="#L2288">2288</a><a id="L2289" href="#L2289">2289</a><a id="L2290" href="#L2290">2290</a><a id="L2291" href="#L2291">2291</a><a id="L2292" href="#L2292">2292</a><a id="L2293" href="#L2293">2293</a><a id="L2294" href="#L2294">2294</a><a id="L2295" href="#L2295">2295</a><a id="L2296" href="#L2296">2296</a><a id="L2297" href="#L2297">2297</a><a id="L2298" href="#L2298">2298</a><a id="L2299" href="#L2299">2299</a><a id="L2300" href="#L2300">2300</a><a id="L2301" href="#L2301">2301</a><a id="L2302" href="#L2302">2302</a><a id="L2303" href="#L2303">2303</a><a id="L2304" href="#L2304">2304</a><a id="L2305" href="#L2305">2305</a><a id="L2306" href="#L2306">2306</a><a id="L2307" href="#L2307">2307</a><a id="L2308" href="#L2308">2308</a><a id="L2309" href="#L2309">2309</a><a id="L2310" href="#L2310">2310</a><a id="L2311" href="#L2311">2311</a><a id="L2312" href="#L2312">2312</a><a id="L2313" href="#L2313">2313</a><a id="L2314" href="#L2314">2314</a><a id="L2315" href="#L2315">2315</a><a id="L2316" href="#L2316">2316</a><a id="L2317" href="#L2317">2317</a><a id="L2318" href="#L2318">2318</a><a id="L2319" href="#L2319">2319</a><a id="L2320" href="#L2320">2320</a><a id="L2321" href="#L2321">2321</a><a id="L2322" href="#L2322">2322</a><a id="L2323" href="#L2323">2323</a><a id="L2324" href="#L2324">2324</a><a id="L2325" href="#L2325">2325</a><a id="L2326" href="#L2326">2326</a><a id="L2327" href="#L2327">2327</a><a id="L2328" href="#L2328">2328</a><a id="L2329" href="#L2329">2329</a><a id="L2330" href="#L2330">2330</a><a id="L2331" href="#L2331">2331</a><a id="L2332" href="#L2332">2332</a><a id="L2333" href="#L2333">2333</a><a id="L2334" href="#L2334">2334</a><a id="L2335" href="#L2335">2335</a><a id="L2336" href="#L2336">2336</a><a id="L2337" href="#L2337">2337</a><a id="L2338" href="#L2338">2338</a><a id="L2339" href="#L2339">2339</a><a id="L2340" href="#L2340">2340</a><a id="L2341" href="#L2341">2341</a><a id="L2342" href="#L2342">2342</a><a id="L2343" href="#L2343">2343</a><a id="L2344" href="#L2344">2344</a><a id="L2345" href="#L2345">2345</a><a id="L2346" href="#L2346">2346</a><a id="L2347" href="#L2347">2347</a><a id="L2348" href="#L2348">2348</a><a id="L2349" href="#L2349">2349</a><a id="L2350" href="#L2350">2350</a><a id="L2351" href="#L2351">2351</a><a id="L2352" href="#L2352">2352</a><a id="L2353" href="#L2353">2353</a><a id="L2354" href="#L2354">2354</a><a id="L2355" href="#L2355">2355</a><a id="L2356" href="#L2356">2356</a><a id="L2357" href="#L2357">2357</a><a id="L2358" href="#L2358">2358</a><a id="L2359" href="#L2359">2359</a><a id="L2360" href="#L2360">2360</a><a id="L2361" href="#L2361">2361</a><a id="L2362" href="#L2362">2362</a><a id="L2363" href="#L2363">2363</a><a id="L2364" href="#L2364">2364</a><a id="L2365" href="#L2365">2365</a><a id="L2366" href="#L2366">2366</a><a id="L2367" href="#L2367">2367</a><a id="L2368" href="#L2368">2368</a><a id="L2369" href="#L2369">2369</a><a id="L2370" href="#L2370">2370</a><a id="L2371" href="#L2371">2371</a><a id="L2372" href="#L2372">2372</a><a id="L2373" href="#L2373">2373</a><a id="L2374" href="#L2374">2374</a><a id="L2375" href="#L2375">2375</a><a id="L2376" href="#L2376">2376</a><a id="L2377" href="#L2377">2377</a><a id="L2378" href="#L2378">2378</a><a id="L2379" href="#L2379">2379</a><a id="L2380" href="#L2380">2380</a><a id="L2381" href="#L2381">2381</a><a id="L2382" href="#L2382">2382</a><a id="L2383" href="#L2383">2383</a><a id="L2384" href="#L2384">2384</a><a id="L2385" href="#L2385">2385</a><a id="L2386" href="#L2386">2386</a><a id="L2387" href="#L2387">2387</a><a id="L2388" href="#L2388">2388</a><a id="L2389" href="#L2389">2389</a><a id="L2390" href="#L2390">2390</a><a id="L2391" href="#L2391">2391</a><a id="L2392" href="#L2392">2392</a><a id="L2393" href="#L2393">2393</a><a id="L2394" href="#L2394">2394</a><a id="L2395" href="#L2395">2395</a><a id="L2396" href="#L2396">2396</a><a id="L2397" href="#L2397">2397</a><a id="L2398" href="#L2398">2398</a><a id="L2399" href="#L2399">2399</a><a id="L2400" href="#L2400">2400</a><a id="L2401" href="#L2401">2401</a><a id="L2402" href="#L2402">2402</a><a id="L2403" href="#L2403">2403</a><a id="L2404" href="#L2404">2404</a><a id="L2405" href="#L2405">2405</a><a id="L2406" href="#L2406">2406</a><a id="L2407" href="#L2407">2407</a><a id="L2408" href="#L2408">2408</a><a id="L2409" href="#L2409">2409</a><a id="L2410" href="#L2410">2410</a><a id="L2411" href="#L2411">2411</a><a id="L2412" href="#L2412">2412</a><a id="L2413" href="#L2413">2413</a><a id="L2414" href="#L2414">2414</a><a id="L2415" href="#L2415">2415</a><a id="L2416" href="#L2416">2416</a><a id="L2417" href="#L2417">2417</a><a id="L2418" href="#L2418">2418</a><a id="L2419" href="#L2419">2419</a><a id="L2420" href="#L2420">2420</a><a id="L2421" href="#L2421">2421</a><a id="L2422" href="#L2422">2422</a><a id="L2423" href="#L2423">2423</a><a id="L2424" href="#L2424">2424</a><a id="L2425" href="#L2425">2425</a><a id="L2426" href="#L2426">2426</a><a id="L2427" href="#L2427">2427</a><a id="L2428" href="#L2428">2428</a><a id="L2429" href="#L2429">2429</a><a id="L2430" href="#L2430">2430</a><a id="L2431" href="#L2431">2431</a><a id="L2432" href="#L2432">2432</a><a id="L2433" href="#L2433">2433</a><a id="L2434" href="#L2434">2434</a><a id="L2435" href="#L2435">2435</a><a id="L2436" href="#L2436">2436</a><a id="L2437" href="#L2437">2437</a><a id="L2438" href="#L2438">2438</a><a id="L2439" href="#L2439">2439</a><a id="L2440" href="#L2440">2440</a><a id="L2441" href="#L2441">2441</a><a id="L2442" href="#L2442">2442</a><a id="L2443" href="#L2443">2443</a><a id="L2444" href="#L2444">2444</a><a id="L2445" href="#L2445">2445</a><a id="L2446" href="#L2446">2446</a><a id="L2447" href="#L2447">2447</a><a id="L2448" href="#L2448">2448</a><a id="L2449" href="#L2449">2449</a><a id="L2450" href="#L2450">2450</a><a id="L2451" href="#L2451">2451</a><a id="L2452" href="#L2452">2452</a><a id="L2453" href="#L2453">2453</a><a id="L2454" href="#L2454">2454</a><a id="L2455" href="#L2455">2455</a><a id="L2456" href="#L2456">2456</a><a id="L2457" href="#L2457">2457</a><a id="L2458" href="#L2458">2458</a><a id="L2459" href="#L2459">2459</a><a id="L2460" href="#L2460">2460</a><a id="L2461" href="#L2461">2461</a><a id="L2462" href="#L2462">2462</a><a id="L2463" href="#L2463">2463</a><a id="L2464" href="#L2464">2464</a><a id="L2465" href="#L2465">2465</a><a id="L2466" href="#L2466">2466</a><a id="L2467" href="#L2467">2467</a><a id="L2468" href="#L2468">2468</a><a id="L2469" href="#L2469">2469</a><a id="L2470" href="#L2470">2470</a><a id="L2471" href="#L2471">2471</a><a id="L2472" href="#L2472">2472</a><a id="L2473" href="#L2473">2473</a><a id="L2474" href="#L2474">2474</a><a id="L2475" href="#L2475">2475</a><a id="L2476" href="#L2476">2476</a><a id="L2477" href="#L2477">2477</a><a id="L2478" href="#L2478">2478</a><a id="L2479" href="#L2479">2479</a><a id="L2480" href="#L2480">2480</a><a id="L2481" href="#L2481">2481</a><a id="L2482" href="#L2482">2482</a><a id="L2483" href="#L2483">2483</a><a id="L2484" href="#L2484">2484</a><a id="L2485" href="#L2485">2485</a><a id="L2486" href="#L2486">2486</a><a id="L2487" href="#L2487">2487</a><a id="L2488" href="#L2488">2488</a><a id="L2489" href="#L2489">2489</a><a id="L2490" href="#L2490">2490</a><a id="L2491" href="#L2491">2491</a><a id="L2492" href="#L2492">2492</a><a id="L2493" href="#L2493">2493</a><a id="L2494" href="#L2494">2494</a><a id="L2495" href="#L2495">2495</a><a id="L2496" href="#L2496">2496</a><a id="L2497" href="#L2497">2497</a><a id="L2498" href="#L2498">2498</a><a id="L2499" href="#L2499">2499</a><a id="L2500" href="#L2500">2500</a><a id="L2501" href="#L2501">2501</a><a id="L2502" href="#L2502">2502</a><a id="L2503" href="#L2503">2503</a><a id="L2504" href="#L2504">2504</a><a id="L2505" href="#L2505">2505</a><a id="L2506" href="#L2506">2506</a><a id="L2507" href="#L2507">2507</a><a id="L2508" href="#L2508">2508</a><a id="L2509" href="#L2509">2509</a><a id="L2510" href="#L2510">2510</a><a id="L2511" href="#L2511">2511</a><a id="L2512" href="#L2512">2512</a><a id="L2513" href="#L2513">2513</a><a id="L2514" href="#L2514">2514</a><a id="L2515" href="#L2515">2515</a><a id="L2516" href="#L2516">2516</a><a id="L2517" href="#L2517">2517</a><a id="L2518" href="#L2518">2518</a><a id="L2519" href="#L2519">2519</a><a id="L2520" href="#L2520">2520</a><a id="L2521" href="#L2521">2521</a><a id="L2522" href="#L2522">2522</a><a id="L2523" href="#L2523">2523</a><a id="L2524" href="#L2524">2524</a><a id="L2525" href="#L2525">2525</a><a id="L2526" href="#L2526">2526</a><a id="L2527" href="#L2527">2527</a><a id="L2528" href="#L2528">2528</a><a id="L2529" href="#L2529">2529</a><a id="L2530" href="#L2530">2530</a><a id="L2531" href="#L2531">2531</a><a id="L2532" href="#L2532">2532</a><a id="L2533" href="#L2533">2533</a><a id="L2534" href="#L2534">2534</a><a id="L2535" href="#L2535">2535</a><a id="L2536" href="#L2536">2536</a><a id="L2537" href="#L2537">2537</a><a id="L2538" href="#L2538">2538</a><a id="L2539" href="#L2539">2539</a><a id="L2540" href="#L2540">2540</a><a id="L2541" href="#L2541">2541</a><a id="L2542" href="#L2542">2542</a><a id="L2543" href="#L2543">2543</a><a id="L2544" href="#L2544">2544</a><a id="L2545" href="#L2545">2545</a><a id="L2546" href="#L2546">2546</a><a id="L2547" href="#L2547">2547</a><a id="L2548" href="#L2548">2548</a><a id="L2549" href="#L2549">2549</a><a id="L2550" href="#L2550">2550</a><a id="L2551" href="#L2551">2551</a><a id="L2552" href="#L2552">2552</a><a id="L2553" href="#L2553">2553</a><a id="L2554" href="#L2554">2554</a><a id="L2555" href="#L2555">2555</a><a id="L2556" href="#L2556">2556</a><a id="L2557" href="#L2557">2557</a><a id="L2558" href="#L2558">2558</a><a id="L2559" href="#L2559">2559</a><a id="L2560" href="#L2560">2560</a><a id="L2561" href="#L2561">2561</a><a id="L2562" href="#L2562">2562</a><a id="L2563" href="#L2563">2563</a><a id="L2564" href="#L2564">2564</a><a id="L2565" href="#L2565">2565</a><a id="L2566" href="#L2566">2566</a><a id="L2567" href="#L2567">2567</a><a id="L2568" href="#L2568">2568</a><a id="L2569" href="#L2569">2569</a><a id="L2570" href="#L2570">2570</a><a id="L2571" href="#L2571">2571</a><a id="L2572" href="#L2572">2572</a><a id="L2573" href="#L2573">2573</a><a id="L2574" href="#L2574">2574</a><a id="L2575" href="#L2575">2575</a><a id="L2576" href="#L2576">2576</a><a id="L2577" href="#L2577">2577</a><a id="L2578" href="#L2578">2578</a><a id="L2579" href="#L2579">2579</a><a id="L2580" href="#L2580">2580</a><a id="L2581" href="#L2581">2581</a><a id="L2582" href="#L2582">2582</a><a id="L2583" href="#L2583">2583</a><a id="L2584" href="#L2584">2584</a><a id="L2585" href="#L2585">2585</a><a id="L2586" href="#L2586">2586</a><a id="L2587" href="#L2587">2587</a><a id="L2588" href="#L2588">2588</a><a id="L2589" href="#L2589">2589</a><a id="L2590" href="#L2590">2590</a><a id="L2591" href="#L2591">2591</a><a id="L2592" href="#L2592">2592</a><a id="L2593" href="#L2593">2593</a><a id="L2594" href="#L2594">2594</a><a id="L2595" href="#L2595">2595</a><a id="L2596" href="#L2596">2596</a><a id="L2597" href="#L2597">2597</a><a id="L2598" href="#L2598">2598</a><a id="L2599" href="#L2599">2599</a><a id="L2600" href="#L2600">2600</a><a id="L2601" href="#L2601">2601</a><a id="L2602" href="#L2602">2602</a><a id="L2603" href="#L2603">2603</a><a id="L2604" href="#L2604">2604</a><a id="L2605" href="#L2605">2605</a><a id="L2606" href="#L2606">2606</a><a id="L2607" href="#L2607">2607</a><a id="L2608" href="#L2608">2608</a><a id="L2609" href="#L2609">2609</a><a id="L2610" href="#L2610">2610</a><a id="L2611" href="#L2611">2611</a><a id="L2612" href="#L2612">2612</a><a id="L2613" href="#L2613">2613</a><a id="L2614" href="#L2614">2614</a><a id="L2615" href="#L2615">2615</a><a id="L2616" href="#L2616">2616</a><a id="L2617" href="#L2617">2617</a><a id="L2618" href="#L2618">2618</a><a id="L2619" href="#L2619">2619</a><a id="L2620" href="#L2620">2620</a><a id="L2621" href="#L2621">2621</a><a id="L2622" href="#L2622">2622</a><a id="L2623" href="#L2623">2623</a><a id="L2624" href="#L2624">2624</a><a id="L2625" href="#L2625">2625</a><a id="L2626" href="#L2626">2626</a><a id="L2627" href="#L2627">2627</a><a id="L2628" href="#L2628">2628</a><a id="L2629" href="#L2629">2629</a><a id="L2630" href="#L2630">2630</a><a id="L2631" href="#L2631">2631</a><a id="L2632" href="#L2632">2632</a><a id="L2633" href="#L2633">2633</a><a id="L2634" href="#L2634">2634</a><a id="L2635" href="#L2635">2635</a><a id="L2636" href="#L2636">2636</a><a id="L2637" href="#L2637">2637</a><a id="L2638" href="#L2638">2638</a><a id="L2639" href="#L2639">2639</a><a id="L2640" href="#L2640">2640</a><a id="L2641" href="#L2641">2641</a><a id="L2642" href="#L2642">2642</a><a id="L2643" href="#L2643">2643</a><a id="L2644" href="#L2644">2644</a><a id="L2645" href="#L2645">2645</a><a id="L2646" href="#L2646">2646</a><a id="L2647" href="#L2647">2647</a><a id="L2648" href="#L2648">2648</a><a id="L2649" href="#L2649">2649</a><a id="L2650" href="#L2650">2650</a><a id="L2651" href="#L2651">2651</a><a id="L2652" href="#L2652">2652</a><a id="L2653" href="#L2653">2653</a><a id="L2654" href="#L2654">2654</a><a id="L2655" href="#L2655">2655</a><a id="L2656" href="#L2656">2656</a><a id="L2657" href="#L2657">2657</a><a id="L2658" href="#L2658">2658</a><a id="L2659" href="#L2659">2659</a><a id="L2660" href="#L2660">2660</a><a id="L2661" href="#L2661">2661</a><a id="L2662" href="#L2662">2662</a><a id="L2663" href="#L2663">2663</a><a id="L2664" href="#L2664">2664</a><a id="L2665" href="#L2665">2665</a><a id="L2666" href="#L2666">2666</a><a id="L2667" href="#L2667">2667</a><a id="L2668" href="#L2668">2668</a><a id="L2669" href="#L2669">2669</a><a id="L2670" href="#L2670">2670</a><a id="L2671" href="#L2671">2671</a><a id="L2672" href="#L2672">2672</a><a id="L2673" href="#L2673">2673</a><a id="L2674" href="#L2674">2674</a><a id="L2675" href="#L2675">2675</a><a id="L2676" href="#L2676">2676</a><a id="L2677" href="#L2677">2677</a><a id="L2678" href="#L2678">2678</a><a id="L2679" href="#L2679">2679</a><a id="L2680" href="#L2680">2680</a><a id="L2681" href="#L2681">2681</a><a id="L2682" href="#L2682">2682</a><a id="L2683" href="#L2683">2683</a><a id="L2684" href="#L2684">2684</a><a id="L2685" href="#L2685">2685</a><a id="L2686" href="#L2686">2686</a><a id="L2687" href="#L2687">2687</a><a id="L2688" href="#L2688">2688</a><a id="L2689" href="#L2689">2689</a><a id="L2690" href="#L2690">2690</a><a id="L2691" href="#L2691">2691</a><a id="L2692" href="#L2692">2692</a><a id="L2693" href="#L2693">2693</a><a id="L2694" href="#L2694">2694</a><a id="L2695" href="#L2695">2695</a><a id="L2696" href="#L2696">2696</a><a id="L2697" href="#L2697">2697</a><a id="L2698" href="#L2698">2698</a><a id="L2699" href="#L2699">2699</a><a id="L2700" href="#L2700">2700</a><a id="L2701" href="#L2701">2701</a><a id="L2702" href="#L2702">2702</a><a id="L2703" href="#L2703">2703</a><a id="L2704" href="#L2704">2704</a><a id="L2705" href="#L2705">2705</a><a id="L2706" href="#L2706">2706</a><a id="L2707" href="#L2707">2707</a><a id="L2708" href="#L2708">2708</a><a id="L2709" href="#L2709">2709</a><a id="L2710" href="#L2710">2710</a><a id="L2711" href="#L2711">2711</a><a id="L2712" href="#L2712">2712</a><a id="L2713" href="#L2713">2713</a><a id="L2714" href="#L2714">2714</a><a id="L2715" href="#L2715">2715</a><a id="L2716" href="#L2716">2716</a><a id="L2717" href="#L2717">2717</a><a id="L2718" href="#L2718">2718</a><a id="L2719" href="#L2719">2719</a><a id="L2720" href="#L2720">2720</a><a id="L2721" href="#L2721">2721</a><a id="L2722" href="#L2722">2722</a><a id="L2723" href="#L2723">2723</a><a id="L2724" href="#L2724">2724</a><a id="L2725" href="#L2725">2725</a><a id="L2726" href="#L2726">2726</a><a id="L2727" href="#L2727">2727</a><a id="L2728" href="#L2728">2728</a><a id="L2729" href="#L2729">2729</a><a id="L2730" href="#L2730">2730</a><a id="L2731" href="#L2731">2731</a><a id="L2732" href="#L2732">2732</a><a id="L2733" href="#L2733">2733</a><a id="L2734" href="#L2734">2734</a><a id="L2735" href="#L2735">2735</a><a id="L2736" href="#L2736">2736</a><a id="L2737" href="#L2737">2737</a><a id="L2738" href="#L2738">2738</a><a id="L2739" href="#L2739">2739</a><a id="L2740" href="#L2740">2740</a><a id="L2741" href="#L2741">2741</a><a id="L2742" href="#L2742">2742</a><a id="L2743" href="#L2743">2743</a><a id="L2744" href="#L2744">2744</a><a id="L2745" href="#L2745">2745</a><a id="L2746" href="#L2746">2746</a><a id="L2747" href="#L2747">2747</a><a id="L2748" href="#L2748">2748</a><a id="L2749" href="#L2749">2749</a><a id="L2750" href="#L2750">2750</a><a id="L2751" href="#L2751">2751</a><a id="L2752" href="#L2752">2752</a><a id="L2753" href="#L2753">2753</a><a id="L2754" href="#L2754">2754</a><a id="L2755" href="#L2755">2755</a><a id="L2756" href="#L2756">2756</a><a id="L2757" href="#L2757">2757</a><a id="L2758" href="#L2758">2758</a><a id="L2759" href="#L2759">2759</a><a id="L2760" href="#L2760">2760</a><a id="L2761" href="#L2761">2761</a><a id="L2762" href="#L2762">2762</a><a id="L2763" href="#L2763">2763</a><a id="L2764" href="#L2764">2764</a><a id="L2765" href="#L2765">2765</a><a id="L2766" href="#L2766">2766</a><a id="L2767" href="#L2767">2767</a><a id="L2768" href="#L2768">2768</a><a id="L2769" href="#L2769">2769</a><a id="L2770" href="#L2770">2770</a><a id="L2771" href="#L2771">2771</a><a id="L2772" href="#L2772">2772</a><a id="L2773" href="#L2773">2773</a><a id="L2774" href="#L2774">2774</a><a id="L2775" href="#L2775">2775</a><a id="L2776" href="#L2776">2776</a><a id="L2777" href="#L2777">2777</a><a id="L2778" href="#L2778">2778</a><a id="L2779" href="#L2779">2779</a><a id="L2780" href="#L2780">2780</a><a id="L2781" href="#L2781">2781</a><a id="L2782" href="#L2782">2782</a><a id="L2783" href="#L2783">2783</a><a id="L2784" href="#L2784">2784</a><a id="L2785" href="#L2785">2785</a><a id="L2786" href="#L2786">2786</a><a id="L2787" href="#L2787">2787</a><a id="L2788" href="#L2788">2788</a><a id="L2789" href="#L2789">2789</a><a id="L2790" href="#L2790">2790</a><a id="L2791" href="#L2791">2791</a><a id="L2792" href="#L2792">2792</a><a id="L2793" href="#L2793">2793</a><a id="L2794" href="#L2794">2794</a><a id="L2795" href="#L2795">2795</a><a id="L2796" href="#L2796">2796</a><a id="L2797" href="#L2797">2797</a><a id="L2798" href="#L2798">2798</a><a id="L2799" href="#L2799">2799</a><a id="L2800" href="#L2800">2800</a><a id="L2801" href="#L2801">2801</a><a id="L2802" href="#L2802">2802</a><a id="L2803" href="#L2803">2803</a><a id="L2804" href="#L2804">2804</a><a id="L2805" href="#L2805">2805</a><a id="L2806" href="#L2806">2806</a><a id="L2807" href="#L2807">2807</a><a id="L2808" href="#L2808">2808</a><a id="L2809" href="#L2809">2809</a><a id="L2810" href="#L2810">2810</a><a id="L2811" href="#L2811">2811</a><a id="L2812" href="#L2812">2812</a><a id="L2813" href="#L2813">2813</a><a id="L2814" href="#L2814">2814</a><a id="L2815" href="#L2815">2815</a><a id="L2816" href="#L2816">2816</a><a id="L2817" href="#L2817">2817</a><a id="L2818" href="#L2818">2818</a><a id="L2819" href="#L2819">2819</a><a id="L2820" href="#L2820">2820</a><a id="L2821" href="#L2821">2821</a><a id="L2822" href="#L2822">2822</a><a id="L2823" href="#L2823">2823</a><a id="L2824" href="#L2824">2824</a><a id="L2825" href="#L2825">2825</a><a id="L2826" href="#L2826">2826</a><a id="L2827" href="#L2827">2827</a><a id="L2828" href="#L2828">2828</a><a id="L2829" href="#L2829">2829</a><a id="L2830" href="#L2830">2830</a><a id="L2831" href="#L2831">2831</a><a id="L2832" href="#L2832">2832</a><a id="L2833" href="#L2833">2833</a><a id="L2834" href="#L2834">2834</a><a id="L2835" href="#L2835">2835</a><a id="L2836" href="#L2836">2836</a><a id="L2837" href="#L2837">2837</a><a id="L2838" href="#L2838">2838</a><a id="L2839" href="#L2839">2839</a><a id="L2840" href="#L2840">2840</a><a id="L2841" href="#L2841">2841</a><a id="L2842" href="#L2842">2842</a><a id="L2843" href="#L2843">2843</a><a id="L2844" href="#L2844">2844</a><a id="L2845" href="#L2845">2845</a><a id="L2846" href="#L2846">2846</a><a id="L2847" href="#L2847">2847</a><a id="L2848" href="#L2848">2848</a><a id="L2849" href="#L2849">2849</a><a id="L2850" href="#L2850">2850</a><a id="L2851" href="#L2851">2851</a><a id="L2852" href="#L2852">2852</a><a id="L2853" href="#L2853">2853</a><a id="L2854" href="#L2854">2854</a><a id="L2855" href="#L2855">2855</a><a id="L2856" href="#L2856">2856</a><a id="L2857" href="#L2857">2857</a><a id="L2858" href="#L2858">2858</a><a id="L2859" href="#L2859">2859</a><a id="L2860" href="#L2860">2860</a><a id="L2861" href="#L2861">2861</a><a id="L2862" href="#L2862">2862</a><a id="L2863" href="#L2863">2863</a><a id="L2864" href="#L2864">2864</a><a id="L2865" href="#L2865">2865</a><a id="L2866" href="#L2866">2866</a><a id="L2867" href="#L2867">2867</a><a id="L2868" href="#L2868">2868</a><a id="L2869" href="#L2869">2869</a><a id="L2870" href="#L2870">2870</a><a id="L2871" href="#L2871">2871</a><a id="L2872" href="#L2872">2872</a><a id="L2873" href="#L2873">2873</a><a id="L2874" href="#L2874">2874</a><a id="L2875" href="#L2875">2875</a><a id="L2876" href="#L2876">2876</a><a id="L2877" href="#L2877">2877</a><a id="L2878" href="#L2878">2878</a><a id="L2879" href="#L2879">2879</a><a id="L2880" href="#L2880">2880</a><a id="L2881" href="#L2881">2881</a><a id="L2882" href="#L2882">2882</a><a id="L2883" href="#L2883">2883</a><a id="L2884" href="#L2884">2884</a><a id="L2885" href="#L2885">2885</a><a id="L2886" href="#L2886">2886</a><a id="L2887" href="#L2887">2887</a><a id="L2888" href="#L2888">2888</a><a id="L2889" href="#L2889">2889</a><a id="L2890" href="#L2890">2890</a><a id="L2891" href="#L2891">2891</a><a id="L2892" href="#L2892">2892</a><a id="L2893" href="#L2893">2893</a><a id="L2894" href="#L2894">2894</a><a id="L2895" href="#L2895">2895</a><a id="L2896" href="#L2896">2896</a><a id="L2897" href="#L2897">2897</a><a id="L2898" href="#L2898">2898</a><a id="L2899" href="#L2899">2899</a><a id="L2900" href="#L2900">2900</a><a id="L2901" href="#L2901">2901</a><a id="L2902" href="#L2902">2902</a><a id="L2903" href="#L2903">2903</a><a id="L2904" href="#L2904">2904</a><a id="L2905" href="#L2905">2905</a><a id="L2906" href="#L2906">2906</a><a id="L2907" href="#L2907">2907</a><a id="L2908" href="#L2908">2908</a><a id="L2909" href="#L2909">2909</a><a id="L2910" href="#L2910">2910</a><a id="L2911" href="#L2911">2911</a><a id="L2912" href="#L2912">2912</a><a id="L2913" href="#L2913">2913</a><a id="L2914" href="#L2914">2914</a><a id="L2915" href="#L2915">2915</a><a id="L2916" href="#L2916">2916</a><a id="L2917" href="#L2917">2917</a><a id="L2918" href="#L2918">2918</a><a id="L2919" href="#L2919">2919</a><a id="L2920" href="#L2920">2920</a><a id="L2921" href="#L2921">2921</a><a id="L2922" href="#L2922">2922</a><a id="L2923" href="#L2923">2923</a><a id="L2924" href="#L2924">2924</a><a id="L2925" href="#L2925">2925</a><a id="L2926" href="#L2926">2926</a><a id="L2927" href="#L2927">2927</a><a id="L2928" href="#L2928">2928</a><a id="L2929" href="#L2929">2929</a><a id="L2930" href="#L2930">2930</a><a id="L2931" href="#L2931">2931</a><a id="L2932" href="#L2932">2932</a><a id="L2933" href="#L2933">2933</a><a id="L2934" href="#L2934">2934</a><a id="L2935" href="#L2935">2935</a><a id="L2936" href="#L2936">2936</a><a id="L2937" href="#L2937">2937</a><a id="L2938" href="#L2938">2938</a><a id="L2939" href="#L2939">2939</a><a id="L2940" href="#L2940">2940</a><a id="L2941" href="#L2941">2941</a><a id="L2942" href="#L2942">2942</a><a id="L2943" href="#L2943">2943</a><a id="L2944" href="#L2944">2944</a><a id="L2945" href="#L2945">2945</a><a id="L2946" href="#L2946">2946</a><a id="L2947" href="#L2947">2947</a><a id="L2948" href="#L2948">2948</a><a id="L2949" href="#L2949">2949</a><a id="L2950" href="#L2950">2950</a><a id="L2951" href="#L2951">2951</a><a id="L2952" href="#L2952">2952</a><a id="L2953" href="#L2953">2953</a><a id="L2954" href="#L2954">2954</a><a id="L2955" href="#L2955">2955</a><a id="L2956" href="#L2956">2956</a><a id="L2957" href="#L2957">2957</a><a id="L2958" href="#L2958">2958</a><a id="L2959" href="#L2959">2959</a><a id="L2960" href="#L2960">2960</a><a id="L2961" href="#L2961">2961</a><a id="L2962" href="#L2962">2962</a><a id="L2963" href="#L2963">2963</a><a id="L2964" href="#L2964">2964</a><a id="L2965" href="#L2965">2965</a><a id="L2966" href="#L2966">2966</a><a id="L2967" href="#L2967">2967</a><a id="L2968" href="#L2968">2968</a><a id="L2969" href="#L2969">2969</a><a id="L2970" href="#L2970">2970</a><a id="L2971" href="#L2971">2971</a><a id="L2972" href="#L2972">2972</a><a id="L2973" href="#L2973">2973</a><a id="L2974" href="#L2974">2974</a><a id="L2975" href="#L2975">2975</a><a id="L2976" href="#L2976">2976</a><a id="L2977" href="#L2977">2977</a><a id="L2978" href="#L2978">2978</a><a id="L2979" href="#L2979">2979</a><a id="L2980" href="#L2980">2980</a><a id="L2981" href="#L2981">2981</a><a id="L2982" href="#L2982">2982</a><a id="L2983" href="#L2983">2983</a><a id="L2984" href="#L2984">2984</a><a id="L2985" href="#L2985">2985</a><a id="L2986" href="#L2986">2986</a><a id="L2987" href="#L2987">2987</a><a id="L2988" href="#L2988">2988</a><a id="L2989" href="#L2989">2989</a><a id="L2990" href="#L2990">2990</a><a id="L2991" href="#L2991">2991</a><a id="L2992" href="#L2992">2992</a><a id="L2993" href="#L2993">2993</a><a id="L2994" href="#L2994">2994</a><a id="L2995" href="#L2995">2995</a><a id="L2996" href="#L2996">2996</a><a id="L2997" href="#L2997">2997</a><a id="L2998" href="#L2998">2998</a><a id="L2999" href="#L2999">2999</a><a id="L3000" href="#L3000">3000</a><a id="L3001" href="#L3001">3001</a><a id="L3002" href="#L3002">3002</a><a id="L3003" href="#L3003">3003</a><a id="L3004" href="#L3004">3004</a><a id="L3005" href="#L3005">3005</a><a id="L3006" href="#L3006">3006</a><a id="L3007" href="#L3007">3007</a><a id="L3008" href="#L3008">3008</a><a id="L3009" href="#L3009">3009</a><a id="L3010" href="#L3010">3010</a><a id="L3011" href="#L3011">3011</a><a id="L3012" href="#L3012">3012</a><a id="L3013" href="#L3013">3013</a><a id="L3014" href="#L3014">3014</a><a id="L3015" href="#L3015">3015</a><a id="L3016" href="#L3016">3016</a><a id="L3017" href="#L3017">3017</a><a id="L3018" href="#L3018">3018</a><a id="L3019" href="#L3019">3019</a><a id="L3020" href="#L3020">3020</a><a id="L3021" href="#L3021">3021</a><a id="L3022" href="#L3022">3022</a><a id="L3023" href="#L3023">3023</a><a id="L3024" href="#L3024">3024</a><a id="L3025" href="#L3025">3025</a><a id="L3026" href="#L3026">3026</a><a id="L3027" href="#L3027">3027</a><a id="L3028" href="#L3028">3028</a><a id="L3029" href="#L3029">3029</a><a id="L3030" href="#L3030">3030</a><a id="L3031" href="#L3031">3031</a><a id="L3032" href="#L3032">3032</a><a id="L3033" href="#L3033">3033</a><a id="L3034" href="#L3034">3034</a><a id="L3035" href="#L3035">3035</a><a id="L3036" href="#L3036">3036</a><a id="L3037" href="#L3037">3037</a><a id="L3038" href="#L3038">3038</a><a id="L3039" href="#L3039">3039</a><a id="L3040" href="#L3040">3040</a><a id="L3041" href="#L3041">3041</a><a id="L3042" href="#L3042">3042</a><a id="L3043" href="#L3043">3043</a><a id="L3044" href="#L3044">3044</a><a id="L3045" href="#L3045">3045</a><a id="L3046" href="#L3046">3046</a><a id="L3047" href="#L3047">3047</a><a id="L3048" href="#L3048">3048</a><a id="L3049" href="#L3049">3049</a><a id="L3050" href="#L3050">3050</a><a id="L3051" href="#L3051">3051</a><a id="L3052" href="#L3052">3052</a><a id="L3053" href="#L3053">3053</a><a id="L3054" href="#L3054">3054</a><a id="L3055" href="#L3055">3055</a><a id="L3056" href="#L3056">3056</a><a id="L3057" href="#L3057">3057</a><a id="L3058" href="#L3058">3058</a><a id="L3059" href="#L3059">3059</a><a id="L3060" href="#L3060">3060</a><a id="L3061" href="#L3061">3061</a><a id="L3062" href="#L3062">3062</a><a id="L3063" href="#L3063">3063</a><a id="L3064" href="#L3064">3064</a><a id="L3065" href="#L3065">3065</a><a id="L3066" href="#L3066">3066</a><a id="L3067" href="#L3067">3067</a><a id="L3068" href="#L3068">3068</a><a id="L3069" href="#L3069">3069</a><a id="L3070" href="#L3070">3070</a><a id="L3071" href="#L3071">3071</a><a id="L3072" href="#L3072">3072</a><a id="L3073" href="#L3073">3073</a><a id="L3074" href="#L3074">3074</a><a id="L3075" href="#L3075">3075</a><a id="L3076" href="#L3076">3076</a><a id="L3077" href="#L3077">3077</a><a id="L3078" href="#L3078">3078</a><a id="L3079" href="#L3079">3079</a><a id="L3080" href="#L3080">3080</a><a id="L3081" href="#L3081">3081</a><a id="L3082" href="#L3082">3082</a><a id="L3083" href="#L3083">3083</a><a id="L3084" href="#L3084">3084</a><a id="L3085" href="#L3085">3085</a><a id="L3086" href="#L3086">3086</a><a id="L3087" href="#L3087">3087</a><a id="L3088" href="#L3088">3088</a><a id="L3089" href="#L3089">3089</a><a id="L3090" href="#L3090">3090</a><a id="L3091" href="#L3091">3091</a><a id="L3092" href="#L3092">3092</a><a id="L3093" href="#L3093">3093</a><a id="L3094" href="#L3094">3094</a><a id="L3095" href="#L3095">3095</a><a id="L3096" href="#L3096">3096</a><a id="L3097" href="#L3097">3097</a><a id="L3098" href="#L3098">3098</a><a id="L3099" href="#L3099">3099</a><a id="L3100" href="#L3100">3100</a><a id="L3101" href="#L3101">3101</a><a id="L3102" href="#L3102">3102</a><a id="L3103" href="#L3103">3103</a><a id="L3104" href="#L3104">3104</a><a id="L3105" href="#L3105">3105</a><a id="L3106" href="#L3106">3106</a><a id="L3107" href="#L3107">3107</a><a id="L3108" href="#L3108">3108</a><a id="L3109" href="#L3109">3109</a><a id="L3110" href="#L3110">3110</a><a id="L3111" href="#L3111">3111</a><a id="L3112" href="#L3112">3112</a><a id="L3113" href="#L3113">3113</a><a id="L3114" href="#L3114">3114</a><a id="L3115" href="#L3115">3115</a><a id="L3116" href="#L3116">3116</a><a id="L3117" href="#L3117">3117</a><a id="L3118" href="#L3118">3118</a><a id="L3119" href="#L3119">3119</a><a id="L3120" href="#L3120">3120</a><a id="L3121" href="#L3121">3121</a><a id="L3122" href="#L3122">3122</a><a id="L3123" href="#L3123">3123</a><a id="L3124" href="#L3124">3124</a><a id="L3125" href="#L3125">3125</a><a id="L3126" href="#L3126">3126</a><a id="L3127" href="#L3127">3127</a><a id="L3128" href="#L3128">3128</a><a id="L3129" href="#L3129">3129</a><a id="L3130" href="#L3130">3130</a><a id="L3131" href="#L3131">3131</a><a id="L3132" href="#L3132">3132</a><a id="L3133" href="#L3133">3133</a><a id="L3134" href="#L3134">3134</a><a id="L3135" href="#L3135">3135</a><a id="L3136" href="#L3136">3136</a><a id="L3137" href="#L3137">3137</a><a id="L3138" href="#L3138">3138</a><a id="L3139" href="#L3139">3139</a><a id="L3140" href="#L3140">3140</a><a id="L3141" href="#L3141">3141</a><a id="L3142" href="#L3142">3142</a><a id="L3143" href="#L3143">3143</a><a id="L3144" href="#L3144">3144</a><a id="L3145" href="#L3145">3145</a><a id="L3146" href="#L3146">3146</a><a id="L3147" href="#L3147">3147</a><a id="L3148" href="#L3148">3148</a><a id="L3149" href="#L3149">3149</a><a id="L3150" href="#L3150">3150</a><a id="L3151" href="#L3151">3151</a><a id="L3152" href="#L3152">3152</a><a id="L3153" href="#L3153">3153</a><a id="L3154" href="#L3154">3154</a><a id="L3155" href="#L3155">3155</a><a id="L3156" href="#L3156">3156</a><a id="L3157" href="#L3157">3157</a><a id="L3158" href="#L3158">3158</a><a id="L3159" href="#L3159">3159</a><a id="L3160" href="#L3160">3160</a><a id="L3161" href="#L3161">3161</a><a id="L3162" href="#L3162">3162</a><a id="L3163" href="#L3163">3163</a><a id="L3164" href="#L3164">3164</a><a id="L3165" href="#L3165">3165</a><a id="L3166" href="#L3166">3166</a><a id="L3167" href="#L3167">3167</a><a id="L3168" href="#L3168">3168</a><a id="L3169" href="#L3169">3169</a><a id="L3170" href="#L3170">3170</a><a id="L3171" href="#L3171">3171</a><a id="L3172" href="#L3172">3172</a><a id="L3173" href="#L3173">3173</a><a id="L3174" href="#L3174">3174</a><a id="L3175" href="#L3175">3175</a><a id="L3176" href="#L3176">3176</a><a id="L3177" href="#L3177">3177</a><a id="L3178" href="#L3178">3178</a><a id="L3179" href="#L3179">3179</a><a id="L3180" href="#L3180">3180</a><a id="L3181" href="#L3181">3181</a><a id="L3182" href="#L3182">3182</a><a id="L3183" href="#L3183">3183</a><a id="L3184" href="#L3184">3184</a><a id="L3185" href="#L3185">3185</a><a id="L3186" href="#L3186">3186</a><a id="L3187" href="#L3187">3187</a><a id="L3188" href="#L3188">3188</a><a id="L3189" href="#L3189">3189</a><a id="L3190" href="#L3190">3190</a><a id="L3191" href="#L3191">3191</a><a id="L3192" href="#L3192">3192</a><a id="L3193" href="#L3193">3193</a><a id="L3194" href="#L3194">3194</a><a id="L3195" href="#L3195">3195</a><a id="L3196" href="#L3196">3196</a><a id="L3197" href="#L3197">3197</a><a id="L3198" href="#L3198">3198</a><a id="L3199" href="#L3199">3199</a><a id="L3200" href="#L3200">3200</a><a id="L3201" href="#L3201">3201</a><a id="L3202" href="#L3202">3202</a><a id="L3203" href="#L3203">3203</a><a id="L3204" href="#L3204">3204</a><a id="L3205" href="#L3205">3205</a><a id="L3206" href="#L3206">3206</a><a id="L3207" href="#L3207">3207</a><a id="L3208" href="#L3208">3208</a><a id="L3209" href="#L3209">3209</a><a id="L3210" href="#L3210">3210</a><a id="L3211" href="#L3211">3211</a><a id="L3212" href="#L3212">3212</a><a id="L3213" href="#L3213">3213</a><a id="L3214" href="#L3214">3214</a><a id="L3215" href="#L3215">3215</a><a id="L3216" href="#L3216">3216</a><a id="L3217" href="#L3217">3217</a><a id="L3218" href="#L3218">3218</a><a id="L3219" href="#L3219">3219</a><a id="L3220" href="#L3220">3220</a><a id="L3221" href="#L3221">3221</a><a id="L3222" href="#L3222">3222</a><a id="L3223" href="#L3223">3223</a><a id="L3224" href="#L3224">3224</a><a id="L3225" href="#L3225">3225</a><a id="L3226" href="#L3226">3226</a><a id="L3227" href="#L3227">3227</a><a id="L3228" href="#L3228">3228</a><a id="L3229" href="#L3229">3229</a><a id="L3230" href="#L3230">3230</a><a id="L3231" href="#L3231">3231</a><a id="L3232" href="#L3232">3232</a><a id="L3233" href="#L3233">3233</a><a id="L3234" href="#L3234">3234</a><a id="L3235" href="#L3235">3235</a><a id="L3236" href="#L3236">3236</a><a id="L3237" href="#L3237">3237</a><a id="L3238" href="#L3238">3238</a><a id="L3239" href="#L3239">3239</a><a id="L3240" href="#L3240">3240</a><a id="L3241" href="#L3241">3241</a><a id="L3242" href="#L3242">3242</a><a id="L3243" href="#L3243">3243</a><a id="L3244" href="#L3244">3244</a><a id="L3245" href="#L3245">3245</a><a id="L3246" href="#L3246">3246</a><a id="L3247" href="#L3247">3247</a><a id="L3248" href="#L3248">3248</a><a id="L3249" href="#L3249">3249</a><a id="L3250" href="#L3250">3250</a><a id="L3251" href="#L3251">3251</a><a id="L3252" href="#L3252">3252</a><a id="L3253" href="#L3253">3253</a><a id="L3254" href="#L3254">3254</a><a id="L3255" href="#L3255">3255</a><a id="L3256" href="#L3256">3256</a><a id="L3257" href="#L3257">3257</a><a id="L3258" href="#L3258">3258</a><a id="L3259" href="#L3259">3259</a><a id="L3260" href="#L3260">3260</a><a id="L3261" href="#L3261">3261</a><a id="L3262" href="#L3262">3262</a><a id="L3263" href="#L3263">3263</a><a id="L3264" href="#L3264">3264</a><a id="L3265" href="#L3265">3265</a><a id="L3266" href="#L3266">3266</a><a id="L3267" href="#L3267">3267</a><a id="L3268" href="#L3268">3268</a><a id="L3269" href="#L3269">3269</a><a id="L3270" href="#L3270">3270</a><a id="L3271" href="#L3271">3271</a><a id="L3272" href="#L3272">3272</a><a id="L3273" href="#L3273">3273</a><a id="L3274" href="#L3274">3274</a><a id="L3275" href="#L3275">3275</a><a id="L3276" href="#L3276">3276</a><a id="L3277" href="#L3277">3277</a><a id="L3278" href="#L3278">3278</a><a id="L3279" href="#L3279">3279</a><a id="L3280" href="#L3280">3280</a><a id="L3281" href="#L3281">3281</a><a id="L3282" href="#L3282">3282</a><a id="L3283" href="#L3283">3283</a><a id="L3284" href="#L3284">3284</a><a id="L3285" href="#L3285">3285</a><a id="L3286" href="#L3286">3286</a><a id="L3287" href="#L3287">3287</a><a id="L3288" href="#L3288">3288</a><a id="L3289" href="#L3289">3289</a><a id="L3290" href="#L3290">3290</a><a id="L3291" href="#L3291">3291</a><a id="L3292" href="#L3292">3292</a><a id="L3293" href="#L3293">3293</a><a id="L3294" href="#L3294">3294</a><a id="L3295" href="#L3295">3295</a><a id="L3296" href="#L3296">3296</a><a id="L3297" href="#L3297">3297</a><a id="L3298" href="#L3298">3298</a><a id="L3299" href="#L3299">3299</a><a id="L3300" href="#L3300">3300</a><a id="L3301" href="#L3301">3301</a><a id="L3302" href="#L3302">3302</a><a id="L3303" href="#L3303">3303</a><a id="L3304" href="#L3304">3304</a><a id="L3305" href="#L3305">3305</a><a id="L3306" href="#L3306">3306</a><a id="L3307" href="#L3307">3307</a><a id="L3308" href="#L3308">3308</a><a id="L3309" href="#L3309">3309</a><a id="L3310" href="#L3310">3310</a><a id="L3311" href="#L3311">3311</a><a id="L3312" href="#L3312">3312</a><a id="L3313" href="#L3313">3313</a><a id="L3314" href="#L3314">3314</a><a id="L3315" href="#L3315">3315</a><a id="L3316" href="#L3316">3316</a><a id="L3317" href="#L3317">3317</a><a id="L3318" href="#L3318">3318</a><a id="L3319" href="#L3319">3319</a><a id="L3320" href="#L3320">3320</a><a id="L3321" href="#L3321">3321</a><a id="L3322" href="#L3322">3322</a><a id="L3323" href="#L3323">3323</a><a id="L3324" href="#L3324">3324</a><a id="L3325" href="#L3325">3325</a><a id="L3326" href="#L3326">3326</a><a id="L3327" href="#L3327">3327</a><a id="L3328" href="#L3328">3328</a><a id="L3329" href="#L3329">3329</a><a id="L3330" href="#L3330">3330</a><a id="L3331" href="#L3331">3331</a><a id="L3332" href="#L3332">3332</a><a id="L3333" href="#L3333">3333</a><a id="L3334" href="#L3334">3334</a><a id="L3335" href="#L3335">3335</a><a id="L3336" href="#L3336">3336</a><a id="L3337" href="#L3337">3337</a><a id="L3338" href="#L3338">3338</a><a id="L3339" href="#L3339">3339</a><a id="L3340" href="#L3340">3340</a><a id="L3341" href="#L3341">3341</a><a id="L3342" href="#L3342">3342</a><a id="L3343" href="#L3343">3343</a><a id="L3344" href="#L3344">3344</a><a id="L3345" href="#L3345">3345</a><a id="L3346" href="#L3346">3346</a><a id="L3347" href="#L3347">3347</a><a id="L3348" href="#L3348">3348</a><a id="L3349" href="#L3349">3349</a><a id="L3350" href="#L3350">3350</a><a id="L3351" href="#L3351">3351</a><a id="L3352" href="#L3352">3352</a><a id="L3353" href="#L3353">3353</a><a id="L3354" href="#L3354">3354</a><a id="L3355" href="#L3355">3355</a><a id="L3356" href="#L3356">3356</a><a id="L3357" href="#L3357">3357</a><a id="L3358" href="#L3358">3358</a><a id="L3359" href="#L3359">3359</a><a id="L3360" href="#L3360">3360</a><a id="L3361" href="#L3361">3361</a><a id="L3362" href="#L3362">3362</a><a id="L3363" href="#L3363">3363</a><a id="L3364" href="#L3364">3364</a><a id="L3365" href="#L3365">3365</a><a id="L3366" href="#L3366">3366</a><a id="L3367" href="#L3367">3367</a><a id="L3368" href="#L3368">3368</a><a id="L3369" href="#L3369">3369</a><a id="L3370" href="#L3370">3370</a><a id="L3371" href="#L3371">3371</a><a id="L3372" href="#L3372">3372</a><a id="L3373" href="#L3373">3373</a><a id="L3374" href="#L3374">3374</a><a id="L3375" href="#L3375">3375</a><a id="L3376" href="#L3376">3376</a><a id="L3377" href="#L3377">3377</a><a id="L3378" href="#L3378">3378</a><a id="L3379" href="#L3379">3379</a><a id="L3380" href="#L3380">3380</a><a id="L3381" href="#L3381">3381</a><a id="L3382" href="#L3382">3382</a><a id="L3383" href="#L3383">3383</a><a id="L3384" href="#L3384">3384</a><a id="L3385" href="#L3385">3385</a><a id="L3386" href="#L3386">3386</a><a id="L3387" href="#L3387">3387</a><a id="L3388" href="#L3388">3388</a><a id="L3389" href="#L3389">3389</a><a id="L3390" href="#L3390">3390</a><a id="L3391" href="#L3391">3391</a><a id="L3392" href="#L3392">3392</a><a id="L3393" href="#L3393">3393</a><a id="L3394" href="#L3394">3394</a><a id="L3395" href="#L3395">3395</a><a id="L3396" href="#L3396">3396</a><a id="L3397" href="#L3397">3397</a><a id="L3398" href="#L3398">3398</a><a id="L3399" href="#L3399">3399</a><a id="L3400" href="#L3400">3400</a><a id="L3401" href="#L3401">3401</a><a id="L3402" href="#L3402">3402</a><a id="L3403" href="#L3403">3403</a><a id="L3404" href="#L3404">3404</a><a id="L3405" href="#L3405">3405</a><a id="L3406" href="#L3406">3406</a><a id="L3407" href="#L3407">3407</a><a id="L3408" href="#L3408">3408</a><a id="L3409" href="#L3409">3409</a><a id="L3410" href="#L3410">3410</a><a id="L3411" href="#L3411">3411</a><a id="L3412" href="#L3412">3412</a><a id="L3413" href="#L3413">3413</a><a id="L3414" href="#L3414">3414</a><a id="L3415" href="#L3415">3415</a><a id="L3416" href="#L3416">3416</a><a id="L3417" href="#L3417">3417</a><a id="L3418" href="#L3418">3418</a><a id="L3419" href="#L3419">3419</a><a id="L3420" href="#L3420">3420</a><a id="L3421" href="#L3421">3421</a><a id="L3422" href="#L3422">3422</a><a id="L3423" href="#L3423">3423</a><a id="L3424" href="#L3424">3424</a><a id="L3425" href="#L3425">3425</a><a id="L3426" href="#L3426">3426</a><a id="L3427" href="#L3427">3427</a><a id="L3428" href="#L3428">3428</a><a id="L3429" href="#L3429">3429</a><a id="L3430" href="#L3430">3430</a><a id="L3431" href="#L3431">3431</a><a id="L3432" href="#L3432">3432</a><a id="L3433" href="#L3433">3433</a><a id="L3434" href="#L3434">3434</a><a id="L3435" href="#L3435">3435</a><a id="L3436" href="#L3436">3436</a><a id="L3437" href="#L3437">3437</a><a id="L3438" href="#L3438">3438</a><a id="L3439" href="#L3439">3439</a><a id="L3440" href="#L3440">3440</a><a id="L3441" href="#L3441">3441</a><a id="L3442" href="#L3442">3442</a><a id="L3443" href="#L3443">3443</a><a id="L3444" href="#L3444">3444</a><a id="L3445" href="#L3445">3445</a><a id="L3446" href="#L3446">3446</a><a id="L3447" href="#L3447">3447</a><a id="L3448" href="#L3448">3448</a><a id="L3449" href="#L3449">3449</a><a id="L3450" href="#L3450">3450</a><a id="L3451" href="#L3451">3451</a><a id="L3452" href="#L3452">3452</a><a id="L3453" href="#L3453">3453</a><a id="L3454" href="#L3454">3454</a><a id="L3455" href="#L3455">3455</a><a id="L3456" href="#L3456">3456</a><a id="L3457" href="#L3457">3457</a><a id="L3458" href="#L3458">3458</a><a id="L3459" href="#L3459">3459</a><a id="L3460" href="#L3460">3460</a><a id="L3461" href="#L3461">3461</a><a id="L3462" href="#L3462">3462</a><a id="L3463" href="#L3463">3463</a><a id="L3464" href="#L3464">3464</a><a id="L3465" href="#L3465">3465</a><a id="L3466" href="#L3466">3466</a><a id="L3467" href="#L3467">3467</a><a id="L3468" href="#L3468">3468</a><a id="L3469" href="#L3469">3469</a><a id="L3470" href="#L3470">3470</a><a id="L3471" href="#L3471">3471</a><a id="L3472" href="#L3472">3472</a><a id="L3473" href="#L3473">3473</a><a id="L3474" href="#L3474">3474</a><a id="L3475" href="#L3475">3475</a><a id="L3476" href="#L3476">3476</a><a id="L3477" href="#L3477">3477</a><a id="L3478" href="#L3478">3478</a><a id="L3479" href="#L3479">3479</a><a id="L3480" href="#L3480">3480</a><a id="L3481" href="#L3481">3481</a><a id="L3482" href="#L3482">3482</a><a id="L3483" href="#L3483">3483</a><a id="L3484" href="#L3484">3484</a><a id="L3485" href="#L3485">3485</a><a id="L3486" href="#L3486">3486</a><a id="L3487" href="#L3487">3487</a><a id="L3488" href="#L3488">3488</a><a id="L3489" href="#L3489">3489</a><a id="L3490" href="#L3490">3490</a><a id="L3491" href="#L3491">3491</a><a id="L3492" href="#L3492">3492</a><a id="L3493" href="#L3493">3493</a><a id="L3494" href="#L3494">3494</a><a id="L3495" href="#L3495">3495</a><a id="L3496" href="#L3496">3496</a><a id="L3497" href="#L3497">3497</a><a id="L3498" href="#L3498">3498</a><a id="L3499" href="#L3499">3499</a><a id="L3500" href="#L3500">3500</a><a id="L3501" href="#L3501">3501</a><a id="L3502" href="#L3502">3502</a><a id="L3503" href="#L3503">3503</a><a id="L3504" href="#L3504">3504</a><a id="L3505" href="#L3505">3505</a><a id="L3506" href="#L3506">3506</a><a id="L3507" href="#L3507">3507</a><a id="L3508" href="#L3508">3508</a><a id="L3509" href="#L3509">3509</a><a id="L3510" href="#L3510">3510</a><a id="L3511" href="#L3511">3511</a><a id="L3512" href="#L3512">3512</a><a id="L3513" href="#L3513">3513</a><a id="L3514" href="#L3514">3514</a><a id="L3515" href="#L3515">3515</a><a id="L3516" href="#L3516">3516</a><a id="L3517" href="#L3517">3517</a><a id="L3518" href="#L3518">3518</a><a id="L3519" href="#L3519">3519</a><a id="L3520" href="#L3520">3520</a><a id="L3521" href="#L3521">3521</a><a id="L3522" href="#L3522">3522</a><a id="L3523" href="#L3523">3523</a><a id="L3524" href="#L3524">3524</a><a id="L3525" href="#L3525">3525</a><a id="L3526" href="#L3526">3526</a><a id="L3527" href="#L3527">3527</a><a id="L3528" href="#L3528">3528</a><a id="L3529" href="#L3529">3529</a><a id="L3530" href="#L3530">3530</a><a id="L3531" href="#L3531">3531</a><a id="L3532" href="#L3532">3532</a><a id="L3533" href="#L3533">3533</a><a id="L3534" href="#L3534">3534</a><a id="L3535" href="#L3535">3535</a><a id="L3536" href="#L3536">3536</a><a id="L3537" href="#L3537">3537</a><a id="L3538" href="#L3538">3538</a><a id="L3539" href="#L3539">3539</a><a id="L3540" href="#L3540">3540</a><a id="L3541" href="#L3541">3541</a><a id="L3542" href="#L3542">3542</a><a id="L3543" href="#L3543">3543</a><a id="L3544" href="#L3544">3544</a><a id="L3545" href="#L3545">3545</a><a id="L3546" href="#L3546">3546</a><a id="L3547" href="#L3547">3547</a><a id="L3548" href="#L3548">3548</a><a id="L3549" href="#L3549">3549</a><a id="L3550" href="#L3550">3550</a><a id="L3551" href="#L3551">3551</a><a id="L3552" href="#L3552">3552</a><a id="L3553" href="#L3553">3553</a><a id="L3554" href="#L3554">3554</a><a id="L3555" href="#L3555">3555</a><a id="L3556" href="#L3556">3556</a><a id="L3557" href="#L3557">3557</a><a id="L3558" href="#L3558">3558</a><a id="L3559" href="#L3559">3559</a><a id="L3560" href="#L3560">3560</a><a id="L3561" href="#L3561">3561</a><a id="L3562" href="#L3562">3562</a><a id="L3563" href="#L3563">3563</a><a id="L3564" href="#L3564">3564</a><a id="L3565" href="#L3565">3565</a><a id="L3566" href="#L3566">3566</a><a id="L3567" href="#L3567">3567</a><a id="L3568" href="#L3568">3568</a><a id="L3569" href="#L3569">3569</a><a id="L3570" href="#L3570">3570</a><a id="L3571" href="#L3571">3571</a><a id="L3572" href="#L3572">3572</a><a id="L3573" href="#L3573">3573</a><a id="L3574" href="#L3574">3574</a><a id="L3575" href="#L3575">3575</a><a id="L3576" href="#L3576">3576</a><a id="L3577" href="#L3577">3577</a><a id="L3578" href="#L3578">3578</a><a id="L3579" href="#L3579">3579</a><a id="L3580" href="#L3580">3580</a><a id="L3581" href="#L3581">3581</a><a id="L3582" href="#L3582">3582</a><a id="L3583" href="#L3583">3583</a><a id="L3584" href="#L3584">3584</a><a id="L3585" href="#L3585">3585</a><a id="L3586" href="#L3586">3586</a><a id="L3587" href="#L3587">3587</a><a id="L3588" href="#L3588">3588</a><a id="L3589" href="#L3589">3589</a><a id="L3590" href="#L3590">3590</a><a id="L3591" href="#L3591">3591</a><a id="L3592" href="#L3592">3592</a><a id="L3593" href="#L3593">3593</a><a id="L3594" href="#L3594">3594</a><a id="L3595" href="#L3595">3595</a><a id="L3596" href="#L3596">3596</a><a id="L3597" href="#L3597">3597</a><a id="L3598" href="#L3598">3598</a><a id="L3599" href="#L3599">3599</a><a id="L3600" href="#L3600">3600</a><a id="L3601" href="#L3601">3601</a><a id="L3602" href="#L3602">3602</a><a id="L3603" href="#L3603">3603</a><a id="L3604" href="#L3604">3604</a><a id="L3605" href="#L3605">3605</a><a id="L3606" href="#L3606">3606</a><a id="L3607" href="#L3607">3607</a><a id="L3608" href="#L3608">3608</a><a id="L3609" href="#L3609">3609</a><a id="L3610" href="#L3610">3610</a><a id="L3611" href="#L3611">3611</a><a id="L3612" href="#L3612">3612</a><a id="L3613" href="#L3613">3613</a><a id="L3614" href="#L3614">3614</a><a id="L3615" href="#L3615">3615</a><a id="L3616" href="#L3616">3616</a><a id="L3617" href="#L3617">3617</a><a id="L3618" href="#L3618">3618</a><a id="L3619" href="#L3619">3619</a><a id="L3620" href="#L3620">3620</a><a id="L3621" href="#L3621">3621</a><a id="L3622" href="#L3622">3622</a><a id="L3623" href="#L3623">3623</a><a id="L3624" href="#L3624">3624</a><a id="L3625" href="#L3625">3625</a><a id="L3626" href="#L3626">3626</a><a id="L3627" href="#L3627">3627</a><a id="L3628" href="#L3628">3628</a><a id="L3629" href="#L3629">3629</a><a id="L3630" href="#L3630">3630</a><a id="L3631" href="#L3631">3631</a><a id="L3632" href="#L3632">3632</a><a id="L3633" href="#L3633">3633</a><a id="L3634" href="#L3634">3634</a><a id="L3635" href="#L3635">3635</a><a id="L3636" href="#L3636">3636</a><a id="L3637" href="#L3637">3637</a><a id="L3638" href="#L3638">3638</a><a id="L3639" href="#L3639">3639</a><a id="L3640" href="#L3640">3640</a><a id="L3641" href="#L3641">3641</a><a id="L3642" href="#L3642">3642</a><a id="L3643" href="#L3643">3643</a><a id="L3644" href="#L3644">3644</a><a id="L3645" href="#L3645">3645</a><a id="L3646" href="#L3646">3646</a><a id="L3647" href="#L3647">3647</a><a id="L3648" href="#L3648">3648</a><a id="L3649" href="#L3649">3649</a><a id="L3650" href="#L3650">3650</a><a id="L3651" href="#L3651">3651</a><a id="L3652" href="#L3652">3652</a><a id="L3653" href="#L3653">3653</a><a id="L3654" href="#L3654">3654</a><a id="L3655" href="#L3655">3655</a><a id="L3656" href="#L3656">3656</a><a id="L3657" href="#L3657">3657</a><a id="L3658" href="#L3658">3658</a><a id="L3659" href="#L3659">3659</a><a id="L3660" href="#L3660">3660</a><a id="L3661" href="#L3661">3661</a><a id="L3662" href="#L3662">3662</a><a id="L3663" href="#L3663">3663</a><a id="L3664" href="#L3664">3664</a><a id="L3665" href="#L3665">3665</a><a id="L3666" href="#L3666">3666</a><a id="L3667" href="#L3667">3667</a><a id="L3668" href="#L3668">3668</a><a id="L3669" href="#L3669">3669</a><a id="L3670" href="#L3670">3670</a><a id="L3671" href="#L3671">3671</a><a id="L3672" href="#L3672">3672</a><a id="L3673" href="#L3673">3673</a><a id="L3674" href="#L3674">3674</a><a id="L3675" href="#L3675">3675</a><a id="L3676" href="#L3676">3676</a><a id="L3677" href="#L3677">3677</a><a id="L3678" href="#L3678">3678</a><a id="L3679" href="#L3679">3679</a><a id="L3680" href="#L3680">3680</a><a id="L3681" href="#L3681">3681</a><a id="L3682" href="#L3682">3682</a><a id="L3683" href="#L3683">3683</a><a id="L3684" href="#L3684">3684</a><a id="L3685" href="#L3685">3685</a><a id="L3686" href="#L3686">3686</a><a id="L3687" href="#L3687">3687</a><a id="L3688" href="#L3688">3688</a><a id="L3689" href="#L3689">3689</a><a id="L3690" href="#L3690">3690</a><a id="L3691" href="#L3691">3691</a><a id="L3692" href="#L3692">3692</a><a id="L3693" href="#L3693">3693</a><a id="L3694" href="#L3694">3694</a><a id="L3695" href="#L3695">3695</a><a id="L3696" href="#L3696">3696</a><a id="L3697" href="#L3697">3697</a><a id="L3698" href="#L3698">3698</a><a id="L3699" href="#L3699">3699</a><a id="L3700" href="#L3700">3700</a><a id="L3701" href="#L3701">3701</a><a id="L3702" href="#L3702">3702</a><a id="L3703" href="#L3703">3703</a><a id="L3704" href="#L3704">3704</a><a id="L3705" href="#L3705">3705</a><a id="L3706" href="#L3706">3706</a><a id="L3707" href="#L3707">3707</a><a id="L3708" href="#L3708">3708</a><a id="L3709" href="#L3709">3709</a><a id="L3710" href="#L3710">3710</a><a id="L3711" href="#L3711">3711</a><a id="L3712" href="#L3712">3712</a><a id="L3713" href="#L3713">3713</a><a id="L3714" href="#L3714">3714</a><a id="L3715" href="#L3715">3715</a><a id="L3716" href="#L3716">3716</a><a id="L3717" href="#L3717">3717</a><a id="L3718" href="#L3718">3718</a><a id="L3719" href="#L3719">3719</a><a id="L3720" href="#L3720">3720</a><a id="L3721" href="#L3721">3721</a><a id="L3722" href="#L3722">3722</a><a id="L3723" href="#L3723">3723</a><a id="L3724" href="#L3724">3724</a><a id="L3725" href="#L3725">3725</a><a id="L3726" href="#L3726">3726</a><a id="L3727" href="#L3727">3727</a><a id="L3728" href="#L3728">3728</a><a id="L3729" href="#L3729">3729</a><a id="L3730" href="#L3730">3730</a><a id="L3731" href="#L3731">3731</a><a id="L3732" href="#L3732">3732</a><a id="L3733" href="#L3733">3733</a><a id="L3734" href="#L3734">3734</a><a id="L3735" href="#L3735">3735</a><a id="L3736" href="#L3736">3736</a><a id="L3737" href="#L3737">3737</a><a id="L3738" href="#L3738">3738</a><a id="L3739" href="#L3739">3739</a><a id="L3740" href="#L3740">3740</a><a id="L3741" href="#L3741">3741</a><a id="L3742" href="#L3742">3742</a><a id="L3743" href="#L3743">3743</a><a id="L3744" href="#L3744">3744</a><a id="L3745" href="#L3745">3745</a><a id="L3746" href="#L3746">3746</a><a id="L3747" href="#L3747">3747</a><a id="L3748" href="#L3748">3748</a><a id="L3749" href="#L3749">3749</a><a id="L3750" href="#L3750">3750</a><a id="L3751" href="#L3751">3751</a><a id="L3752" href="#L3752">3752</a><a id="L3753" href="#L3753">3753</a><a id="L3754" href="#L3754">3754</a><a id="L3755" href="#L3755">3755</a><a id="L3756" href="#L3756">3756</a><a id="L3757" href="#L3757">3757</a><a id="L3758" href="#L3758">3758</a><a id="L3759" href="#L3759">3759</a><a id="L3760" href="#L3760">3760</a><a id="L3761" href="#L3761">3761</a><a id="L3762" href="#L3762">3762</a><a id="L3763" href="#L3763">3763</a><a id="L3764" href="#L3764">3764</a><a id="L3765" href="#L3765">3765</a><a id="L3766" href="#L3766">3766</a><a id="L3767" href="#L3767">3767</a><a id="L3768" href="#L3768">3768</a><a id="L3769" href="#L3769">3769</a><a id="L3770" href="#L3770">3770</a><a id="L3771" href="#L3771">3771</a><a id="L3772" href="#L3772">3772</a><a id="L3773" href="#L3773">3773</a><a id="L3774" href="#L3774">3774</a><a id="L3775" href="#L3775">3775</a><a id="L3776" href="#L3776">3776</a><a id="L3777" href="#L3777">3777</a><a id="L3778" href="#L3778">3778</a><a id="L3779" href="#L3779">3779</a><a id="L3780" href="#L3780">3780</a><a id="L3781" href="#L3781">3781</a><a id="L3782" href="#L3782">3782</a><a id="L3783" href="#L3783">3783</a><a id="L3784" href="#L3784">3784</a><a id="L3785" href="#L3785">3785</a><a id="L3786" href="#L3786">3786</a><a id="L3787" href="#L3787">3787</a><a id="L3788" href="#L3788">3788</a><a id="L3789" href="#L3789">3789</a><a id="L3790" href="#L3790">3790</a><a id="L3791" href="#L3791">3791</a><a id="L3792" href="#L3792">3792</a><a id="L3793" href="#L3793">3793</a><a id="L3794" href="#L3794">3794</a><a id="L3795" href="#L3795">3795</a><a id="L3796" href="#L3796">3796</a><a id="L3797" href="#L3797">3797</a><a id="L3798" href="#L3798">3798</a><a id="L3799" href="#L3799">3799</a><a id="L3800" href="#L3800">3800</a><a id="L3801" href="#L3801">3801</a><a id="L3802" href="#L3802">3802</a><a id="L3803" href="#L3803">3803</a><a id="L3804" href="#L3804">3804</a><a id="L3805" href="#L3805">3805</a><a id="L3806" href="#L3806">3806</a><a id="L3807" href="#L3807">3807</a><a id="L3808" href="#L3808">3808</a><a id="L3809" href="#L3809">3809</a><a id="L3810" href="#L3810">3810</a><a id="L3811" href="#L3811">3811</a><a id="L3812" href="#L3812">3812</a><a id="L3813" href="#L3813">3813</a><a id="L3814" href="#L3814">3814</a><a id="L3815" href="#L3815">3815</a><a id="L3816" href="#L3816">3816</a><a id="L3817" href="#L3817">3817</a><a id="L3818" href="#L3818">3818</a><a id="L3819" href="#L3819">3819</a><a id="L3820" href="#L3820">3820</a><a id="L3821" href="#L3821">3821</a><a id="L3822" href="#L3822">3822</a><a id="L3823" href="#L3823">3823</a><a id="L3824" href="#L3824">3824</a><a id="L3825" href="#L3825">3825</a><a id="L3826" href="#L3826">3826</a><a id="L3827" href="#L3827">3827</a><a id="L3828" href="#L3828">3828</a><a id="L3829" href="#L3829">3829</a><a id="L3830" href="#L3830">3830</a><a id="L3831" href="#L3831">3831</a><a id="L3832" href="#L3832">3832</a><a id="L3833" href="#L3833">3833</a><a id="L3834" href="#L3834">3834</a><a id="L3835" href="#L3835">3835</a><a id="L3836" href="#L3836">3836</a><a id="L3837" href="#L3837">3837</a><a id="L3838" href="#L3838">3838</a><a id="L3839" href="#L3839">3839</a><a id="L3840" href="#L3840">3840</a><a id="L3841" href="#L3841">3841</a><a id="L3842" href="#L3842">3842</a><a id="L3843" href="#L3843">3843</a><a id="L3844" href="#L3844">3844</a><a id="L3845" href="#L3845">3845</a><a id="L3846" href="#L3846">3846</a><a id="L3847" href="#L3847">3847</a><a id="L3848" href="#L3848">3848</a><a id="L3849" href="#L3849">3849</a><a id="L3850" href="#L3850">3850</a><a id="L3851" href="#L3851">3851</a><a id="L3852" href="#L3852">3852</a><a id="L3853" href="#L3853">3853</a><a id="L3854" href="#L3854">3854</a><a id="L3855" href="#L3855">3855</a><a id="L3856" href="#L3856">3856</a><a id="L3857" href="#L3857">3857</a><a id="L3858" href="#L3858">3858</a><a id="L3859" href="#L3859">3859</a><a id="L3860" href="#L3860">3860</a><a id="L3861" href="#L3861">3861</a><a id="L3862" href="#L3862">3862</a><a id="L3863" href="#L3863">3863</a><a id="L3864" href="#L3864">3864</a><a id="L3865" href="#L3865">3865</a><a id="L3866" href="#L3866">3866</a><a id="L3867" href="#L3867">3867</a><a id="L3868" href="#L3868">3868</a><a id="L3869" href="#L3869">3869</a><a id="L3870" href="#L3870">3870</a><a id="L3871" href="#L3871">3871</a><a id="L3872" href="#L3872">3872</a><a id="L3873" href="#L3873">3873</a><a id="L3874" href="#L3874">3874</a><a id="L3875" href="#L3875">3875</a><a id="L3876" href="#L3876">3876</a><a id="L3877" href="#L3877">3877</a><a id="L3878" href="#L3878">3878</a><a id="L3879" href="#L3879">3879</a><a id="L3880" href="#L3880">3880</a><a id="L3881" href="#L3881">3881</a><a id="L3882" href="#L3882">3882</a><a id="L3883" href="#L3883">3883</a><a id="L3884" href="#L3884">3884</a><a id="L3885" href="#L3885">3885</a><a id="L3886" href="#L3886">3886</a><a id="L3887" href="#L3887">3887</a><a id="L3888" href="#L3888">3888</a><a id="L3889" href="#L3889">3889</a><a id="L3890" href="#L3890">3890</a><a id="L3891" href="#L3891">3891</a><a id="L3892" href="#L3892">3892</a><a id="L3893" href="#L3893">3893</a><a id="L3894" href="#L3894">3894</a><a id="L3895" href="#L3895">3895</a><a id="L3896" href="#L3896">3896</a><a id="L3897" href="#L3897">3897</a><a id="L3898" href="#L3898">3898</a><a id="L3899" href="#L3899">3899</a><a id="L3900" href="#L3900">3900</a><a id="L3901" href="#L3901">3901</a><a id="L3902" href="#L3902">3902</a><a id="L3903" href="#L3903">3903</a><a id="L3904" href="#L3904">3904</a><a id="L3905" href="#L3905">3905</a><a id="L3906" href="#L3906">3906</a><a id="L3907" href="#L3907">3907</a><a id="L3908" href="#L3908">3908</a><a id="L3909" href="#L3909">3909</a><a id="L3910" href="#L3910">3910</a><a id="L3911" href="#L3911">3911</a><a id="L3912" href="#L3912">3912</a><a id="L3913" href="#L3913">3913</a><a id="L3914" href="#L3914">3914</a><a id="L3915" href="#L3915">3915</a><a id="L3916" href="#L3916">3916</a><a id="L3917" href="#L3917">3917</a><a id="L3918" href="#L3918">3918</a><a id="L3919" href="#L3919">3919</a><a id="L3920" href="#L3920">3920</a><a id="L3921" href="#L3921">3921</a><a id="L3922" href="#L3922">3922</a><a id="L3923" href="#L3923">3923</a><a id="L3924" href="#L3924">3924</a><a id="L3925" href="#L3925">3925</a><a id="L3926" href="#L3926">3926</a><a id="L3927" href="#L3927">3927</a><a id="L3928" href="#L3928">3928</a><a id="L3929" href="#L3929">3929</a><a id="L3930" href="#L3930">3930</a><a id="L3931" href="#L3931">3931</a><a id="L3932" href="#L3932">3932</a><a id="L3933" href="#L3933">3933</a><a id="L3934" href="#L3934">3934</a><a id="L3935" href="#L3935">3935</a><a id="L3936" href="#L3936">3936</a><a id="L3937" href="#L3937">3937</a><a id="L3938" href="#L3938">3938</a><a id="L3939" href="#L3939">3939</a><a id="L3940" href="#L3940">3940</a><a id="L3941" href="#L3941">3941</a><a id="L3942" href="#L3942">3942</a><a id="L3943" href="#L3943">3943</a><a id="L3944" href="#L3944">3944</a><a id="L3945" href="#L3945">3945</a><a id="L3946" href="#L3946">3946</a><a id="L3947" href="#L3947">3947</a><a id="L3948" href="#L3948">3948</a><a id="L3949" href="#L3949">3949</a><a id="L3950" href="#L3950">3950</a><a id="L3951" href="#L3951">3951</a><a id="L3952" href="#L3952">3952</a><a id="L3953" href="#L3953">3953</a><a id="L3954" href="#L3954">3954</a><a id="L3955" href="#L3955">3955</a><a id="L3956" href="#L3956">3956</a><a id="L3957" href="#L3957">3957</a><a id="L3958" href="#L3958">3958</a><a id="L3959" href="#L3959">3959</a><a id="L3960" href="#L3960">3960</a><a id="L3961" href="#L3961">3961</a><a id="L3962" href="#L3962">3962</a><a id="L3963" href="#L3963">3963</a><a id="L3964" href="#L3964">3964</a><a id="L3965" href="#L3965">3965</a><a id="L3966" href="#L3966">3966</a><a id="L3967" href="#L3967">3967</a><a id="L3968" href="#L3968">3968</a><a id="L3969" href="#L3969">3969</a><a id="L3970" href="#L3970">3970</a><a id="L3971" href="#L3971">3971</a><a id="L3972" href="#L3972">3972</a><a id="L3973" href="#L3973">3973</a><a id="L3974" href="#L3974">3974</a><a id="L3975" href="#L3975">3975</a><a id="L3976" href="#L3976">3976</a><a id="L3977" href="#L3977">3977</a><a id="L3978" href="#L3978">3978</a><a id="L3979" href="#L3979">3979</a><a id="L3980" href="#L3980">3980</a><a id="L3981" href="#L3981">3981</a><a id="L3982" href="#L3982">3982</a><a id="L3983" href="#L3983">3983</a><a id="L3984" href="#L3984">3984</a><a id="L3985" href="#L3985">3985</a><a id="L3986" href="#L3986">3986</a><a id="L3987" href="#L3987">3987</a><a id="L3988" href="#L3988">3988</a><a id="L3989" href="#L3989">3989</a><a id="L3990" href="#L3990">3990</a><a id="L3991" href="#L3991">3991</a><a id="L3992" href="#L3992">3992</a><a id="L3993" href="#L3993">3993</a><a id="L3994" href="#L3994">3994</a><a id="L3995" href="#L3995">3995</a><a id="L3996" href="#L3996">3996</a><a id="L3997" href="#L3997">3997</a><a id="L3998" href="#L3998">3998</a><a id="L3999" href="#L3999">3999</a><a id="L4000" href="#L4000">4000</a><a id="L4001" href="#L4001">4001</a><a id="L4002" href="#L4002">4002</a><a id="L4003" href="#L4003">4003</a><a id="L4004" href="#L4004">4004</a><a id="L4005" href="#L4005">4005</a><a id="L4006" href="#L4006">4006</a><a id="L4007" href="#L4007">4007</a><a id="L4008" href="#L4008">4008</a><a id="L4009" href="#L4009">4009</a><a id="L4010" href="#L4010">4010</a><a id="L4011" href="#L4011">4011</a><a id="L4012" href="#L4012">4012</a><a id="L4013" href="#L4013">4013</a><a id="L4014" href="#L4014">4014</a><a id="L4015" href="#L4015">4015</a><a id="L4016" href="#L4016">4016</a><a id="L4017" href="#L4017">4017</a><a id="L4018" href="#L4018">4018</a><a id="L4019" href="#L4019">4019</a><a id="L4020" href="#L4020">4020</a><a id="L4021" href="#L4021">4021</a><a id="L4022" href="#L4022">4022</a><a id="L4023" href="#L4023">4023</a><a id="L4024" href="#L4024">4024</a><a id="L4025" href="#L4025">4025</a><a id="L4026" href="#L4026">4026</a><a id="L4027" href="#L4027">4027</a><a id="L4028" href="#L4028">4028</a><a id="L4029" href="#L4029">4029</a><a id="L4030" href="#L4030">4030</a><a id="L4031" href="#L4031">4031</a><a id="L4032" href="#L4032">4032</a><a id="L4033" href="#L4033">4033</a><a id="L4034" href="#L4034">4034</a><a id="L4035" href="#L4035">4035</a><a id="L4036" href="#L4036">4036</a><a id="L4037" href="#L4037">4037</a><a id="L4038" href="#L4038">4038</a><a id="L4039" href="#L4039">4039</a><a id="L4040" href="#L4040">4040</a><a id="L4041" href="#L4041">4041</a><a id="L4042" href="#L4042">4042</a><a id="L4043" href="#L4043">4043</a><a id="L4044" href="#L4044">4044</a><a id="L4045" href="#L4045">4045</a><a id="L4046" href="#L4046">4046</a><a id="L4047" href="#L4047">4047</a><a id="L4048" href="#L4048">4048</a><a id="L4049" href="#L4049">4049</a><a id="L4050" href="#L4050">4050</a><a id="L4051" href="#L4051">4051</a><a id="L4052" href="#L4052">4052</a><a id="L4053" href="#L4053">4053</a><a id="L4054" href="#L4054">4054</a><a id="L4055" href="#L4055">4055</a><a id="L4056" href="#L4056">4056</a><a id="L4057" href="#L4057">4057</a><a id="L4058" href="#L4058">4058</a><a id="L4059" href="#L4059">4059</a><a id="L4060" href="#L4060">4060</a><a id="L4061" href="#L4061">4061</a><a id="L4062" href="#L4062">4062</a><a id="L4063" href="#L4063">4063</a><a id="L4064" href="#L4064">4064</a><a id="L4065" href="#L4065">4065</a><a id="L4066" href="#L4066">4066</a><a id="L4067" href="#L4067">4067</a><a id="L4068" href="#L4068">4068</a><a id="L4069" href="#L4069">4069</a><a id="L4070" href="#L4070">4070</a><a id="L4071" href="#L4071">4071</a><a id="L4072" href="#L4072">4072</a><a id="L4073" href="#L4073">4073</a><a id="L4074" href="#L4074">4074</a><a id="L4075" href="#L4075">4075</a><a id="L4076" href="#L4076">4076</a><a id="L4077" href="#L4077">4077</a><a id="L4078" href="#L4078">4078</a><a id="L4079" href="#L4079">4079</a><a id="L4080" href="#L4080">4080</a><a id="L4081" href="#L4081">4081</a><a id="L4082" href="#L4082">4082</a><a id="L4083" href="#L4083">4083</a><a id="L4084" href="#L4084">4084</a><a id="L4085" href="#L4085">4085</a><a id="L4086" href="#L4086">4086</a><a id="L4087" href="#L4087">4087</a><a id="L4088" href="#L4088">4088</a><a id="L4089" href="#L4089">4089</a><a id="L4090" href="#L4090">4090</a><a id="L4091" href="#L4091">4091</a><a id="L4092" href="#L4092">4092</a><a id="L4093" href="#L4093">4093</a><a id="L4094" href="#L4094">4094</a><a id="L4095" href="#L4095">4095</a><a id="L4096" href="#L4096">4096</a><a id="L4097" href="#L4097">4097</a><a id="L4098" href="#L4098">4098</a><a id="L4099" href="#L4099">4099</a><a id="L4100" href="#L4100">4100</a><a id="L4101" href="#L4101">4101</a><a id="L4102" href="#L4102">4102</a><a id="L4103" href="#L4103">4103</a><a id="L4104" href="#L4104">4104</a><a id="L4105" href="#L4105">4105</a><a id="L4106" href="#L4106">4106</a><a id="L4107" href="#L4107">4107</a><a id="L4108" href="#L4108">4108</a><a id="L4109" href="#L4109">4109</a><a id="L4110" href="#L4110">4110</a><a id="L4111" href="#L4111">4111</a><a id="L4112" href="#L4112">4112</a><a id="L4113" href="#L4113">4113</a><a id="L4114" href="#L4114">4114</a><a id="L4115" href="#L4115">4115</a><a id="L4116" href="#L4116">4116</a><a id="L4117" href="#L4117">4117</a><a id="L4118" href="#L4118">4118</a><a id="L4119" href="#L4119">4119</a><a id="L4120" href="#L4120">4120</a><a id="L4121" href="#L4121">4121</a><a id="L4122" href="#L4122">4122</a><a id="L4123" href="#L4123">4123</a><a id="L4124" href="#L4124">4124</a><a id="L4125" href="#L4125">4125</a><a id="L4126" href="#L4126">4126</a><a id="L4127" href="#L4127">4127</a><a id="L4128" href="#L4128">4128</a><a id="L4129" href="#L4129">4129</a><a id="L4130" href="#L4130">4130</a><a id="L4131" href="#L4131">4131</a><a id="L4132" href="#L4132">4132</a><a id="L4133" href="#L4133">4133</a><a id="L4134" href="#L4134">4134</a><a id="L4135" href="#L4135">4135</a><a id="L4136" href="#L4136">4136</a><a id="L4137" href="#L4137">4137</a><a id="L4138" href="#L4138">4138</a><a id="L4139" href="#L4139">4139</a><a id="L4140" href="#L4140">4140</a><a id="L4141" href="#L4141">4141</a><a id="L4142" href="#L4142">4142</a><a id="L4143" href="#L4143">4143</a><a id="L4144" href="#L4144">4144</a><a id="L4145" href="#L4145">4145</a><a id="L4146" href="#L4146">4146</a><a id="L4147" href="#L4147">4147</a><a id="L4148" href="#L4148">4148</a><a id="L4149" href="#L4149">4149</a><a id="L4150" href="#L4150">4150</a><a id="L4151" href="#L4151">4151</a><a id="L4152" href="#L4152">4152</a><a id="L4153" href="#L4153">4153</a><a id="L4154" href="#L4154">4154</a><a id="L4155" href="#L4155">4155</a><a id="L4156" href="#L4156">4156</a><a id="L4157" href="#L4157">4157</a><a id="L4158" href="#L4158">4158</a><a id="L4159" href="#L4159">4159</a><a id="L4160" href="#L4160">4160</a><a id="L4161" href="#L4161">4161</a><a id="L4162" href="#L4162">4162</a><a id="L4163" href="#L4163">4163</a><a id="L4164" href="#L4164">4164</a><a id="L4165" href="#L4165">4165</a><a id="L4166" href="#L4166">4166</a><a id="L4167" href="#L4167">4167</a><a id="L4168" href="#L4168">4168</a><a id="L4169" href="#L4169">4169</a><a id="L4170" href="#L4170">4170</a><a id="L4171" href="#L4171">4171</a><a id="L4172" href="#L4172">4172</a><a id="L4173" href="#L4173">4173</a><a id="L4174" href="#L4174">4174</a><a id="L4175" href="#L4175">4175</a><a id="L4176" href="#L4176">4176</a><a id="L4177" href="#L4177">4177</a><a id="L4178" href="#L4178">4178</a><a id="L4179" href="#L4179">4179</a><a id="L4180" href="#L4180">4180</a><a id="L4181" href="#L4181">4181</a><a id="L4182" href="#L4182">4182</a><a id="L4183" href="#L4183">4183</a><a id="L4184" href="#L4184">4184</a><a id="L4185" href="#L4185">4185</a><a id="L4186" href="#L4186">4186</a><a id="L4187" href="#L4187">4187</a><a id="L4188" href="#L4188">4188</a><a id="L4189" href="#L4189">4189</a><a id="L4190" href="#L4190">4190</a><a id="L4191" href="#L4191">4191</a><a id="L4192" href="#L4192">4192</a><a id="L4193" href="#L4193">4193</a><a id="L4194" href="#L4194">4194</a><a id="L4195" href="#L4195">4195</a><a id="L4196" href="#L4196">4196</a><a id="L4197" href="#L4197">4197</a><a id="L4198" href="#L4198">4198</a><a id="L4199" href="#L4199">4199</a><a id="L4200" href="#L4200">4200</a><a id="L4201" href="#L4201">4201</a><a id="L4202" href="#L4202">4202</a><a id="L4203" href="#L4203">4203</a><a id="L4204" href="#L4204">4204</a><a id="L4205" href="#L4205">4205</a><a id="L4206" href="#L4206">4206</a><a id="L4207" href="#L4207">4207</a><a id="L4208" href="#L4208">4208</a><a id="L4209" href="#L4209">4209</a><a id="L4210" href="#L4210">4210</a><a id="L4211" href="#L4211">4211</a><a id="L4212" href="#L4212">4212</a><a id="L4213" href="#L4213">4213</a><a id="L4214" href="#L4214">4214</a><a id="L4215" href="#L4215">4215</a><a id="L4216" href="#L4216">4216</a><a id="L4217" href="#L4217">4217</a><a id="L4218" href="#L4218">4218</a><a id="L4219" href="#L4219">4219</a><a id="L4220" href="#L4220">4220</a><a id="L4221" href="#L4221">4221</a><a id="L4222" href="#L4222">4222</a><a id="L4223" href="#L4223">4223</a><a id="L4224" href="#L4224">4224</a><a id="L4225" href="#L4225">4225</a><a id="L4226" href="#L4226">4226</a><a id="L4227" href="#L4227">4227</a><a id="L4228" href="#L4228">4228</a><a id="L4229" href="#L4229">4229</a><a id="L4230" href="#L4230">4230</a><a id="L4231" href="#L4231">4231</a><a id="L4232" href="#L4232">4232</a><a id="L4233" href="#L4233">4233</a><a id="L4234" href="#L4234">4234</a><a id="L4235" href="#L4235">4235</a><a id="L4236" href="#L4236">4236</a><a id="L4237" href="#L4237">4237</a><a id="L4238" href="#L4238">4238</a><a id="L4239" href="#L4239">4239</a><a id="L4240" href="#L4240">4240</a><a id="L4241" href="#L4241">4241</a><a id="L4242" href="#L4242">4242</a><a id="L4243" href="#L4243">4243</a><a id="L4244" href="#L4244">4244</a><a id="L4245" href="#L4245">4245</a><a id="L4246" href="#L4246">4246</a><a id="L4247" href="#L4247">4247</a><a id="L4248" href="#L4248">4248</a><a id="L4249" href="#L4249">4249</a><a id="L4250" href="#L4250">4250</a><a id="L4251" href="#L4251">4251</a><a id="L4252" href="#L4252">4252</a><a id="L4253" href="#L4253">4253</a><a id="L4254" href="#L4254">4254</a><a id="L4255" href="#L4255">4255</a><a id="L4256" href="#L4256">4256</a><a id="L4257" href="#L4257">4257</a><a id="L4258" href="#L4258">4258</a><a id="L4259" href="#L4259">4259</a><a id="L4260" href="#L4260">4260</a><a id="L4261" href="#L4261">4261</a><a id="L4262" href="#L4262">4262</a><a id="L4263" href="#L4263">4263</a><a id="L4264" href="#L4264">4264</a><a id="L4265" href="#L4265">4265</a><a id="L4266" href="#L4266">4266</a><a id="L4267" href="#L4267">4267</a><a id="L4268" href="#L4268">4268</a><a id="L4269" href="#L4269">4269</a><a id="L4270" href="#L4270">4270</a><a id="L4271" href="#L4271">4271</a><a id="L4272" href="#L4272">4272</a><a id="L4273" href="#L4273">4273</a><a id="L4274" href="#L4274">4274</a><a id="L4275" href="#L4275">4275</a><a id="L4276" href="#L4276">4276</a><a id="L4277" href="#L4277">4277</a><a id="L4278" href="#L4278">4278</a><a id="L4279" href="#L4279">4279</a><a id="L4280" href="#L4280">4280</a><a id="L4281" href="#L4281">4281</a><a id="L4282" href="#L4282">4282</a><a id="L4283" href="#L4283">4283</a><a id="L4284" href="#L4284">4284</a><a id="L4285" href="#L4285">4285</a><a id="L4286" href="#L4286">4286</a><a id="L4287" href="#L4287">4287</a><a id="L4288" href="#L4288">4288</a><a id="L4289" href="#L4289">4289</a><a id="L4290" href="#L4290">4290</a><a id="L4291" href="#L4291">4291</a><a id="L4292" href="#L4292">4292</a><a id="L4293" href="#L4293">4293</a><a id="L4294" href="#L4294">4294</a><a id="L4295" href="#L4295">4295</a><a id="L4296" href="#L4296">4296</a><a id="L4297" href="#L4297">4297</a><a id="L4298" href="#L4298">4298</a><a id="L4299" href="#L4299">4299</a><a id="L4300" href="#L4300">4300</a><a id="L4301" href="#L4301">4301</a><a id="L4302" href="#L4302">4302</a><a id="L4303" href="#L4303">4303</a><a id="L4304" href="#L4304">4304</a><a id="L4305" href="#L4305">4305</a><a id="L4306" href="#L4306">4306</a><a id="L4307" href="#L4307">4307</a><a id="L4308" href="#L4308">4308</a><a id="L4309" href="#L4309">4309</a><a id="L4310" href="#L4310">4310</a><a id="L4311" href="#L4311">4311</a><a id="L4312" href="#L4312">4312</a><a id="L4313" href="#L4313">4313</a><a id="L4314" href="#L4314">4314</a><a id="L4315" href="#L4315">4315</a><a id="L4316" href="#L4316">4316</a><a id="L4317" href="#L4317">4317</a><a id="L4318" href="#L4318">4318</a><a id="L4319" href="#L4319">4319</a><a id="L4320" href="#L4320">4320</a><a id="L4321" href="#L4321">4321</a><a id="L4322" href="#L4322">4322</a><a id="L4323" href="#L4323">4323</a><a id="L4324" href="#L4324">4324</a><a id="L4325" href="#L4325">4325</a><a id="L4326" href="#L4326">4326</a><a id="L4327" href="#L4327">4327</a><a id="L4328" href="#L4328">4328</a><a id="L4329" href="#L4329">4329</a><a id="L4330" href="#L4330">4330</a><a id="L4331" href="#L4331">4331</a><a id="L4332" href="#L4332">4332</a><a id="L4333" href="#L4333">4333</a><a id="L4334" href="#L4334">4334</a><a id="L4335" href="#L4335">4335</a><a id="L4336" href="#L4336">4336</a><a id="L4337" href="#L4337">4337</a><a id="L4338" href="#L4338">4338</a><a id="L4339" href="#L4339">4339</a><a id="L4340" href="#L4340">4340</a><a id="L4341" href="#L4341">4341</a><a id="L4342" href="#L4342">4342</a><a id="L4343" href="#L4343">4343</a><a id="L4344" href="#L4344">4344</a><a id="L4345" href="#L4345">4345</a><a id="L4346" href="#L4346">4346</a><a id="L4347" href="#L4347">4347</a><a id="L4348" href="#L4348">4348</a><a id="L4349" href="#L4349">4349</a><a id="L4350" href="#L4350">4350</a><a id="L4351" href="#L4351">4351</a><a id="L4352" href="#L4352">4352</a><a id="L4353" href="#L4353">4353</a><a id="L4354" href="#L4354">4354</a><a id="L4355" href="#L4355">4355</a><a id="L4356" href="#L4356">4356</a><a id="L4357" href="#L4357">4357</a><a id="L4358" href="#L4358">4358</a><a id="L4359" href="#L4359">4359</a><a id="L4360" href="#L4360">4360</a><a id="L4361" href="#L4361">4361</a><a id="L4362" href="#L4362">4362</a><a id="L4363" href="#L4363">4363</a><a id="L4364" href="#L4364">4364</a><a id="L4365" href="#L4365">4365</a><a id="L4366" href="#L4366">4366</a><a id="L4367" href="#L4367">4367</a><a id="L4368" href="#L4368">4368</a><a id="L4369" href="#L4369">4369</a><a id="L4370" href="#L4370">4370</a><a id="L4371" href="#L4371">4371</a><a id="L4372" href="#L4372">4372</a><a id="L4373" href="#L4373">4373</a><a id="L4374" href="#L4374">4374</a><a id="L4375" href="#L4375">4375</a><a id="L4376" href="#L4376">4376</a><a id="L4377" href="#L4377">4377</a><a id="L4378" href="#L4378">4378</a><a id="L4379" href="#L4379">4379</a><a id="L4380" href="#L4380">4380</a><a id="L4381" href="#L4381">4381</a><a id="L4382" href="#L4382">4382</a><a id="L4383" href="#L4383">4383</a><a id="L4384" href="#L4384">4384</a><a id="L4385" href="#L4385">4385</a><a id="L4386" href="#L4386">4386</a><a id="L4387" href="#L4387">4387</a><a id="L4388" href="#L4388">4388</a><a id="L4389" href="#L4389">4389</a><a id="L4390" href="#L4390">4390</a><a id="L4391" href="#L4391">4391</a><a id="L4392" href="#L4392">4392</a><a id="L4393" href="#L4393">4393</a><a id="L4394" href="#L4394">4394</a><a id="L4395" href="#L4395">4395</a><a id="L4396" href="#L4396">4396</a><a id="L4397" href="#L4397">4397</a><a id="L4398" href="#L4398">4398</a><a id="L4399" href="#L4399">4399</a><a id="L4400" href="#L4400">4400</a><a id="L4401" href="#L4401">4401</a><a id="L4402" href="#L4402">4402</a><a id="L4403" href="#L4403">4403</a><a id="L4404" href="#L4404">4404</a><a id="L4405" href="#L4405">4405</a><a id="L4406" href="#L4406">4406</a><a id="L4407" href="#L4407">4407</a><a id="L4408" href="#L4408">4408</a><a id="L4409" href="#L4409">4409</a><a id="L4410" href="#L4410">4410</a><a id="L4411" href="#L4411">4411</a><a id="L4412" href="#L4412">4412</a><a id="L4413" href="#L4413">4413</a><a id="L4414" href="#L4414">4414</a><a id="L4415" href="#L4415">4415</a><a id="L4416" href="#L4416">4416</a><a id="L4417" href="#L4417">4417</a><a id="L4418" href="#L4418">4418</a><a id="L4419" href="#L4419">4419</a><a id="L4420" href="#L4420">4420</a><a id="L4421" href="#L4421">4421</a><a id="L4422" href="#L4422">4422</a><a id="L4423" href="#L4423">4423</a><a id="L4424" href="#L4424">4424</a><a id="L4425" href="#L4425">4425</a><a id="L4426" href="#L4426">4426</a><a id="L4427" href="#L4427">4427</a><a id="L4428" href="#L4428">4428</a><a id="L4429" href="#L4429">4429</a><a id="L4430" href="#L4430">4430</a><a id="L4431" href="#L4431">4431</a><a id="L4432" href="#L4432">4432</a><a id="L4433" href="#L4433">4433</a><a id="L4434" href="#L4434">4434</a><a id="L4435" href="#L4435">4435</a><a id="L4436" href="#L4436">4436</a><a id="L4437" href="#L4437">4437</a><a id="L4438" href="#L4438">4438</a><a id="L4439" href="#L4439">4439</a><a id="L4440" href="#L4440">4440</a><a id="L4441" href="#L4441">4441</a><a id="L4442" href="#L4442">4442</a><a id="L4443" href="#L4443">4443</a><a id="L4444" href="#L4444">4444</a><a id="L4445" href="#L4445">4445</a><a id="L4446" href="#L4446">4446</a><a id="L4447" href="#L4447">4447</a><a id="L4448" href="#L4448">4448</a><a id="L4449" href="#L4449">4449</a><a id="L4450" href="#L4450">4450</a><a id="L4451" href="#L4451">4451</a><a id="L4452" href="#L4452">4452</a><a id="L4453" href="#L4453">4453</a><a id="L4454" href="#L4454">4454</a><a id="L4455" href="#L4455">4455</a><a id="L4456" href="#L4456">4456</a><a id="L4457" href="#L4457">4457</a><a id="L4458" href="#L4458">4458</a><a id="L4459" href="#L4459">4459</a><a id="L4460" href="#L4460">4460</a><a id="L4461" href="#L4461">4461</a><a id="L4462" href="#L4462">4462</a><a id="L4463" href="#L4463">4463</a><a id="L4464" href="#L4464">4464</a><a id="L4465" href="#L4465">4465</a><a id="L4466" href="#L4466">4466</a><a id="L4467" href="#L4467">4467</a><a id="L4468" href="#L4468">4468</a><a id="L4469" href="#L4469">4469</a><a id="L4470" href="#L4470">4470</a><a id="L4471" href="#L4471">4471</a><a id="L4472" href="#L4472">4472</a><a id="L4473" href="#L4473">4473</a><a id="L4474" href="#L4474">4474</a><a id="L4475" href="#L4475">4475</a><a id="L4476" href="#L4476">4476</a><a id="L4477" href="#L4477">4477</a><a id="L4478" href="#L4478">4478</a><a id="L4479" href="#L4479">4479</a><a id="L4480" href="#L4480">4480</a><a id="L4481" href="#L4481">4481</a><a id="L4482" href="#L4482">4482</a><a id="L4483" href="#L4483">4483</a><a id="L4484" href="#L4484">4484</a><a id="L4485" href="#L4485">4485</a><a id="L4486" href="#L4486">4486</a><a id="L4487" href="#L4487">4487</a><a id="L4488" href="#L4488">4488</a><a id="L4489" href="#L4489">4489</a><a id="L4490" href="#L4490">4490</a><a id="L4491" href="#L4491">4491</a><a id="L4492" href="#L4492">4492</a><a id="L4493" href="#L4493">4493</a><a id="L4494" href="#L4494">4494</a><a id="L4495" href="#L4495">4495</a><a id="L4496" href="#L4496">4496</a><a id="L4497" href="#L4497">4497</a><a id="L4498" href="#L4498">4498</a><a id="L4499" href="#L4499">4499</a><a id="L4500" href="#L4500">4500</a><a id="L4501" href="#L4501">4501</a><a id="L4502" href="#L4502">4502</a><a id="L4503" href="#L4503">4503</a><a id="L4504" href="#L4504">4504</a><a id="L4505" href="#L4505">4505</a><a id="L4506" href="#L4506">4506</a><a id="L4507" href="#L4507">4507</a><a id="L4508" href="#L4508">4508</a><a id="L4509" href="#L4509">4509</a><a id="L4510" href="#L4510">4510</a><a id="L4511" href="#L4511">4511</a><a id="L4512" href="#L4512">4512</a><a id="L4513" href="#L4513">4513</a><a id="L4514" href="#L4514">4514</a><a id="L4515" href="#L4515">4515</a><a id="L4516" href="#L4516">4516</a><a id="L4517" href="#L4517">4517</a><a id="L4518" href="#L4518">4518</a><a id="L4519" href="#L4519">4519</a><a id="L4520" href="#L4520">4520</a><a id="L4521" href="#L4521">4521</a><a id="L4522" href="#L4522">4522</a><a id="L4523" href="#L4523">4523</a><a id="L4524" href="#L4524">4524</a><a id="L4525" href="#L4525">4525</a><a id="L4526" href="#L4526">4526</a><a id="L4527" href="#L4527">4527</a><a id="L4528" href="#L4528">4528</a><a id="L4529" href="#L4529">4529</a><a id="L4530" href="#L4530">4530</a><a id="L4531" href="#L4531">4531</a><a id="L4532" href="#L4532">4532</a><a id="L4533" href="#L4533">4533</a><a id="L4534" href="#L4534">4534</a><a id="L4535" href="#L4535">4535</a><a id="L4536" href="#L4536">4536</a><a id="L4537" href="#L4537">4537</a><a id="L4538" href="#L4538">4538</a><a id="L4539" href="#L4539">4539</a><a id="L4540" href="#L4540">4540</a><a id="L4541" href="#L4541">4541</a><a id="L4542" href="#L4542">4542</a><a id="L4543" href="#L4543">4543</a><a id="L4544" href="#L4544">4544</a><a id="L4545" href="#L4545">4545</a><a id="L4546" href="#L4546">4546</a><a id="L4547" href="#L4547">4547</a><a id="L4548" href="#L4548">4548</a><a id="L4549" href="#L4549">4549</a><a id="L4550" href="#L4550">4550</a><a id="L4551" href="#L4551">4551</a><a id="L4552" href="#L4552">4552</a><a id="L4553" href="#L4553">4553</a><a id="L4554" href="#L4554">4554</a><a id="L4555" href="#L4555">4555</a><a id="L4556" href="#L4556">4556</a><a id="L4557" href="#L4557">4557</a><a id="L4558" href="#L4558">4558</a><a id="L4559" href="#L4559">4559</a><a id="L4560" href="#L4560">4560</a><a id="L4561" href="#L4561">4561</a><a id="L4562" href="#L4562">4562</a><a id="L4563" href="#L4563">4563</a><a id="L4564" href="#L4564">4564</a><a id="L4565" href="#L4565">4565</a><a id="L4566" href="#L4566">4566</a><a id="L4567" href="#L4567">4567</a><a id="L4568" href="#L4568">4568</a><a id="L4569" href="#L4569">4569</a><a id="L4570" href="#L4570">4570</a><a id="L4571" href="#L4571">4571</a><a id="L4572" href="#L4572">4572</a><a id="L4573" href="#L4573">4573</a><a id="L4574" href="#L4574">4574</a><a id="L4575" href="#L4575">4575</a><a id="L4576" href="#L4576">4576</a><a id="L4577" href="#L4577">4577</a><a id="L4578" href="#L4578">4578</a><a id="L4579" href="#L4579">4579</a><a id="L4580" href="#L4580">4580</a><a id="L4581" href="#L4581">4581</a><a id="L4582" href="#L4582">4582</a><a id="L4583" href="#L4583">4583</a><a id="L4584" href="#L4584">4584</a><a id="L4585" href="#L4585">4585</a><a id="L4586" href="#L4586">4586</a><a id="L4587" href="#L4587">4587</a><a id="L4588" href="#L4588">4588</a><a id="L4589" href="#L4589">4589</a><a id="L4590" href="#L4590">4590</a><a id="L4591" href="#L4591">4591</a><a id="L4592" href="#L4592">4592</a><a id="L4593" href="#L4593">4593</a><a id="L4594" href="#L4594">4594</a><a id="L4595" href="#L4595">4595</a><a id="L4596" href="#L4596">4596</a><a id="L4597" href="#L4597">4597</a><a id="L4598" href="#L4598">4598</a><a id="L4599" href="#L4599">4599</a><a id="L4600" href="#L4600">4600</a><a id="L4601" href="#L4601">4601</a><a id="L4602" href="#L4602">4602</a><a id="L4603" href="#L4603">4603</a><a id="L4604" href="#L4604">4604</a><a id="L4605" href="#L4605">4605</a><a id="L4606" href="#L4606">4606</a><a id="L4607" href="#L4607">4607</a><a id="L4608" href="#L4608">4608</a><a id="L4609" href="#L4609">4609</a><a id="L4610" href="#L4610">4610</a><a id="L4611" href="#L4611">4611</a><a id="L4612" href="#L4612">4612</a><a id="L4613" href="#L4613">4613</a><a id="L4614" href="#L4614">4614</a><a id="L4615" href="#L4615">4615</a><a id="L4616" href="#L4616">4616</a><a id="L4617" href="#L4617">4617</a><a id="L4618" href="#L4618">4618</a><a id="L4619" href="#L4619">4619</a><a id="L4620" href="#L4620">4620</a><a id="L4621" href="#L4621">4621</a><a id="L4622" href="#L4622">4622</a><a id="L4623" href="#L4623">4623</a><a id="L4624" href="#L4624">4624</a><a id="L4625" href="#L4625">4625</a><a id="L4626" href="#L4626">4626</a><a id="L4627" href="#L4627">4627</a><a id="L4628" href="#L4628">4628</a><a id="L4629" href="#L4629">4629</a><a id="L4630" href="#L4630">4630</a><a id="L4631" href="#L4631">4631</a><a id="L4632" href="#L4632">4632</a><a id="L4633" href="#L4633">4633</a><a id="L4634" href="#L4634">4634</a><a id="L4635" href="#L4635">4635</a><a id="L4636" href="#L4636">4636</a><a id="L4637" href="#L4637">4637</a><a id="L4638" href="#L4638">4638</a><a id="L4639" href="#L4639">4639</a><a id="L4640" href="#L4640">4640</a><a id="L4641" href="#L4641">4641</a><a id="L4642" href="#L4642">4642</a><a id="L4643" href="#L4643">4643</a><a id="L4644" href="#L4644">4644</a><a id="L4645" href="#L4645">4645</a><a id="L4646" href="#L4646">4646</a><a id="L4647" href="#L4647">4647</a><a id="L4648" href="#L4648">4648</a><a id="L4649" href="#L4649">4649</a><a id="L4650" href="#L4650">4650</a><a id="L4651" href="#L4651">4651</a><a id="L4652" href="#L4652">4652</a><a id="L4653" href="#L4653">4653</a><a id="L4654" href="#L4654">4654</a><a id="L4655" href="#L4655">4655</a><a id="L4656" href="#L4656">4656</a><a id="L4657" href="#L4657">4657</a><a id="L4658" href="#L4658">4658</a><a id="L4659" href="#L4659">4659</a><a id="L4660" href="#L4660">4660</a><a id="L4661" href="#L4661">4661</a><a id="L4662" href="#L4662">4662</a><a id="L4663" href="#L4663">4663</a><a id="L4664" href="#L4664">4664</a><a id="L4665" href="#L4665">4665</a><a id="L4666" href="#L4666">4666</a><a id="L4667" href="#L4667">4667</a><a id="L4668" href="#L4668">4668</a><a id="L4669" href="#L4669">4669</a><a id="L4670" href="#L4670">4670</a><a id="L4671" href="#L4671">4671</a><a id="L4672" href="#L4672">4672</a><a id="L4673" href="#L4673">4673</a><a id="L4674" href="#L4674">4674</a><a id="L4675" href="#L4675">4675</a><a id="L4676" href="#L4676">4676</a><a id="L4677" href="#L4677">4677</a><a id="L4678" href="#L4678">4678</a><a id="L4679" href="#L4679">4679</a><a id="L4680" href="#L4680">4680</a><a id="L4681" href="#L4681">4681</a><a id="L4682" href="#L4682">4682</a><a id="L4683" href="#L4683">4683</a><a id="L4684" href="#L4684">4684</a><a id="L4685" href="#L4685">4685</a><a id="L4686" href="#L4686">4686</a><a id="L4687" href="#L4687">4687</a><a id="L4688" href="#L4688">4688</a><a id="L4689" href="#L4689">4689</a><a id="L4690" href="#L4690">4690</a><a id="L4691" href="#L4691">4691</a><a id="L4692" href="#L4692">4692</a><a id="L4693" href="#L4693">4693</a><a id="L4694" href="#L4694">4694</a><a id="L4695" href="#L4695">4695</a><a id="L4696" href="#L4696">4696</a><a id="L4697" href="#L4697">4697</a><a id="L4698" href="#L4698">4698</a><a id="L4699" href="#L4699">4699</a><a id="L4700" href="#L4700">4700</a><a id="L4701" href="#L4701">4701</a><a id="L4702" href="#L4702">4702</a><a id="L4703" href="#L4703">4703</a><a id="L4704" href="#L4704">4704</a><a id="L4705" href="#L4705">4705</a><a id="L4706" href="#L4706">4706</a><a id="L4707" href="#L4707">4707</a><a id="L4708" href="#L4708">4708</a><a id="L4709" href="#L4709">4709</a><a id="L4710" href="#L4710">4710</a><a id="L4711" href="#L4711">4711</a><a id="L4712" href="#L4712">4712</a><a id="L4713" href="#L4713">4713</a><a id="L4714" href="#L4714">4714</a><a id="L4715" href="#L4715">4715</a><a id="L4716" href="#L4716">4716</a><a id="L4717" href="#L4717">4717</a><a id="L4718" href="#L4718">4718</a><a id="L4719" href="#L4719">4719</a><a id="L4720" href="#L4720">4720</a><a id="L4721" href="#L4721">4721</a><a id="L4722" href="#L4722">4722</a><a id="L4723" href="#L4723">4723</a><a id="L4724" href="#L4724">4724</a><a id="L4725" href="#L4725">4725</a><a id="L4726" href="#L4726">4726</a><a id="L4727" href="#L4727">4727</a><a id="L4728" href="#L4728">4728</a><a id="L4729" href="#L4729">4729</a><a id="L4730" href="#L4730">4730</a><a id="L4731" href="#L4731">4731</a><a id="L4732" href="#L4732">4732</a><a id="L4733" href="#L4733">4733</a><a id="L4734" href="#L4734">4734</a><a id="L4735" href="#L4735">4735</a><a id="L4736" href="#L4736">4736</a><a id="L4737" href="#L4737">4737</a><a id="L4738" href="#L4738">4738</a><a id="L4739" href="#L4739">4739</a><a id="L4740" href="#L4740">4740</a><a id="L4741" href="#L4741">4741</a><a id="L4742" href="#L4742">4742</a><a id="L4743" href="#L4743">4743</a><a id="L4744" href="#L4744">4744</a><a id="L4745" href="#L4745">4745</a><a id="L4746" href="#L4746">4746</a><a id="L4747" href="#L4747">4747</a><a id="L4748" href="#L4748">4748</a><a id="L4749" href="#L4749">4749</a><a id="L4750" href="#L4750">4750</a><a id="L4751" href="#L4751">4751</a><a id="L4752" href="#L4752">4752</a><a id="L4753" href="#L4753">4753</a><a id="L4754" href="#L4754">4754</a><a id="L4755" href="#L4755">4755</a><a id="L4756" href="#L4756">4756</a><a id="L4757" href="#L4757">4757</a><a id="L4758" href="#L4758">4758</a><a id="L4759" href="#L4759">4759</a><a id="L4760" href="#L4760">4760</a><a id="L4761" href="#L4761">4761</a><a id="L4762" href="#L4762">4762</a><a id="L4763" href="#L4763">4763</a><a id="L4764" href="#L4764">4764</a><a id="L4765" href="#L4765">4765</a><a id="L4766" href="#L4766">4766</a><a id="L4767" href="#L4767">4767</a><a id="L4768" href="#L4768">4768</a><a id="L4769" href="#L4769">4769</a><a id="L4770" href="#L4770">4770</a><a id="L4771" href="#L4771">4771</a><a id="L4772" href="#L4772">4772</a><a id="L4773" href="#L4773">4773</a><a id="L4774" href="#L4774">4774</a><a id="L4775" href="#L4775">4775</a><a id="L4776" href="#L4776">4776</a><a id="L4777" href="#L4777">4777</a><a id="L4778" href="#L4778">4778</a><a id="L4779" href="#L4779">4779</a><a id="L4780" href="#L4780">4780</a><a id="L4781" href="#L4781">4781</a><a id="L4782" href="#L4782">4782</a><a id="L4783" href="#L4783">4783</a></td>
<td><td><pre class="sourcecode">
<span class="bc">/*******************************************************************************

    copyright:      Copyright (c) 2007-2008 Jascha Wetzel. All rights reserved.

    license:        BSD style: $(LICENSE)

    version:        Initial release: Jan 2008

    authors:        Jascha Wetzel

    This is a regular expression compiler and interpreter based on the Tagged NFA/DFA method.

    The Regex class is not thread safe

    See &lt;a href="http://en.wikipedia.org/wiki/Regular_expression"&gt;Wikpedia's article on regular expressions&lt;/a&gt;
    for details on regular expressions in general.

    The used method implies, that the expressions are &lt;i&gt;regular&lt;/i&gt;, in the way language theory defines it,
    as opposed to what &amp;quot;regular expression&amp;quot; means in most implementations
    (e.g. PCRE or those from the standard libraries of Perl, Java or Python).
    The advantage of this method is it's performance, it's disadvantage is the inability to realize some features
    that Perl-like regular expressions have (e.g. back-references).
    See &lt;a href="http://swtch.com/~rsc/regexp/regexp1.html"&gt;&amp;quot;Regular Expression Matching Can Be Simple And Fast&amp;quot;&lt;/a&gt;
    for details on the differences.

    The time for matching a regular expression against an input string of length N is in O(M*N), where M depends on the
    number of matching brackets and the complexity of the expression. That is, M is constant wrt. the input
    and therefore matching is a linear-time process.

    The syntax of a regular expressions is as follows.
    &lt;i&gt;X&lt;/i&gt; and &lt;i&gt;Y&lt;/i&gt; stand for an arbitrary regular expression.

    &lt;table border=1 cellspacing=0 cellpadding=5&gt;
    &lt;caption&gt;Operators&lt;/caption&gt;
    $(TR $(TD X|Y) $(TD alternation, i.e. X or Y) )
    $(TR $(TD (X)) $(TD matching brackets - creates a sub-match) )
    $(TR $(TD (?X)) $(TD non-matching brackets - only groups X, no sub-match is created) )
    $(TR $(TD [Z]) $(TD character class specification, Z is a string of characters or character ranges, e.g. [a-zA-Z0-9_.\-]) )
    $(TR $(TD [^Z]) $(TD negated character class specification) )
    $(TR $(TD &amp;lt;X) $(TD lookbehind, X may be a single character or a character class) )
    $(TR $(TD &amp;gt;X) $(TD lookahead, X may be a single character or a character class) )
    $(TR $(TD ^) $(TD start of input or start of line) )
    $(TR $(TD $) $(TD end of input or end of line) )
    $(TR $(TD \b) $(TD start or end of word, equals (?&amp;lt;\s&amp;gt;\S|&amp;lt;\S&amp;gt;\s)) )
    $(TR $(TD \B) $(TD opposite of \b, equals (?&amp;lt;\S&amp;gt;\S|&amp;lt;\s&amp;gt;\s)) )
    &lt;/table&gt;

    &lt;table border=1 cellspacing=0 cellpadding=5&gt;
    &lt;caption&gt;Quantifiers&lt;/caption&gt;
    $(TR $(TD X?) $(TD zero or one) )
    $(TR $(TD X*) $(TD zero or more) )
    $(TR $(TD X+) $(TD one or more) )
    $(TR $(TD X{n,m}) $(TD at least n, at most m instances of X.&lt;br&gt;If n is missing, it's set to 0.&lt;br&gt;If m is missing, it is set to infinity.) )
    $(TR $(TD X??) $(TD non-greedy version of the above operators) )
    $(TR $(TD X*?) $(TD see above) )
    $(TR $(TD X+?) $(TD see above) )
    $(TR $(TD X{n,m}?) $(TD see above) )
    &lt;/table&gt;

    &lt;table border=1 cellspacing=0 cellpadding=5&gt;
    &lt;caption&gt;Pre-defined character classes&lt;/caption&gt;
    $(TR $(TD .) $(TD any printable character) )
    $(TR $(TD \s) $(TD whitespace) )
    $(TR $(TD \S) $(TD non-whitespace) )
    $(TR $(TD \w) $(TD alpha-numeric characters or underscore) )
    $(TR $(TD \W) $(TD opposite of \w) )
    $(TR $(TD \d) $(TD digits) )
    $(TR $(TD \D) $(TD non-digit) )
    &lt;/table&gt;

    Note that "alphanumeric" only applies to Latin-1.
*******************************************************************************/</span>
<span class="d Compound"><span class="d Module"><span class="k">module</span> <span class="i">tango</span>.<span class="i">text</span>.<span class="i">Regex</span>;</span>

<span class="d Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">io</span>.<span class="i">Stdout</span>;</span></span>

<span class="bc">/* *****************************************************************************
    A simple pair
*******************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">Pair</span><span class="o ">(<span class="o "><span class="i">T</span></span>)</span>
<span class="d Compound">{
    <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">Pair</span></span> <span class="i">opCall</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">a</span></span>, <span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">b</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Pair</span></span> <span class="i">p</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">a</span></span> = <span class="e Identifier"><span class="i">a</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">b</span></span> = <span class="e Identifier"><span class="i">b</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">p</span></span>;</span>
    }</span></span></span>

    <span class="d Union"><span class="k">union</span>
    <span class="d Compound">{
        <span class="d Struct"><span class="k">struct</span> <span class="d Compound">{
            <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">first</span>, <span class="i">second</span>;</span>
        }</span></span>
        <span class="d Struct"><span class="k">struct</span> <span class="d Compound">{
            <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">a</span>, <span class="i">b</span>;</span>
        }</span></span>
    }</span></span>
}</span></span></span></span>

<span class="bc">/* *****************************************************************************
    Double linked list
*******************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Class"><span class="k">class</span> <span class="i">List</span><span class="o ">(<span class="o "><span class="i">T</span></span>)</span>
<span class="d Compound">{
    <span class="d Class"><span class="k">class</span> <span class="i">Element</span>
    <span class="d Compound">{
        <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">value</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">Element</span></span> <span class="i">prev</span>,
                <span class="i">next</span>;</span>

        <span class="d Constructor"><span class="k">this</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">value</span></span> = <span class="e Identifier"><span class="i">v</span></span></span>;</span>
        }</span></span></span>
    }</span></span>

    <span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>  <span class="i">len</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">Element</span></span> <span class="i">head</span>,
            <span class="i">tail</span>;</span>

    <span class="d Function"><span class="t Identifier"><span class="i">List</span></span> <span class="i">opCatAssign</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">tail</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span> = <span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Element</span></span>(<span class="e Identifier"><span class="i">v</span></span>)</span></span></span>;</span></span>
        <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">next</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Element</span></span>(<span class="e Identifier"><span class="i">v</span></span>)</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">next</span></span>.<span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">tail</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span> = <span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">next</span></span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">len</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">List</span></span> <span class="i">insertAfter</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">w</span></span>, <span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">e</span></span></span>; <span class="e Address">&amp;<span class="e This"><span class="k">this</span></span></span>.<span class="e Identifier"><span class="i">elements</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">value</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">w</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">insertAfter</span></span>(<span class="i">e</span>, <span class="i">v</span>)</span>;</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">List</span></span> <span class="i">insertAfter</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Element</span></span> <span class="i">e</span></span>, <span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tmp</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Element</span></span>(<span class="e Identifier"><span class="i">v</span></span>)</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">e</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">next</span></span> = <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">next</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">next</span></span>.<span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">next</span></span> = <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">tail</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span> = <span class="e Identifier"><span class="i">tmp</span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">len</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">List</span></span> <span class="i">opCatAssign</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">List</span></span> <span class="i">l</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">tail</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span> = <span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">head</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span> = <span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">tail</span></span></span>;</span>
        }</span></span>
        <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">next</span></span> = <span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">head</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">next</span></span>.<span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">tail</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span> = <span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">tail</span></span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">len</span></span> += <span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">len</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">List</span></span> <span class="i">pushFront</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">head</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span> = <span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Element</span></span>(<span class="e Identifier"><span class="i">v</span></span>)</span></span></span>;</span></span>
        <span class="k">else</span>
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span>.<span class="e Identifier"><span class="i">prev</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Element</span></span>(<span class="e Identifier"><span class="i">v</span></span>)</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span>.<span class="e Identifier"><span class="i">prev</span></span>.<span class="e Identifier"><span class="i">next</span></span> = <span class="e Identifier"><span class="i">head</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span> = <span class="e Identifier"><span class="i">head</span></span>.<span class="e Identifier"><span class="i">prev</span></span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">len</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">List</span></span> <span class="i">insertBefore</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">w</span></span>, <span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">e</span></span></span>; <span class="e Address">&amp;<span class="e This"><span class="k">this</span></span></span>.<span class="e Identifier"><span class="i">elements</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">value</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">w</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">insertBefore</span></span>(<span class="i">e</span>, <span class="i">v</span>)</span>;</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">List</span></span> <span class="i">insertBefore</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Element</span></span> <span class="i">e</span></span>, <span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tmp</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Element</span></span>(<span class="e Identifier"><span class="i">v</span></span>)</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">prev</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">next</span></span> = <span class="e Identifier"><span class="i">e</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">prev</span></span>.<span class="e Identifier"><span class="i">next</span></span> = <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">head</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span> = <span class="e Identifier"><span class="i">tmp</span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">len</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">List</span></span> <span class="i">pushFront</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">List</span></span> <span class="i">l</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">head</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span> = <span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">head</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span> = <span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">tail</span></span></span>;</span>
        }</span></span>
        <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span>.<span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">tail</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span>.<span class="e Identifier"><span class="i">prev</span></span>.<span class="e Identifier"><span class="i">next</span></span> = <span class="e Identifier"><span class="i">head</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span> = <span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">head</span></span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">len</span></span> += <span class="e Identifier"><span class="i">l</span></span>.<span class="e Identifier"><span class="i">len</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">length</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">len</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">empty</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identity"><span class="e Identifier"><span class="i">head</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">clear</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span> = <span class="e Null"><span class="k">null</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span> = <span class="e Null"><span class="k">null</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">len</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">pop</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">remove</span></span>(<span class="i">tail</span>);</span></span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">remove</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Element</span></span> <span class="i">e</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span>;</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">prev</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">head</span></span> = <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">next</span></span></span>;</span></span>
        <span class="k">else</span>
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">prev</span></span>.<span class="e Identifier"><span class="i">next</span></span> = <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">next</span></span></span>;</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">next</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tail</span></span> = <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">prev</span></span></span>;</span></span>
        <span class="k">else</span>
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">next</span></span>.<span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">prev</span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">len</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">elements</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="t Identifier"><span class="i">Element</span></span></span>)</span></span> <span class="i">dg</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Element</span></span> <span class="i">e</span>=<span class="e Identifier"><span class="i">head</span></span>;</span></span> <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span>; <span class="e Assign"><span class="e Identifier"><span class="i">e</span></span> = <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">next</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">ret</span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span>(<span class="i">e</span>)</span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">ret</span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">elements_reverse</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="t Identifier"><span class="i">Element</span></span></span>)</span></span> <span class="i">dg</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Element</span></span> <span class="i">e</span>=<span class="e Identifier"><span class="i">tail</span></span>;</span></span> <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span>; <span class="e Assign"><span class="e Identifier"><span class="i">e</span></span> = <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">prev</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">ret</span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span>(<span class="i">e</span>)</span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">ret</span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opApply</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="t Identifier"><span class="i">T</span></span></span>)</span></span> <span class="i">dg</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Element</span></span> <span class="i">e</span>=<span class="e Identifier"><span class="i">head</span></span>;</span></span> <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span>; <span class="e Assign"><span class="e Identifier"><span class="i">e</span></span> = <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">next</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">ret</span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span>(<span class="i">e</span>.<span class="i">value</span>)</span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">ret</span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opApplyReverse</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="t Identifier"><span class="i">T</span></span></span>)</span></span> <span class="i">dg</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Element</span></span> <span class="i">e</span>=<span class="e Identifier"><span class="i">tail</span></span>;</span></span> <span class="e Identity"><span class="e Identifier"><span class="i">e</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span>; <span class="e Assign"><span class="e Identifier"><span class="i">e</span></span> = <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">prev</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">ret</span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span>(<span class="i">e</span>.<span class="i">value</span>)</span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">ret</span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ret</span></span>;</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span>
    }</span></span></span>
}</span></span></span></span>

<span class="bc">/* *****************************************************************************
    Stack based on dynamic array
*******************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">Stack</span><span class="o ">(<span class="o "><span class="i">T</span></span>)</span>
<span class="d Compound">{
    <span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>  <span class="i">_top</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span>     <span class="i">stack</span>;</span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">push</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">_top</span></span> &gt;= <span class="e Identifier"><span class="i">stack</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">stack</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">stack</span></span>.<span class="e Identifier"><span class="i">length</span></span>*<span class="e Int"><span class="n">2</span></span></span>+<span class="e Int"><span class="n">1</span></span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">stack</span></span>[<span class="e Identifier"><span class="i">_top</span></span>]</span> = <span class="e Identifier"><span class="i">v</span></span></span>;</span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">_top</span></span></span>;</span>
    }</span></span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">push</span></span> <span class="i">opCatAssign</span>;</span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">opCatAssign</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">vs</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">end</span> = <span class="e Plus"><span class="e Identifier"><span class="i">_top</span></span>+<span class="e Identifier"><span class="i">vs</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">end</span></span> &gt; <span class="e Identifier"><span class="i">stack</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">stack</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Mul"><span class="e Identifier"><span class="i">end</span></span>*<span class="e Int"><span class="n">2</span></span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">stack</span></span>[<span class="e Identifier"><span class="i">_top</span></span>..<span class="e Identifier"><span class="i">end</span></span>]</span> = <span class="e Identifier"><span class="i">vs</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">_top</span></span> = <span class="e Identifier"><span class="i">end</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">pop</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">num</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">_top</span></span>&gt;=<span class="e Identifier"><span class="i">num</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">_top</span></span> -= <span class="e Identifier"><span class="i">num</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">pop</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">_top</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>)</span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Index"><span class="e Identifier"><span class="i">stack</span></span>[<span class="e PreDecr">--<span class="e Identifier"><span class="i">_top</span></span></span>]</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">top</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">_top</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>)</span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Index"><span class="e Identifier"><span class="i">stack</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">_top</span></span>-<span class="e Int"><span class="n">1</span></span></span>]</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">topPtr</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">_top</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>)</span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Index"><span class="e Address">&amp;<span class="e Identifier"><span class="i">stack</span></span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">_top</span></span>-<span class="e Int"><span class="n">1</span></span></span>]</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">empty</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Identifier"><span class="i">_top</span></span> == <span class="e Int"><span class="n">0</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">clear</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">_top</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">length</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">_top</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">array</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">stack</span></span>[<span class="e Int"><span class="n">0</span></span>..<span class="e Identifier"><span class="i">_top</span></span>]</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">opIndex</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">i</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Index"><span class="e Identifier"><span class="i">stack</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">Stack</span></span> <span class="i">dup</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Stack</span></span> <span class="i">s</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">_top</span></span> = <span class="e Identifier"><span class="i">_top</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">stack</span></span> = <span class="e Identifier"><span class="i">stack</span></span>.<span class="e Identifier"><span class="i">dup</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">s</span></span>;</span>
    }</span></span></span>
}</span></span></span></span>

<span class="bc">/* ************************************************************************************************
    Set container based on assoc array
**************************************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">Set</span><span class="o ">(<span class="o "><span class="i">T</span></span>)</span>
<span class="d Compound">{
    <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span><span class="t Array">[<span class="t Identifier"><span class="i">T</span></span>]</span> <span class="i">data</span>;</span>

    <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">Set</span></span> <span class="i">opCall</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Set</span></span> <span class="i">s</span>;</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">s</span></span>;</span>
    }</span></span></span>

    <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">Set</span></span> <span class="i">opCall</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Set</span></span> <span class="i">s</span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">s</span></span> ~= <span class="e Identifier"><span class="i">v</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">s</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">opAddAssign</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">data</span></span>[<span class="e Identifier"><span class="i">v</span></span>]</span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">opAddAssign</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Set</span></span> <span class="i">s</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">v</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">elements</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">data</span></span>[<span class="e Identifier"><span class="i">v</span></span>]</span> = <span class="e Bool"><span class="k">true</span></span></span>;</span></span></span>
    }</span></span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">opAddAssign</span></span> <span class="i">opCatAssign</span>;</span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">length</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">data</span></span>.<span class="e Identifier"><span class="i">length</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">elements</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">data</span></span>.<span class="e Identifier"><span class="i">keys</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">remove</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Paren">(<span class="e In"><span class="e Identifier"><span class="i">v</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">data</span></span></span>)</span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">data</span></span>.<span class="t Identifier"><span class="i">remove</span></span>(<span class="i">v</span>);</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">contains</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identity"><span class="e Paren">(<span class="e In"><span class="e Identifier"><span class="i">v</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">data</span></span></span>)</span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">contains</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Set</span></span> <span class="i">s</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Set</span></span> <span class="i">tmp</span> = <span class="e Minus"><span class="e Identifier"><span class="i">s</span></span> - <span class="e This"><span class="k">this</span></span></span>;</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">empty</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">empty</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Identifier"><span class="i">data</span></span>.<span class="e Identifier"><span class="i">length</span></span>==<span class="e Int"><span class="n">0</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">Set</span></span> <span class="i">opSub</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Set</span></span> <span class="i">s</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Set</span></span> <span class="i">res</span> = <span class="e Identifier"><span class="i">dup</span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">v</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">elements</span></span> )
            <span class="s Scope"><span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">res</span></span>.<span class="t Identifier"><span class="i">remove</span></span>(<span class="i">v</span>);</span></span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">Set</span></span> <span class="i">dup</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Set</span></span> <span class="i">s</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">v</span></span></span>; <span class="e Identifier"><span class="i">data</span></span>.<span class="e Identifier"><span class="i">keys</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Identifier"><span class="i">v</span></span>]</span> = <span class="e Bool"><span class="k">true</span></span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">s</span></span>;</span>
    }</span></span></span>
}</span></span></span></span>

<span class="bc">/* ************************************************************************************************

**************************************************************************************************/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">quickSort</span><span class="o ">(<span class="o "><span class="i">T</span></span>)</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">a</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">quickSort</span></span>(<span class="i">a</span>,<span class="k">cast</span>(<span class="i">size_t</span>)<span class="n">0</span>,<span class="i">a</span>.<span class="i">length</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">quickSort</span><span class="o ">(<span class="o "><span class="i">T</span></span>)</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">a</span></span>, <span class="o "><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">l</span></span>, <span class="o "><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">t</span>;</span></span>
    <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">i</span> = <span class="e Minus"><span class="e Identifier"><span class="i">r</span></span>-<span class="e Identifier"><span class="i">l</span></span></span>;</span></span>
    <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Int"><span class="n">3</span></span></span> )
    <span class="s Scope"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Int"><span class="n">2</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span>;</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">l</span></span>]</span> &lt; <span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">l</span></span>+<span class="e Int"><span class="n">1</span></span></span>]</span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">l</span></span>]</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">l</span></span>]</span> = <span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">l</span></span>+<span class="e Int"><span class="n">1</span></span></span>]</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">l</span></span>+<span class="e Int"><span class="n">1</span></span></span>]</span> = <span class="e Identifier"><span class="i">t</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span>;</span>
    }</span></span></span>

    <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">p</span> = <span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">l</span></span>]</span>;</span></span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">i</span></span> = <span class="e Identifier"><span class="i">l</span></span></span>;</span>
    <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">j</span> = <span class="e Identifier"><span class="i">r</span></span>;</span></span>

    <span class="s While"><span class="k">while</span> ( <span class="e Bool"><span class="k">true</span></span> )
    <span class="s Scope"><span class="s Compound">{
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>;</span>
        <span class="s For"><span class="k">for</span> ( ; <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">j</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span> &lt; <span class="e Identifier"><span class="i">p</span></span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span> ) <span class="s Scope"><span class="s Compound">{}</span></span></span>
        <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">j</span></span></span>;</span>
        <span class="s For"><span class="k">for</span> ( ; <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">j</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">j</span></span>]</span> &gt;= <span class="e Identifier"><span class="i">p</span></span></span></span>; <span class="e PreDecr">--<span class="e Identifier"><span class="i">j</span></span></span> ) <span class="s Scope"><span class="s Compound">{}</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &gt;= <span class="e Identifier"><span class="i">j</span></span></span> )
            <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span> = <span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">j</span></span>]</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">j</span></span>]</span> = <span class="e Identifier"><span class="i">t</span></span></span>;</span>
    }</span></span></span>
    <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">i</span></span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">l</span></span>]</span> = <span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span> = <span class="e Identifier"><span class="i">p</span></span></span>;</span>

    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">quickSort</span></span>(<span class="i">a</span>, <span class="i">l</span>, <span class="i">i</span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">quickSort</span></span>(<span class="i">a</span>, <span class="i">i</span>+<span class="n">1</span>, <span class="i">r</span>)</span>;</span>
}</span></span></span></span></span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">Math</span>;</span>

<span class="bc">/* ************************************************************************************************
    A range of characters
**************************************************************************************************/</span>
<span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">CharRange</span><span class="o ">(<span class="o "><span class="i">char_t</span></span>)</span>
<span class="d Compound">{
    <span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span>  <span class="i">l_</span>, <span class="i">r_</span>;</span>

    <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">opCall</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">c</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">cr</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Identifier"><span class="i">c</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Identifier"><span class="i">c</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">cr</span></span>;</span>
    }</span></span></span>

    <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">opCall</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">a</span></span>, <span class="o "><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">b</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">cr</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">min</span></span>(<span class="i">a</span>,<span class="i">b</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">a</span>,<span class="i">b</span>)</span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">cr</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">l</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">l_</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">r</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">r_</span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Compares the ranges according to their beginning.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opCmp</span><span class="o ">(<span class="o "><span class="k">const</span> <span class="k">ref</span> <span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">cr</span></span>)</span> <span class="k">const</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">l_</span></span> == <span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">l_</span></span> &lt; <span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">1</span></span>;</span>
    }</span></span></span>


    <span class="d StorageClass"><span class="k">const</span></span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">opEquals</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="k">const</span> <span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">cr</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">l_</span></span> == <span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">r_</span></span> == <span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">contains</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">c</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &gt;= <span class="e Identifier"><span class="i">l_</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Identifier"><span class="i">r_</span></span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">contains</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">cr</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">l_</span></span> &lt;= <span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">r_</span></span> &gt;= <span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">intersects</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">cr</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">r_</span></span> &gt;= <span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">l_</span></span> &lt;= <span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">intersect</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">cr</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">intersects</span></span>(<span class="i">cr</span>)</span>)</span>;</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">ir</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ir</span></span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">l_</span>, <span class="i">cr</span>.<span class="i">l_</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ir</span></span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">min</span></span>(<span class="i">r_</span>, <span class="i">cr</span>.<span class="i">r_</span>)</span></span>;</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">ir</span></span>.<span class="e Identifier"><span class="i">l_</span></span> &gt; <span class="e Identifier"><span class="i">ir</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ir</span></span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Assign"><span class="e Identifier"><span class="i">ir</span></span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Identifier"><span class="i">char_t</span></span>.<span class="e Identifier"><span class="i">min</span></span></span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ir</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">CharRange</span></span><span class="t Array">[]</span> <span class="i">subtract</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">cr</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">CharRange</span></span><span class="t Array">[]</span> <span class="i">sr</span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">contains</span></span>(<span class="k">this</span>)</span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">sr</span></span>;</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">intersects</span></span></span>(<span class="i">cr</span>)</span> )
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">sr</span></span> ~= <span class="e This"><span class="k">this</span></span></span>;</span></span>
        <span class="k">else</span>
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">CharRange</span></span> <span class="i">d</span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">contains</span></span>(<span class="i">cr</span>)</span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Identifier"><span class="i">l_</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">char_t</span></span>)<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span>-<span class="e Int"><span class="n">1</span></span></span>)</span></span></span>;</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">l_</span></span> &lt;= <span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">sr</span></span> ~= <span class="e Identifier"><span class="i">d</span></span></span>;</span></span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">char_t</span></span>)<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span>+<span class="e Int"><span class="n">1</span></span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Identifier"><span class="i">r_</span></span></span>;</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">l_</span></span> &lt;= <span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">sr</span></span> ~= <span class="e Identifier"><span class="i">d</span></span></span>;</span></span></span>
            }</span></span>
            <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span> &gt; <span class="e Identifier"><span class="i">l_</span></span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">char_t</span></span>)<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span>+<span class="e Int"><span class="n">1</span></span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Identifier"><span class="i">r_</span></span></span>;</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">l_</span></span> &lt;= <span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">sr</span></span> ~= <span class="e Identifier"><span class="i">d</span></span></span>;</span></span></span>
            }</span></span>
            <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span> &lt; <span class="e Identifier"><span class="i">r_</span></span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Identifier"><span class="i">l_</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">char_t</span></span>)<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span>-<span class="e Int"><span class="n">1</span></span></span>)</span></span></span>;</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">l_</span></span> &lt;= <span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">sr</span></span> ~= <span class="e Identifier"><span class="i">d</span></span></span>;</span></span></span>
            }</span></span></span></span></span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">sr</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">string</span></span> <span class="i">toString</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span> <span class="i">str</span>;</span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">l_</span></span> == <span class="e Identifier"><span class="i">r_</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">l_</span></span> &gt; <span class="e Int"><span class="n">0x20</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">l_</span></span> &lt; <span class="e Int"><span class="n">0x7f</span></span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"'{}'"</span>, <span class="i">l_</span>)</span>.<span class="e Identifier"><span class="i">idup</span></span></span>;</span></span>
            <span class="k">else</span>
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"({:x})"</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">l_</span>)</span>.<span class="e Identifier"><span class="i">idup</span></span></span>;</span></span></span>
        }</span></span>
        <span class="k">else</span>
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">l_</span></span> &gt; <span class="e Int"><span class="n">0x20</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">l_</span></span> &lt; <span class="e Int"><span class="n">0x7f</span></span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"'{}'"</span>, <span class="i">l_</span>)</span>.<span class="e Identifier"><span class="i">idup</span></span></span>;</span></span>
            <span class="k">else</span>
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"({:x})"</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">l_</span>)</span>.<span class="e Identifier"><span class="i">idup</span></span></span>;</span></span></span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">str</span></span> ~= <span class="e String"><span class="sl">"-"</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">r_</span></span> &gt; <span class="e Int"><span class="n">0x20</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">r_</span></span> &lt; <span class="e Int"><span class="n">0x7f</span></span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">str</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"'{}'"</span>, <span class="i">r_</span>)</span>.<span class="e Identifier"><span class="i">idup</span></span></span>;</span></span>
            <span class="k">else</span>
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">str</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"({:x})"</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">r_</span>)</span>.<span class="e Identifier"><span class="i">idup</span></span></span>;</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">str</span></span>;</span>
    }</span></span></span>
}</span></span></span></span>

<span class="bc">/* ************************************************************************************************
    Represents a class of characters as used in regular expressions (e.g. [0-9a-z], etc.)
**************************************************************************************************/</span>
<span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">CharClass</span><span class="o ">(<span class="o "><span class="i">char_t</span></span>)</span>
<span class="d Compound">{
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharRange</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span> <span class="i">range_t</span>;</span></span>

    <span class="lc">//---------------------------------------------------------------------------------------------</span>
    <span class="lc">// pre-defined character classes</span>
    <span class="d StorageClass"><span class="k">static</span></span> <span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>
        <span class="i">line_startend</span> = <span class="e StructInit">{<span class="i">parts</span>: <span class="e ArrayInit">[
            <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x00</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x00</span></span>}</span>,
            <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x0a</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x0a</span></span>}</span>,
            <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x13</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x13</span></span>}</span>
        ]</span>}</span>,
        <span class="i">digit</span> = <span class="e StructInit">{<span class="i">parts</span>: <span class="e ArrayInit">[
            <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x30</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x39</span></span>}</span>
        ]</span>}</span>,
        <span class="i">whitespace</span> = <span class="e StructInit">{<span class="i">parts</span>: <span class="e ArrayInit">[
            <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x09</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x09</span></span>}</span>,
            <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x0a</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x0a</span></span>}</span>,
            <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x0b</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x0b</span></span>}</span>,
            <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x13</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x13</span></span>}</span>,
            <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x14</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x14</span></span>}</span>,
            <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x20</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x20</span></span>}</span>
        ]</span>}</span>;</span>

    <span class="lc">// 8bit classes</span>
    <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> ( <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">char_t</span></span> == <span class="t Integral"><span class="k">char</span></span>)</span> )
    <span class="d Compound">{
        <span class="d StorageClass"><span class="k">static</span></span> <span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>
            <span class="i">any_char</span> = <span class="e StructInit">{<span class="i">parts</span>: <span class="e ArrayInit">[
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x01</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0xff</span></span>}</span>
            ]</span>}</span>,
            <span class="i">dot_oper</span> = <span class="e StructInit">{<span class="i">parts</span>: <span class="e ArrayInit">[
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x01</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0xff</span></span>}</span>
            ]</span>}</span>,
            <span class="i">alphanum_</span> = <span class="e StructInit">{<span class="i">parts</span>: <span class="e ArrayInit">[
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x30</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x39</span></span>}</span>,
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x41</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x5a</span></span>}</span>,
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x5f</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x5f</span></span>}</span>,
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x61</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x7a</span></span>}</span>
            ]</span>}</span>;</span>
    }</span></span>
    <span class="lc">// 16bit and 32bit classes</span>
    <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> ( <span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">char_t</span></span> == <span class="t Integral"><span class="k">wchar</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">char_t</span></span> == <span class="t Integral"><span class="k">dchar</span></span>)</span></span> )
    <span class="d Compound">{
        <span class="d StorageClass"><span class="k">static</span></span> <span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>
            <span class="i">any_char</span> = <span class="e StructInit">{<span class="i">parts</span>: <span class="e ArrayInit">[
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x0001</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0xffff</span></span>}</span>
            ]</span>}</span>,
            <span class="i">dot_oper</span> = <span class="e StructInit">{<span class="i">parts</span>: <span class="e ArrayInit">[
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x0001</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0xffff</span></span>}</span>
            ]</span>}</span>,
            <span class="i">alphanum_</span> = <span class="e StructInit">{<span class="i">parts</span>: <span class="e ArrayInit">[
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x30</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x39</span></span>}</span>,
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x41</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x5a</span></span>}</span>,
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x5f</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x5f</span></span>}</span>,
                <span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x61</span></span>, <span class="i">r_</span>:<span class="e Int"><span class="n">0x7a</span></span>}</span>
            ]</span>}</span>;</span>
    }</span></span>

    <span class="lc">//---------------------------------------------------------------------------------------------</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">range_t</span></span><span class="t Array">[]</span> <span class="i">parts</span>;</span>

    <span class="d Invariant"><span class="k">invariant</span>()
    <span class="s FuncBody"><span class="s Compound">{
<span class="lc">//        foreach ( i, p; parts )</span>
<span class="lc">//            assert(p.l_&lt;=p.r_, Int.toString(i)~": "~Int.toString(p.l_)~" &gt; "~Int.toString(p.r_));</span>
    }</span></span></span>

    <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">CharClass</span></span> <span class="i">opCall</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">CharClass</span></span>)</span> <span class="i">cc</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">CharClass</span></span> <span class="i">ncc</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ncc</span></span>.<span class="e Identifier"><span class="i">parts</span></span> = <span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">dup</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ncc</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opCmp</span><span class="o ">(<span class="o "><span class="k">const</span> <span class="k">ref</span> <span class="t Identifier"><span class="i">CharClass</span></span> <span class="i">cc</span></span>)</span> <span class="k">const</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt; <span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>;</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">1</span></span>;</span></span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">i</span></span>, <span class="o "><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">parts</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Equal"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">l_</span></span> != <span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>.<span class="e Identifier"><span class="i">l_</span></span></span> || <span class="e Equal"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">r_</span></span> != <span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>.<span class="e Identifier"><span class="i">r_</span></span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">1</span></span>;</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">empty</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt;= <span class="e Int"><span class="n">0</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">matches</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">c</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">parts</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">contains</span></span>(<span class="i">c</span>)</span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">CharClass</span></span> <span class="i">intersect</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">CharClass</span></span> <span class="i">cc</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">CharClass</span></span> <span class="i">ic</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">parts</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cp</span></span></span>; <span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">parts</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">intersects</span></span>(<span class="i">cp</span>)</span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">ic</span></span>.<span class="e Identifier"><span class="i">parts</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">intersect</span></span>(<span class="i">cp</span>)</span></span>;</span></span></span>
            }</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">ic</span></span>;</span>
    }</span></span></span>

    <span class="lc">// requires the class to be optimized</span>
    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">contains</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">range_t</span></span> <span class="i">cr</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">parts</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">contains</span></span>(<span class="i">cr</span>)</span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
    }</span></span></span>

    <span class="lc">// requires the class to be optimized</span>
    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">contains</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">CharClass</span></span> <span class="i">cc</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Labeled"><span class="i">Louter</span>: <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">parts</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p2</span></span></span>; <span class="e Identifier"><span class="i">parts</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">p2</span></span>.<span class="e Identifier"><span class="i">contains</span></span>(<span class="i">p</span>)</span> )
                    <span class="s Scope"><span class="s Continue"><span class="k">continue</span> <span class="i">Louter</span>;</span></span></span>
            }</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
        }</span></span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">subtract</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">CharClass</span></span> <span class="i">cc</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">add</span></span>(<span class="i">cc</span>);</span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">add</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">CharClass</span></span> <span class="i">cc</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">parts</span></span> ~= <span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">parts</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">add</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">range_t</span></span> <span class="i">cr</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">parts</span></span> ~= <span class="e Identifier"><span class="i">cr</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">add</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">c</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">parts</span></span> ~= <span class="e Call"><span class="e TmplInstance"><span class="i">CharRange</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>(<span class="i">c</span>)</span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Requires the CharClass to be optimized.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">negate</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span>  <span class="i">start</span> = <span class="e Identifier"><span class="i">char_t</span></span>.<span class="e Identifier"><span class="i">min</span></span>;</span></span>

        <span class="lc">// first part touches left boundary of value range</span>
        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">l_</span></span> == <span class="e Identifier"><span class="i">start</span></span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">r_</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">start</span></span> &lt; <span class="e Identifier"><span class="i">char_t</span></span>.<span class="e Identifier"><span class="i">max</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">start</span></span></span>;</span></span></span>

            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">i</span></span>, <span class="o "><span class="k">ref</span> <span class="i">cr</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Identifier"><span class="i">start</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">char_t</span></span>)<span class="e Paren">(<span class="e Minus"><span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">i</span></span>+<span class="e Int"><span class="n">1</span></span></span>]</span>.<span class="e Identifier"><span class="i">l_</span></span>-<span class="e Int"><span class="n">1</span></span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">i</span></span>+<span class="e Int"><span class="n">1</span></span></span>]</span>.<span class="e Identifier"><span class="i">r_</span></span></span>;</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">start</span></span> &lt; <span class="e Identifier"><span class="i">char_t</span></span>.<span class="e Identifier"><span class="i">max</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">start</span></span></span>;</span></span></span>
            }</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">start</span></span> != <span class="e Identifier"><span class="i">char_t</span></span>.<span class="e Identifier"><span class="i">max</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Identifier"><span class="i">start</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Identifier"><span class="i">char_t</span></span>.<span class="e Identifier"><span class="i">max</span></span></span>;</span>
            }</span></span>
            <span class="k">else</span>
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Minus"><span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span>-<span class="e Int"><span class="n">1</span></span></span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span>;</span>
        }</span></span></span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">i</span></span>, <span class="o "><span class="k">ref</span> <span class="i">cr</span></span></span>; <span class="e Identifier"><span class="i">parts</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">tmp</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">char_t</span></span>)<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span>-<span class="e Int"><span class="n">1</span></span></span>)</span></span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Identifier"><span class="i">start</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">start</span></span> &lt; <span class="e Identifier"><span class="i">char_t</span></span>.<span class="e Identifier"><span class="i">max</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">start</span></span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>
        }</span></span></span>

        <span class="lc">// last part does not touch right boundary</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">start</span></span> != <span class="e Identifier"><span class="i">char_t</span></span>.<span class="e Identifier"><span class="i">max</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">parts</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">range_t</span></span>(<span class="i">start</span>, <span class="i">char_t</span>.<span class="i">max</span>)</span></span>;</span></span></span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">optimize</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">empty</span></span>()</span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span>;</span></span></span>

        <span class="s Expression"><span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">sort</span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">i</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Int"><span class="n">1</span></span> .. <span class="e Dollar">$</span>]</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">l_</span></span> &gt; <span class="e Plus"><span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>.<span class="e Identifier"><span class="i">r_</span></span>+<span class="e Int"><span class="n">1</span></span></span></span> ) <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">l_</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span>;</span>
                <span class="s Continue"><span class="k">continue</span>;</span>
            }</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">p</span>.<span class="i">r_</span>, <span class="i">parts</span>[<span class="i">i</span>].<span class="i">r_</span>)</span></span>;</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Index"><span class="e Identifier"><span class="i">parts</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>.<span class="e Identifier"><span class="i">r_</span></span> &gt;= <span class="e Identifier"><span class="i">char_t</span></span>.<span class="e Identifier"><span class="i">max</span></span></span> )
                <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
        }</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">i</span></span>+<span class="e Int"><span class="n">1</span></span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">string</span></span> <span class="i">toString</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span> <span class="i">str</span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">str</span></span> ~= <span class="e String"><span class="sl">"["</span></span></span>;</span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">parts</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">str</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span></span>;</span></span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">str</span></span> ~= <span class="e String"><span class="sl">"]"</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">str</span></span>;</span>
    }</span></span></span>
}</span></span></span></span>

<span class="d Debug"><span class="k">debug</span>(<span class="i">UnitTest</span>)
<span class="d Compound">{
<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d StorageClass"><span class="k">static</span></span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Integral"><span class="k">char</span></span>)</span></span> <span class="i">cc</span> = <span class="e StructInit">{ <span class="i">parts</span>: <span class="e ArrayInit">[<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">10</span></span>}</span>,<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">6</span></span>}</span>,<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">5</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">12</span></span>}</span>,<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">12</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">17</span></span>}</span>,<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">20</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">100</span></span>}</span>]</span> }</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>, <span class="e String"><span class="sl">"[(0)-(a)(0)-(6)(5)-(c)(c)-(11)(14)-'d']"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(0)-(11)(14)-'d']"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">" [(12)-(13)'e'-(ff)]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(0)-(11)(14)-'d']"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(12)-(13)'e'-(ff)]"</span></span>)</span>;</span>

    <span class="s Declaration"><span class="d StorageClass"><span class="k">static</span></span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Integral"><span class="k">char</span></span>)</span></span> <span class="i">cc2</span> = <span class="e StructInit">{ <span class="i">parts</span>: <span class="e ArrayInit">[]</span> }</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc2</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc2</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(0)-(ff)]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc2</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(0)-(ff)]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc2</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[]"</span></span>)</span>;</span>

    <span class="s Declaration"><span class="d StorageClass"><span class="k">static</span></span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Integral"><span class="k">char</span></span>)</span></span> <span class="i">cc3</span> = <span class="e StructInit">{ <span class="i">parts</span>: <span class="e ArrayInit">[<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">100</span></span>}</span>,<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">200</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">0xff</span></span>}</span>,]</span> }</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc3</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>, <span class="e String"><span class="sl">"[(0)-'d'(c8)-(ff)]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc3</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"['e'-(c7)]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc3</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(0)-'d'(c8)-(ff)]"</span></span>)</span>;</span>

    <span class="s Declaration"><span class="d StorageClass"><span class="k">static</span></span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Integral"><span class="k">char</span></span>)</span></span> <span class="i">cc4</span> = <span class="e StructInit">{ <span class="i">parts</span>: <span class="e ArrayInit">[<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">200</span></span>}</span>,<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">100</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">0xff</span></span>}</span>,]</span> }</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(0)-(c8)'d'-(ff)]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc4</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(9)-(13)(20)-'~'(a0)-(ff)(100)-(17f)(180)-(24f)(20a3)-(20b5)]"</span></span>)</span>;</span>

    <span class="s Declaration"><span class="d StorageClass"><span class="k">static</span></span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Integral"><span class="k">dchar</span></span>)</span></span> <span class="i">cc5</span> = <span class="e StructInit">{ <span class="i">parts</span>: <span class="e ArrayInit">[<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x9</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">0x13</span></span>}</span>,<span class="e StructInit">{<span class="e Int"><span class="n">0x20</span></span>,<span class="i">r_</span>:<span class="e Char"><span class="cl">'~'</span></span>}</span>,<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0xa0</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">0xff</span></span>}</span>,<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x100</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">0x17f</span></span>}</span>,<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x180</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">0x24f</span></span>}</span>,<span class="e StructInit">{<span class="i">l_</span>:<span class="e Int"><span class="n">0x20a3</span></span>,<span class="i">r_</span>:<span class="e Int"><span class="n">0x20b5</span></span>}</span>]</span> }</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc5</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(9)-(13)(20)-'~'(a0)-(24f)(20a3)-(20b5)]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc5</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(0)-(8)(14)-(1f)(7f)-(9f)(250)-(20a2)(20b6)-(10ffff)]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc5</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(0)-(8)(14)-(1f)(7f)-(9f)(250)-(20a2)(20b6)-(10ffff)]"</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc5</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>,  <span class="e String"><span class="sl">"[(9)-(13)(20)-'~'(a0)-(24f)(20a3)-(20b5)]"</span></span>)</span>;</span>
}</span></span></span>
}</span></span>

<span class="bc">/* ************************************************************************************************

**************************************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">Predicate</span><span class="o ">(<span class="o "><span class="i">char_t</span></span>)</span>
<span class="d Compound">{
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span>       <span class="i">string_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>    <span class="i">cc_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharRange</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>    <span class="i">cr_t</span>;</span></span>

    <span class="lc">// generic data</span>
    <span class="d Enum"><span class="k">enum</span> <span class="i">Type</span> {
        <span class="d EnumMember"><span class="i">consume</span></span>, <span class="d EnumMember"><span class="i">epsilon</span></span>, <span class="d EnumMember"><span class="i">lookahead</span></span>, <span class="d EnumMember"><span class="i">lookbehind</span></span>
    }</span>

    <span class="d Variables"><span class="t Identifier"><span class="i">cc_t</span></span>    <span class="i">input</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">Type</span></span>    <span class="i">type</span>;</span>

    <span class="lc">// data for compiled predicates</span>
    <span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span>  <span class="i">MAX_BITMAP_LENGTH</span> = <span class="e Int"><span class="n">256</span></span>,
                <span class="i">MAX_SEARCH_LENGTH</span> = <span class="e Int"><span class="n">256</span></span>;</span>
    <span class="d Enum"><span class="k">enum</span> <span class="i">MatchMode</span> {
        <span class="d EnumMember"><span class="i">generic</span></span>, <span class="d EnumMember"><span class="i">generic_l</span></span>,
        <span class="d EnumMember"><span class="i">single_char</span></span>, <span class="d EnumMember"><span class="i">bitmap</span></span>, <span class="d EnumMember"><span class="i">string_search</span></span>,         <span class="lc">// consume</span>
        <span class="d EnumMember"><span class="i">single_char_l</span></span>, <span class="d EnumMember"><span class="i">bitmap_l</span></span>, <span class="d EnumMember"><span class="i">string_search_l</span></span>    <span class="lc">// lookahead</span>
    }</span>

    <span class="d Variables"><span class="t Identifier"><span class="i">MatchMode</span></span>   <span class="i">mode</span>;</span>
    <span class="lc">// data_chr had to be pulled out of the union due to</span>
    <span class="lc">// http://d.puremagic.com/issues/show_bug.cgi?id=2632 --- don't put it back</span>
    <span class="lc">// in until this is resolved!</span>
    <span class="lc">//</span>
    <span class="lc">// Keep in mind that data_str.length can't be modified directly unless the</span>
    <span class="lc">// new length is strictly greater than the old length. This is essentially</span>
    <span class="lc">// because ubyte.sizeof can be less than char_t.sizeof. If you set</span>
    <span class="lc">// data_str.length to anything less than or equal to data_bmp.length,</span>
    <span class="lc">// data_str will not be reallocated: only the length value will change but</span>
    <span class="lc">// nothing will realize that not that much space has actually been</span>
    <span class="lc">// allocated. data_str will be too small and you'll likely get segfaults or</span>
    <span class="lc">// such.</span>
    <span class="lc">//</span>
    <span class="lc">// In short: don't mess with data_str.length. If you have to, remove the</span>
    <span class="lc">// union entirely.</span>
    <span class="lc">//</span>
    <span class="lc">// -- Deewiant</span>
    <span class="d Union"><span class="k">union</span> <span class="d Compound">{
        <span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span>     <span class="i">data_bmp</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">string_t</span></span>    <span class="i">data_str</span>;</span>
    }</span></span><span class="d Empty">;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span>      <span class="i">data_chr</span>;</span>


    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">compile</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span>)</span>;</span>

        <span class="lc">// single char?</span>
        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span> == <span class="e Int"><span class="n">1</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">l_</span></span> == <span class="e Index"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">r_</span></span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">mode</span></span> = <span class="e Cond"><span class="e Equal"><span class="e Identifier"><span class="i">type</span></span>==<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> ? <span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">single_char</span></span> : <span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">single_char_l</span></span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">data_chr</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">l_</span></span></span>;</span>
            <span class="s Return"><span class="k">return</span>;</span>
        }</span></span></span>
        <span class="lc">// check whether we can use a bitmap</span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Rel"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">l_</span></span> &gt; <span class="e Identifier"><span class="i">MAX_BITMAP_LENGTH</span></span></span> || <span class="e Rel"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">r_</span></span> &gt; <span class="e Identifier"><span class="i">MAX_BITMAP_LENGTH</span></span></span></span> )
                <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">LnoBitmap</span>;</span></span></span>
        }</span></span></span>

        <span class="lc">// setup bitmap</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">data_bmp</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Div"><span class="e Identifier"><span class="i">MAX_BITMAP_LENGTH</span></span>/<span class="e Int"><span class="n">8</span></span></span></span>;</span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">c</span> = <span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">l_</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">r_</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">c</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e OrAssign"><span class="e Index"><span class="e Identifier"><span class="i">data_bmp</span></span>[<span class="e Div"><span class="e Identifier"><span class="i">c</span></span>/<span class="e Int"><span class="n">8</span></span></span>]</span> |= <span class="e LShift"><span class="e Int"><span class="n">1</span></span> &lt;&lt; <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">c</span></span>&amp;<span class="e Int"><span class="n">7</span></span></span>)</span></span></span>;</span></span></span>
        }</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">mode</span></span> = <span class="e Cond"><span class="e Equal"><span class="e Identifier"><span class="i">type</span></span>==<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> ? <span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">bitmap</span></span> : <span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">bitmap_l</span></span></span></span>;</span>
        <span class="s Return"><span class="k">return</span>;</span>

    <span class="s Labeled"><span class="i">LnoBitmap</span>:
<span class="bc">/*
        // check whether the class is small enough to justify a string-search
        // TODO: consider inverse class for 8bit chars?
        uint class_size;
        foreach ( p; input.parts )
            class_size += cast(uint)p.r_+1-p.l_;
        if ( class_size &gt; MAX_SEARCH_LENGTH )
            goto Lgeneric;
        data_str.length = class_size;
        size_t ind;
        foreach ( p; input.parts )
        {
            for ( char_t c = p.l_; c &lt;= p.r_; ++c )
                data_str[ind++] = c;
        }
        mode = type==Type.consume ? MatchMode.string_search : MatchMode.string_search_l;
        return;
*/</span>
    <span class="s Labeled"><span class="i">Lgeneric</span>:
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">data_str</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span>)<span class="e Identifier"><span class="i">input</span></span></span>.<span class="e Identifier"><span class="i">parts</span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">mode</span></span> = <span class="e Cond"><span class="e Equal"><span class="e Identifier"><span class="i">type</span></span>==<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> ? <span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">generic</span></span> : <span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">generic_l</span></span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">matches</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">c</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Equal"><span class="e Identifier"><span class="i">type</span></span> == <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> || <span class="e Equal"><span class="e Identifier"><span class="i">type</span></span> == <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">lookahead</span></span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">matches</span></span>(<span class="i">c</span>)</span>;</span></span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>)</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">Predicate</span></span> <span class="i">intersect</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Predicate</span></span> <span class="i">p</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Predicate</span></span> <span class="i">p2</span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p2</span></span>.<span class="e Identifier"><span class="i">input</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">intersect</span></span>(<span class="i">p</span>.<span class="i">input</span>)</span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">p2</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">intersects</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Predicate</span></span> <span class="i">p</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">type</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cr</span></span></span>; <span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cr2</span></span></span>; <span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">intersects</span></span>(<span class="i">cr2</span>)</span> )
                    <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span></span></span>
            }</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">exceedsMax</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">uint</span></span> <span class="i">maxc</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Rel"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">l_</span></span> &gt; <span class="e Identifier"><span class="i">maxc</span></span></span> || <span class="e Rel"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">r_</span></span> &gt; <span class="e Identifier"><span class="i">maxc</span></span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span></span></span>
        }</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
    }</span></span></span>

    <span class="d StorageClass">@<span class="i">property</span></span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">empty</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span> &amp;&amp; <span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">subtract</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Predicate</span></span> <span class="i">p</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">subtract</span></span>(<span class="i">p</span>.<span class="i">input</span>)</span>;</span></span></span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">negate</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">optimize</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opCmp</span><span class="o ">(<span class="o "><span class="k">const</span> <span class="k">ref</span> <span class="t Identifier"><span class="i">Predicate</span></span> <span class="i">p</span></span>)</span> <span class="k">const</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">opCmp</span></span>(<span class="i">p</span>.<span class="i">input</span>)</span>;</span>
    }</span></span></span>

    <span class="d StorageClass"><span class="k">const</span></span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">opEquals</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="k">const</span> <span class="t Identifier"><span class="i">Predicate</span></span> <span class="i">p</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">type</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">opCmp</span></span>(<span class="i">p</span>.<span class="i">input</span>)</span> != <span class="e Int"><span class="n">0</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">cc_t</span></span> <span class="i">getInput</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">input</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">setInput</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">cc_t</span></span>)</span> <span class="i">cc</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">input</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">cc_t</span></span>)<span class="e Identifier"><span class="i">cc</span></span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">appendInput</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">cr_t</span></span> <span class="i">cr</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">input</span></span>.<span class="t Identifier"><span class="i">add</span></span>(<span class="i">cr</span>);</span></span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">appendInput</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">cc_t</span></span> <span class="i">cc</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">input</span></span>.<span class="t Identifier"><span class="i">add</span></span>(<span class="i">cc</span>);</span></span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">appendInput</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Predicate</span></span> <span class="i">p</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">add</span></span>(<span class="i">p</span>.<span class="i">input</span>)</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">string</span></span> <span class="i">toString</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span> <span class="i">str</span>;</span></span>
        <span class="s Switch"><span class="k">switch</span> ( <span class="e Identifier"><span class="i">type</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span>:      <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span></span>;</span>       <span class="s Break"><span class="k">break</span>;</span></span></span></span>
            <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span>:      <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str</span></span> = <span class="e String"><span class="sl">"eps"</span></span></span>;</span>                <span class="s Break"><span class="k">break</span>;</span></span></span></span>
            <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">lookahead</span></span>:    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str</span></span> = <span class="e Cat"><span class="e String"><span class="sl">"la:"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span></span></span>;</span> <span class="s Break"><span class="k">break</span>;</span></span></span></span>
            <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">lookbehind</span></span>:   <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str</span></span> = <span class="e Cat"><span class="e String"><span class="sl">"lb:"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span></span></span>;</span> <span class="s Break"><span class="k">break</span>;</span></span></span></span>
            <span class="s Default"><span class="k">default</span>:
                <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>)</span>;</span></span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">str</span></span>;</span>
    }</span></span></span>
}</span></span></span></span>
<span class="d Import"><span class="k">import</span> <span class="i">Utf</span> = <span class="i">tango</span>.<span class="i">text</span>.<span class="i">convert</span>.<span class="i">Utf</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">text</span>.<span class="i">convert</span>.<span class="i">Format</span>;</span>

<span class="bc">/* ************************************************************************************************

**************************************************************************************************/</span>
<span class="d Class"><span class="k">class</span> <span class="i">RegExpException</span> : <span class="t BaseClass"><span class="t Identifier"><span class="i">Exception</span></span></span>
<span class="d Compound">{
    <span class="d Constructor"><span class="k">this</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">string</span></span> <span class="i">msg</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Super"><span class="k">super</span></span>(<span class="sl">"RegExp: "</span>~<span class="i">msg</span>)</span>;</span>
    }</span></span></span>
}</span></span>

<span class="bc">/* ************************************************************************************************
    TNFA state
**************************************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Class"><span class="k">class</span> <span class="i">TNFAState</span><span class="o ">(<span class="o "><span class="i">char_t</span></span>)</span>
<span class="d Compound">{
    <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span>    <span class="i">accept</span> = <span class="e Bool"><span class="k">false</span></span>,
            <span class="i">visited</span> = <span class="e Bool"><span class="k">false</span></span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>  <span class="i">index</span>;</span>
    <span class="d Variables"><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t TemplateInstance"><span class="i">TNFATransition</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>)</span></span>  <span class="i">transitions</span>;</span>

    <span class="d Constructor"><span class="k">this</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">transitions</span></span> = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t TemplateInstance"><span class="i">TNFATransition</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>)</span></span></span></span>;</span>
    }</span></span></span>
}</span></span></span></span>


<span class="bc">/* ************************************************************************************************
    Priority classes used to linearize priorities after non-linear transition creation.
**************************************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Enum"><span class="k">enum</span> <span class="i">PriorityClass</span> {
    <span class="d EnumMember"><span class="i">greedy</span>=<span class="e Int"><span class="n">0</span></span></span>, <span class="d EnumMember"><span class="i">normal</span>=<span class="e Int"><span class="n">1</span></span></span>, <span class="d EnumMember"><span class="i">reluctant</span>=<span class="e Int"><span class="n">2</span></span></span>, <span class="d EnumMember"><span class="i">extraReluctant</span>=<span class="e Int"><span class="n">3</span></span></span>
}</span>

<span class="bc">/* ********************************************************************************
    TNFA tagged transition
***********************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Class"><span class="k">class</span> <span class="i">TNFATransition</span><span class="o ">(<span class="o "><span class="i">char_t</span></span>)</span>
<span class="d Compound">{
    <span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFAState</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>  <span class="i">target</span>;</span>
    <span class="d Variables"><span class="t TemplateInstance"><span class="i">Predicate</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>  <span class="i">predicate</span>;</span>
    <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span>                <span class="i">priority</span>,
                        <span class="i">tag</span>;</span>        <span class="lc">/// one-based tag number, 0 = untagged</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">PriorityClass</span></span>       <span class="i">priorityClass</span>;</span>

    <span class="d Constructor"><span class="k">this</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">PriorityClass</span></span> <span class="i">pc</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">priorityClass</span></span> = <span class="e Identifier"><span class="i">pc</span></span></span>;</span>
    }</span></span></span>

    <span class="bc">/******************************************************************************
        Move through states only going via epsilon transitions, and only choosing
        the one with highest priority. If the highest priority transition from a
        state isn't an epsilon transition, false is returned.
        If the accepting NFA state can be reached in this manner, true is returned.

        NOTE: This method does not look for cycles which should be kept in mind for
        later. larsivi 20090827
    *******************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">canFinish</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFAState</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>  <span class="i">t</span> = <span class="e Identifier"><span class="i">target</span></span>;</span></span>
        <span class="s While"><span class="k">while</span> (<span class="e Not">!<span class="e Identifier"><span class="i">t</span></span></span>.<span class="e Identifier"><span class="i">accept</span></span>) <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFATransition</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span> <span class="i">highestPriTrans</span>;</span></span>
            <span class="s Foreach"><span class="k">foreach</span> (<span class="o "><span class="o "><span class="i">trans</span></span></span>; <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">transitions</span></span>) <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> (<span class="e OrOr"><span class="e Not">!<span class="e Identifier"><span class="i">highestPriTrans</span></span></span> || <span class="e Rel"><span class="e Identifier"><span class="i">highestPriTrans</span></span>.<span class="e Identifier"><span class="i">priority</span></span> &gt; <span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">priority</span></span></span></span>)
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">highestPriTrans</span></span> = <span class="e Identifier"><span class="i">trans</span></span></span>;</span></span></span>
            }</span></span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Not">!<span class="e Paren">(<span class="e Equal"><span class="e Identifier"><span class="i">highestPriTrans</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> == <span class="e TmplInstance"><span class="i">Predicate</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>)</span></span>)
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>

            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> = <span class="e Identifier"><span class="i">highestPriTrans</span></span>.<span class="e Identifier"><span class="i">target</span></span></span>;</span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span>
    }</span></span></span>

}</span></span></span></span>

<span class="bc">/* ************************************************************************************************
    Fragments of TNFAs as used in the Thompson method
**************************************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Class"><span class="k">class</span> <span class="i">TNFAFragment</span><span class="o ">(<span class="o "><span class="i">char_t</span></span>)</span>
<span class="d Compound">{
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFAState</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>        <span class="i">state_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFATransition</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>   <span class="i">trans_t</span>;</span></span>

    <span class="d Variables"><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">trans_t</span></span>)</span></span>  <span class="i">entries</span>,        <span class="lc">/// transitions to be added to the entry state</span>
                    <span class="i">exits</span>,          <span class="lc">/// transitions to be added to the exit state</span>
                    <span class="i">entry_state</span>,    <span class="lc">/// transitions to write the entry state to</span>
                    <span class="i">exit_state</span>;</span>     <span class="lc">/// transitions to write the exit state to</span>

    <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">swapMatchingBracketSyntax</span>;</span>

    <span class="d Constructor"><span class="k">this</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">entries</span></span>     = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">trans_t</span></span>)</span></span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">exits</span></span>       = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">trans_t</span></span>)</span></span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">entry_state</span></span> = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">trans_t</span></span>)</span></span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">exit_state</span></span>  = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">trans_t</span></span>)</span></span></span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Write the given state as entry state to this fragment.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">setEntry</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">state</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> ~= <span class="e Identifier"><span class="i">entries</span></span></span>;</span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">entry_state</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">state</span></span></span>;</span></span></span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Write the given state as exit state to this fragment.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">setExit</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">state</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> ~= <span class="e Identifier"><span class="i">exits</span></span></span>;</span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">exit_state</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">state</span></span></span>;</span></span></span>
    }</span></span></span>
}</span></span></span></span>

<span class="bc">/* ************************************************************************************************
    Tagged NFA
**************************************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d StorageClass"><span class="k">final</span></span> <span class="d Template"><span class="d Compound"><span class="d Class"><span class="k">class</span> <span class="i">TNFA</span><span class="o ">(<span class="o "><span class="i">char_t</span></span>)</span>
<span class="d Compound">{
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFATransition</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>   <span class="i">trans_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFAFragment</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>     <span class="i">frag_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFAState</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>        <span class="i">state_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">Predicate</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>        <span class="i">predicate_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span>                  <span class="i">string_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharRange</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>        <span class="i">range_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>        <span class="i">cc_t</span>;</span></span>

    <span class="d Variables"><span class="t Identifier"><span class="i">string_t</span></span>    <span class="i">pattern</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span><span class="t Array">[]</span>   <span class="i">states</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span>     <span class="i">start</span>;</span>

    <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">swapMatchingBracketSyntax</span>;</span> <span class="lc">/// whether to make (?...) matching and (...) non-matching</span>

    <span class="bc">/* ********************************************************************************************
        Creates the TNFA from the given regex pattern
    **********************************************************************************************/</span>
    <span class="d Constructor"><span class="k">this</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">string_t</span></span> <span class="i">regex</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">next_tag</span></span>        = <span class="e Int"><span class="n">1</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">transitions</span></span>     = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">trans_t</span></span>)</span></span></span></span>;</span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">pattern</span></span> = <span class="e Identifier"><span class="i">regex</span></span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Print the TNFA (tabular representation of the delta function)
    **********************************************************************************************/</span>
    <span class="d Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">print</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span></span>, <span class="o "><span class="i">s</span></span></span>; <span class="e Identifier"><span class="i">states</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"{}{:d2}{}"</span>, <span class="i">s</span> <span class="k">is</span> <span class="i">start</span>?<span class="sl">"&gt;"</span>:<span class="sl">" "</span>, <span class="i">i</span>, <span class="i">s</span>.<span class="i">accept</span>?<span class="sl">"*"</span>:<span class="sl">" "</span>)</span>;</span>

            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">first</span>=<span class="e Bool"><span class="k">true</span></span>;</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">" {"</span>)</span>;</span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"{}{}{}:{}-&gt;{}"</span>, <span class="i">first</span>?<span class="sl">""</span>:<span class="sl">", "</span>, <span class="i">t</span>.<span class="i">priority</span>, <span class="sl">"gnrx"</span>[<span class="i">t</span>.<span class="i">priorityClass</span>], <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">toString</span>, <span class="i">t</span>.<span class="i">target</span> <span class="k">is</span> <span class="k">null</span>?-<span class="n">1</span>:<span class="i">t</span>.<span class="i">target</span>.<span class="i">index</span>)</span>;</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">tag</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">" t{}"</span>, <span class="i">t</span>.<span class="i">tag</span>)</span>;</span>
                }</span></span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
            }</span></span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"}"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span>
        }</span></span></span>
    }</span></span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">uint</span></span> <span class="i">tagCount</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Minus"><span class="e Identifier"><span class="i">next_tag</span></span>-<span class="e Int"><span class="n">1</span></span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Constructs the TNFA using extended Thompson method.
        Uses a slightly extended version of Dijkstra's shunting yard algorithm to convert
        the regexp from infix notation.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">parse</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">bool</span></span> <span class="i">unanchored</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">frag_t</span></span>)</span></span>       <span class="i">frags</span>       = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">frag_t</span></span>)</span></span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">Stack</span>!<span class="o ">(<span class="t Identifier"><span class="i">Operator</span></span>)</span></span>    <span class="i">opStack</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">Stack</span>!<span class="o ">(<span class="t Integral"><span class="k">uint</span></span>)</span></span>        <span class="i">tagStack</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">Stack</span>!<span class="o ">(<span class="t TemplateInstance"><span class="i">Pair</span>!<span class="o ">(<span class="t Integral"><span class="k">uint</span></span>)</span></span>)</span></span> <span class="i">occurStack</span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">opStack</span></span> ~= <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">eos</span></span></span>;</span>

        <span class="bc">/* ****************************************************************************************
            Perform action on operator stack
        ******************************************************************************************/</span>
        <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">perform</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Operator</span></span> <span class="i">next_op</span></span>, <span class="o "><span class="t Integral"><span class="k">bool</span></span> <span class="i">explicit_operator</span>=<span class="e Bool"><span class="k">true</span></span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="lc">// calculate index in action matrix</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">index</span> = <span class="e Mul"><span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">opStack</span></span></span>.<span class="e Identifier"><span class="i">top</span></span>()</span>*<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">max</span></span>+<span class="e Int"><span class="n">1</span></span></span>)</span></span>;</span></span>
            <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">index</span></span> += <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">next_op</span></span></span></span>;</span>

            <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"<span class="es">\t</span>{}:{} -&gt; {}  {} frag(s)"</span>,
                <span class="i">operator_names</span>[<span class="i">opStack</span>.<span class="i">top</span>], <span class="i">operator_names</span>[<span class="i">next_op</span>], <span class="i">action_names</span>[<span class="i">action_lookup</span>[<span class="i">index</span>]], <span class="i">frags</span>.<span class="i">length</span>
            )</span>;</span></span>
            <span class="s Switch"><span class="k">switch</span> ( <span class="e Index"><span class="e Identifier"><span class="i">action_lookup</span></span>[<span class="e Identifier"><span class="i">index</span></span>]</span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">opStack</span></span> ~= <span class="e Identifier"><span class="i">next_op</span></span></span>;</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">next_op</span></span> == <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">open_par</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">tagStack</span></span> ~= <span class="e Identifier"><span class="i">next_tag</span></span></span>;</span>
                        <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">next_tag</span></span> += <span class="e Int"><span class="n">2</span></span></span>;</span>
                    }</span></span></span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Switch"><span class="k">switch</span> ( <span class="e Call"><span class="e Identifier"><span class="i">opStack</span></span>.<span class="e Identifier"><span class="i">top</span></span>()</span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">concat</span></span>:       <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">constructConcat</span></span>(<span class="i">frags</span>);</span></span>                             <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">altern</span></span>:       <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">constructAltern</span></span>(<span class="i">frags</span>);</span></span>                             <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">zero_one_g</span></span>:   <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructZeroOne</span></span>(<span class="i">frags</span>, <span class="i">PriorityClass</span>.<span class="i">greedy</span>)</span>;</span>      <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">zero_one_ng</span></span>:  <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructZeroOne</span></span>(<span class="i">frags</span>, <span class="i">PriorityClass</span>.<span class="i">reluctant</span>)</span>;</span>   <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">zero_one_xr</span></span>:  <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructZeroOne</span></span>(<span class="i">frags</span>, <span class="i">PriorityClass</span>.<span class="i">extraReluctant</span>)</span>;</span>  <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">zero_more_g</span></span>:  <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructZeroMore</span></span>(<span class="i">frags</span>, <span class="i">PriorityClass</span>.<span class="i">greedy</span>)</span>;</span>     <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">zero_more_ng</span></span>: <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructZeroMore</span></span>(<span class="i">frags</span>, <span class="i">PriorityClass</span>.<span class="i">reluctant</span>)</span>;</span>  <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">zero_more_xr</span></span>: <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructZeroMore</span></span>(<span class="i">frags</span>, <span class="i">PriorityClass</span>.<span class="i">extraReluctant</span>)</span>;</span> <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">one_more_g</span></span>:   <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructOneMore</span></span>(<span class="i">frags</span>, <span class="i">PriorityClass</span>.<span class="i">greedy</span>)</span>;</span>      <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">one_more_ng</span></span>:  <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructOneMore</span></span>(<span class="i">frags</span>, <span class="i">PriorityClass</span>.<span class="i">reluctant</span>)</span>;</span>   <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">one_more_xr</span></span>:  <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructOneMore</span></span>(<span class="i">frags</span>, <span class="i">PriorityClass</span>.<span class="i">extraReluctant</span>)</span>;</span>  <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">occur_g</span></span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">Pair</span>!<span class="o ">(<span class="t Integral"><span class="k">uint</span></span>)</span></span> <span class="i">occur</span> = <span class="e Call"><span class="e Identifier"><span class="i">occurStack</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span></span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructOccur</span></span>(<span class="i">frags</span>, <span class="i">occur</span>.<span class="i">a</span>, <span class="i">occur</span>.<span class="i">b</span>, <span class="i">PriorityClass</span>.<span class="i">greedy</span>)</span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">occur_ng</span></span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">Pair</span>!<span class="o ">(<span class="t Integral"><span class="k">uint</span></span>)</span></span> <span class="i">occur</span> = <span class="e Call"><span class="e Identifier"><span class="i">occurStack</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span></span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructOccur</span></span>(<span class="i">frags</span>, <span class="i">occur</span>.<span class="i">a</span>, <span class="i">occur</span>.<span class="i">b</span>, <span class="i">PriorityClass</span>.<span class="i">reluctant</span>)</span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Default"><span class="k">default</span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"cannot process operand at <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$])</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span></span>
                    }</span></span></span>
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">opStack</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>

                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">next_op</span>, <span class="k">false</span>)</span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poa</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">opStack</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pca</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">opStack</span></span>.<span class="e Identifier"><span class="i">top</span></span>()</span> == <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">open_par</span></span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">tagStack</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
                            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"Missing opening parentheses for closing parentheses at char {} <span class="es">\"</span>{}<span class="es">\"</span>"</span>, <span class="i">cursor</span>, <span class="i">Utf</span>.<span class="i">toString</span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$]))</span>.<span class="e Identifier"><span class="i">idup</span></span>)</span>;</span></span></span>
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">constructBracket</span></span>(<span class="i">frags</span>, <span class="i">tagStack</span>.<span class="i">top</span>())</span>;</span>
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">tagStack</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
                    }</span></span>
                    <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">opStack</span></span>.<span class="e Identifier"><span class="i">top</span></span>()</span> == <span class="e Identifier"><span class="i">Operator</span></span>.<span class="e Identifier"><span class="i">open_par_nm</span></span></span>)</span>;</span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">constructBracket</span></span>(<span class="i">frags</span>);</span></span>
                    }</span></span></span>
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">opStack</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">don</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                <span class="s Default"><span class="k">default</span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"Unexpected operand at char {} <span class="es">\"</span>{}<span class="es">\"</span> in <span class="es">\"</span>{}<span class="es">\"</span>"</span>, <span class="i">cursor</span>, <span class="i">Utf</span>.<span class="i">toString</span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$]), <span class="i">Utf</span>.<span class="i">toString</span>(<span class="i">pattern</span>))</span>.<span class="e Identifier"><span class="i">idup</span></span>)</span>;</span></span></span></span>
            }</span></span></span>

            <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
        }</span></span></span></span>

        <span class="lc">// add implicit extra reluctant .* (with . == any_char) at the beginning for unanchored matches</span>
        <span class="lc">// and matching bracket for total match group</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">unanchored</span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">any_char</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">consume</span>)</span></span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">zero_more_xr</span>, <span class="k">false</span>)</span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">open_par</span>, <span class="k">false</span>)</span>;</span>
        }</span></span></span>

        <span class="lc">// convert regex to postfix and create TNFA</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">implicit_concat</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">predicate_t</span></span>.<span class="t Identifier"><span class="i">Type</span></span> <span class="i">pred_type</span>;</span></span>

        <span class="s While"><span class="k">while</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">endOfPattern</span></span></span>()</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">pred_type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span>;</span>

            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">c</span> = <span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span></span>
            <span class="s Switch"><span class="k">switch</span> ( <span class="e Identifier"><span class="i">c</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'|'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">altern</span>)</span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">implicit_concat</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'('</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">implicit_concat</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">implicit_concat</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> == <span class="e Char"><span class="cl">'?'</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span>
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">swapMatchingBracketSyntax</span>?<span class="i">Operator</span>.<span class="i">open_par</span>:<span class="i">Operator</span>.<span class="i">open_par_nm</span>)</span>;</span>
                    }</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">swapMatchingBracketSyntax</span>?<span class="i">Operator</span>.<span class="i">open_par_nm</span>:<span class="i">Operator</span>.<span class="i">open_par</span>)</span>;</span></span></span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">')'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">close_par</span>)</span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'?'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> == <span class="e Char"><span class="cl">'?'</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span>
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">zero_one_ng</span>)</span>;</span>
                    }</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">zero_one_g</span>)</span>;</span></span></span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'*'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> == <span class="e Char"><span class="cl">'?'</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span>
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">zero_more_ng</span>)</span>;</span>
                    }</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">zero_more_g</span>)</span>;</span></span></span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'+'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> == <span class="e Char"><span class="cl">'?'</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span>
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">one_more_ng</span>)</span>;</span>
                    }</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">one_more_g</span>)</span>;</span></span></span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'{'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">Pair</span>!<span class="o ">(<span class="t Integral"><span class="k">uint</span></span>)</span></span> <span class="i">occur</span>;</span></span>
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">parseOccurCount</span></span>(<span class="i">occur</span>.<span class="i">a</span>, <span class="i">occur</span>.<span class="i">b</span>)</span>;</span>
                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">occurStack</span></span> ~= <span class="e Identifier"><span class="i">occur</span></span></span>;</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> == <span class="e Char"><span class="cl">'?'</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span>
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">occur_ng</span>)</span>;</span>
                    }</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">occur_g</span>)</span>;</span></span></span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'['</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">implicit_concat</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">implicit_concat</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructCharClass</span></span>(<span class="i">pred_type</span>)</span></span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'.'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">implicit_concat</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">implicit_concat</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">dot_oper</span>, <span class="i">pred_type</span>)</span></span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'$'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">implicit_concat</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">implicit_concat</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>

                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">line_startend</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">lookahead</span>)</span></span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'^'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">implicit_concat</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">implicit_concat</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>

                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">line_startend</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">lookbehind</span>)</span></span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'&gt;'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">pred_type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">lookahead</span></span></span>;</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">c</span></span> == <span class="e Char"><span class="cl">'['</span></span></span> )
                        <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="k">case</span> <span class="e Char"><span class="cl">'['</span></span>;</span></span>
                    <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">c</span></span> == <span class="e Char"><span class="cl">'<span class="es">\\</span>'</span></span></span> )
                        <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="k">case</span> <span class="e Char"><span class="cl">'<span class="es">\\</span>'</span></span>;</span></span>
                    <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">c</span></span> == <span class="e Char"><span class="cl">'.'</span></span></span> )
                        <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="k">case</span> <span class="e Char"><span class="cl">'.'</span></span>;</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="k">default</span>;</span></span></span></span></span></span></span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'&lt;'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">pred_type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">lookbehind</span></span></span>;</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">c</span></span> == <span class="e Char"><span class="cl">'['</span></span></span> )
                        <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="k">case</span> <span class="e Char"><span class="cl">'['</span></span>;</span></span>
                    <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">c</span></span> == <span class="e Char"><span class="cl">'<span class="es">\\</span>'</span></span></span> )
                        <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="k">case</span> <span class="e Char"><span class="cl">'<span class="es">\\</span>'</span></span>;</span></span>
                    <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">c</span></span> == <span class="e Char"><span class="cl">'.'</span></span></span> )
                        <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="k">case</span> <span class="e Char"><span class="cl">'.'</span></span>;</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="k">default</span>;</span></span></span></span></span></span></span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'<span class="es">\\</span>'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span></span>;</span>

                    <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">implicit_concat</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">implicit_concat</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>

                    <span class="s Switch"><span class="k">switch</span> ( <span class="e Identifier"><span class="i">c</span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'t'</span></span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructSingleChar</span></span>(<span class="cl">'<span class="es">\t</span>'</span>, <span class="i">pred_type</span>)</span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'n'</span></span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructSingleChar</span></span>(<span class="cl">'<span class="es">\n</span>'</span>, <span class="i">pred_type</span>)</span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'r'</span></span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructSingleChar</span></span>(<span class="cl">'<span class="es">\r</span>'</span>, <span class="i">pred_type</span>)</span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'w'</span></span>:   <span class="lc">// alphanumeric and _</span>
                            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">alphanum_</span>, <span class="i">pred_type</span>)</span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'W'</span></span>:   <span class="lc">// non-(alphanum and _)</span>
                            <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">cc</span> = <span class="e Call"><span class="e Identifier"><span class="i">cc_t</span></span>(<span class="i">cc_t</span>.<span class="i">alphanum_</span>)</span>;</span></span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc</span>, <span class="i">pred_type</span>)</span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'s'</span></span>:   <span class="lc">// whitespace</span>
                            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">whitespace</span>, <span class="i">pred_type</span>)</span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'S'</span></span>:   <span class="lc">// non-whitespace</span>
                            <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">cc</span> = <span class="e Call"><span class="e Identifier"><span class="i">cc_t</span></span>(<span class="i">cc_t</span>.<span class="i">whitespace</span>)</span>;</span></span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc</span>, <span class="i">pred_type</span>)</span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'d'</span></span>:   <span class="lc">// digit</span>
                            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">digit</span>, <span class="i">pred_type</span>)</span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'D'</span></span>:   <span class="lc">// non-digit</span>
                            <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">cc</span> = <span class="e Call"><span class="e Identifier"><span class="i">cc_t</span></span>(<span class="i">cc_t</span>.<span class="i">digit</span>)</span>;</span></span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>
                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc</span>, <span class="i">pred_type</span>)</span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'b'</span></span>:   <span class="lc">// either end of word</span>
                            <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">pred_type</span></span> != <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> )
                                <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e String"><span class="sl">"Escape sequence <span class="es">\\</span>b not allowed in look-ahead or -behind"</span></span>)</span>;</span></span></span>

                            <span class="lc">// create (?&lt;\S&gt;\s|&lt;\s&gt;\S)</span>
                            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">cc</span> = <span class="e Call"><span class="e Identifier"><span class="i">cc_t</span></span>(<span class="i">cc_t</span>.<span class="i">whitespace</span>)</span>;</span></span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>

                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">open_par_nm</span>)</span>;</span>

                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">lookbehind</span>)</span></span>;</span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span>
                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">whitespace</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">lookahead</span>)</span></span>;</span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">altern</span>, <span class="k">false</span>)</span>;</span>
                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">whitespace</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">lookbehind</span>)</span></span>;</span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span>
                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">lookahead</span>)</span></span>;</span>

                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">close_par</span>, <span class="k">false</span>)</span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'B'</span></span>:   <span class="lc">// neither end of word</span>
                            <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">pred_type</span></span> != <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> )
                                <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e String"><span class="sl">"Escape sequence <span class="es">\\</span>B not allowed in look-ahead or -behind"</span></span>)</span>;</span></span></span>

                            <span class="lc">// create (?&lt;\S&gt;\S|&lt;\s&gt;\s)</span>
                            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">cc</span> = <span class="e Call"><span class="e Identifier"><span class="i">cc_t</span></span>(<span class="i">cc_t</span>.<span class="i">whitespace</span>)</span>;</span></span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">negate</span></span>()</span>;</span>

                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">open_par_nm</span>)</span>;</span>

                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">lookbehind</span>)</span></span>;</span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span>
                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">lookahead</span>)</span></span>;</span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">altern</span>, <span class="k">false</span>)</span>;</span>
                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">whitespace</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">lookbehind</span>)</span></span>;</span>
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span>
                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">whitespace</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">lookahead</span>)</span></span>;</span>

                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">close_par</span>, <span class="k">false</span>)</span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'('</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">')'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'['</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">']'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'{'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'}'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'*'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'+'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'?'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'.'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'<span class="es">\\</span>'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'^'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'$'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'|'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'&lt;'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'&gt;'</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                        <span class="s Default"><span class="k">default</span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructSingleChar</span></span>(<span class="i">c</span>, <span class="i">pred_type</span>)</span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
<span class="lc">//                            throw new RegExpException(Format.convert("Unknown escape sequence \\{}", c));</span>
                    }</span></span></span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>

                <span class="s Default"><span class="k">default</span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">implicit_concat</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">implicit_concat</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructSingleChar</span></span>(<span class="i">c</span>, <span class="i">pred_type</span>)</span></span>;</span></span></span></span>
            }</span></span></span>
        }</span></span></span>

        <span class="lc">// add implicit reluctant .* (with . == any_char) at the end for unanchored matches</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">unanchored</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">close_par</span>, <span class="k">false</span>)</span>;</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">implicit_concat</span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">concat</span>, <span class="k">false</span>)</span>;</span></span></span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc_t</span>.<span class="i">any_char</span>, <span class="i">predicate_t</span>.<span class="i">Type</span>.<span class="i">consume</span>)</span></span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">perform</span></span>(<span class="i">Operator</span>.<span class="i">zero_more_ng</span>, <span class="k">false</span>)</span>;</span>
        }</span></span></span>

        <span class="lc">// empty operator stack</span>
        <span class="s While"><span class="k">while</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">perform</span></span></span>(<span class="i">Operator</span>.<span class="i">eos</span>)</span> ) <span class="s Scope"><span class="s Compound">{}</span></span></span>

        <span class="lc">// set start and finish states</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span></span>;</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">finish</span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">finish</span></span>.<span class="e Identifier"><span class="i">accept</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">f</span></span></span>; <span class="e Identifier"><span class="i">frags</span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">f</span></span>.<span class="t Identifier"><span class="i">setExit</span></span>(<span class="i">finish</span>);</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">f</span></span>.<span class="t Identifier"><span class="i">setEntry</span></span>(<span class="i">start</span>);</span></span>
        }</span></span></span>

        <span class="lc">// set transition priorities</span>
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">trans_t</span></span>)</span></span><span class="t Array">[<span class="e Plus"><span class="e Identifier"><span class="i">PriorityClass</span></span>.<span class="e Identifier"><span class="i">max</span></span>+<span class="e Int"><span class="n">1</span></span></span>]</span> <span class="i">trans</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="k">ref</span> <span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">trans</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">trans_t</span></span>)</span></span></span></span>;</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">Stack</span>!<span class="o ">(<span class="t Identifier"><span class="i">trans_t</span></span>)</span></span> <span class="i">todo</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">state</span> = <span class="e Identifier"><span class="i">start</span></span>;</span></span>

        <span class="s While"><span class="k">while</span> ( <span class="e OrOr"><span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">todo</span></span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> || <span class="e Not">!<span class="e Identifier"><span class="i">state</span></span></span>.<span class="e Identifier"><span class="i">visited</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Not">!<span class="e Identifier"><span class="i">state</span></span></span>.<span class="e Identifier"><span class="i">visited</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">visited</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                <span class="s Foreach"><span class="k">foreach_reverse</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">todo</span></span> ~= <span class="e Identifier"><span class="i">t</span></span></span>;</span></span></span>
            }</span></span></span>

            <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">todo</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
                <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">t</span> = <span class="e Call"><span class="e Identifier"><span class="i">todo</span></span>.<span class="e Identifier"><span class="i">top</span></span>()</span>;</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">todo</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">priorityClass</span></span>&lt;=<span class="e Identifier"><span class="i">PriorityClass</span></span>.<span class="e Identifier"><span class="i">max</span></span></span>)</span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Index"><span class="e Identifier"><span class="i">trans</span></span>[<span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">priorityClass</span></span>]</span> ~= <span class="e Identifier"><span class="i">t</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">state</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span></span>;</span>
        }</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">nextPrio</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">ts</span></span></span>; <span class="e Identifier"><span class="i">trans</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">ts</span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">priority</span></span> = <span class="e PostIncr"><span class="e Identifier"><span class="i">nextPrio</span></span>++</span></span>;</span></span></span>
        }</span></span></span>
    }</span></span></span>

<span class="d Protection"><span class="k">private</span></span>:
    <span class="d Compound"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span>            <span class="i">next_tag</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>          <span class="i">cursor</span>,
                    <span class="i">next_cursor</span>;</span>
    <span class="d Variables"><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">trans_t</span></span>)</span></span>  <span class="i">transitions</span>;</span>

    <span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span><span class="t Array">[<span class="t Identifier"><span class="i">state_t</span></span>]</span>    <span class="i">clonedStates</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span><span class="t Array">[<span class="t Identifier"><span class="i">trans_t</span></span>]</span>    <span class="i">clonedTransitions</span>;</span>

    <span class="lc">/// RegEx operators</span>
    <span class="d Enum"><span class="k">enum</span> <span class="i">Operator</span> {
        <span class="d EnumMember"><span class="i">eos</span></span>, <span class="d EnumMember"><span class="i">concat</span></span>, <span class="d EnumMember"><span class="i">altern</span></span>, <span class="d EnumMember"><span class="i">open_par</span></span>, <span class="d EnumMember"><span class="i">close_par</span></span>,
        <span class="d EnumMember"><span class="i">zero_one_g</span></span>, <span class="d EnumMember"><span class="i">zero_more_g</span></span>, <span class="d EnumMember"><span class="i">one_more_g</span></span>,        <span class="lc">// greedy</span>
        <span class="d EnumMember"><span class="i">zero_one_ng</span></span>, <span class="d EnumMember"><span class="i">zero_more_ng</span></span>, <span class="d EnumMember"><span class="i">one_more_ng</span></span>,     <span class="lc">// non-greedy/reluctant</span>
        <span class="d EnumMember"><span class="i">zero_one_xr</span></span>, <span class="d EnumMember"><span class="i">zero_more_xr</span></span>, <span class="d EnumMember"><span class="i">one_more_xr</span></span>,     <span class="lc">// extra-reluctant</span>
        <span class="d EnumMember"><span class="i">open_par_nm</span></span>, <span class="d EnumMember"><span class="i">occur_g</span></span>, <span class="d EnumMember"><span class="i">occur_ng</span></span>
    }</span>
    <span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">operator_names</span> = <span class="e ArrayInit">[<span class="e String"><span class="sl">"EOS"</span></span>, <span class="e String"><span class="sl">"concat"</span></span>, <span class="e String"><span class="sl">"|"</span></span>, <span class="e String"><span class="sl">"("</span></span>, <span class="e String"><span class="sl">")"</span></span>, <span class="e String"><span class="sl">"?"</span></span>, <span class="e String"><span class="sl">"*"</span></span>, <span class="e String"><span class="sl">"+"</span></span>, <span class="e String"><span class="sl">"??"</span></span>, <span class="e String"><span class="sl">"*?"</span></span>, <span class="e String"><span class="sl">"+?"</span></span>, <span class="e String"><span class="sl">"??x"</span></span>, <span class="e String"><span class="sl">"*?x"</span></span>, <span class="e String"><span class="sl">"+?x"</span></span>, <span class="e String"><span class="sl">"(?"</span></span>, <span class="e String"><span class="sl">"{x,y}"</span></span>, <span class="e String"><span class="sl">"{x,y}?"</span></span>]</span>;</span>

    <span class="lc">/// Actions for to-postfix transformation</span>
    <span class="d Enum"><span class="k">enum</span> <span class="i">Act</span> {
        <span class="d EnumMember"><span class="i">pua</span></span>, <span class="d EnumMember"><span class="i">poc</span></span>, <span class="d EnumMember"><span class="i">poa</span></span>, <span class="d EnumMember"><span class="i">pca</span></span>, <span class="d EnumMember"><span class="i">don</span></span>, <span class="d EnumMember"><span class="i">err</span></span>
    }</span>
    <span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">action_names</span> = <span class="e ArrayInit">[<span class="e String"><span class="sl">"push+advance"</span></span>, <span class="e String"><span class="sl">"pop+copy"</span></span>, <span class="e String"><span class="sl">"pop+advance"</span></span>, <span class="e String"><span class="sl">"pop+copy+advance"</span></span>, <span class="e String"><span class="sl">"done"</span></span>, <span class="e String"><span class="sl">"error"</span></span>]</span>;</span>

    <span class="lc">/// Action lookup for to-postfix transformation</span>
    <span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">Act</span></span><span class="t Array">[]</span> <span class="i">action_lookup</span> =
    <span class="e ArrayInit">[
    <span class="lc">//  eos      concat   |        (        )        ?        *        +        ??       *?       +?       ??extra  *?extra  +?extra  (?       {x,y}    {x,y}?</span>
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">don</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pca</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">err</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pca</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>,
        <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">pua</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>, <span class="e Identifier"><span class="i">Act</span></span>.<span class="e Identifier"><span class="i">poc</span></span>
    ]</span>;</span>

    <span class="d StorageClass"><span class="k">final</span></span> <span class="d Function"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">peekPattern</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tmp</span> = <span class="e Identifier"><span class="i">next_cursor</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">tmp</span></span> &lt; <span class="e Identifier"><span class="i">pattern</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">decode</span></span>(<span class="i">pattern</span>, <span class="i">tmp</span>)</span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span>
    }</span></span></span>

    <span class="d StorageClass"><span class="k">final</span></span> <span class="d Function"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">readPattern</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cursor</span></span> = <span class="e Identifier"><span class="i">next_cursor</span></span></span>;</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">next_cursor</span></span> &lt; <span class="e Identifier"><span class="i">pattern</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">decode</span></span>(<span class="i">pattern</span>, <span class="i">next_cursor</span>)</span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span>
    }</span></span></span>

    <span class="d StorageClass"><span class="k">final</span></span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">endOfPattern</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Identifier"><span class="i">next_cursor</span></span> &gt;= <span class="e Identifier"><span class="i">pattern</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">addState</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">s</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">state_t</span></span></span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">index</span></span> = <span class="e Identifier"><span class="i">states</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">states</span></span> ~= <span class="e Identifier"><span class="i">s</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">s</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">addTransition</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">PriorityClass</span></span> <span class="i">pc</span> = <span class="e Identifier"><span class="i">PriorityClass</span></span>.<span class="e Identifier"><span class="i">normal</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">trans</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">trans_t</span></span>(<span class="e Identifier"><span class="i">pc</span></span>)</span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">transitions</span></span> ~= <span class="e Identifier"><span class="i">trans</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">trans</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">uint</span></span> <span class="i">parseNumber</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">res</span>;</span></span>
        <span class="s While"><span class="k">while</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">endOfPattern</span></span></span>()</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">c</span> = <span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt; <span class="e Char"><span class="cl">'0'</span></span></span> || <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &gt; <span class="e Char"><span class="cl">'9'</span></span></span></span> )
                <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span> = <span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">res</span></span>*<span class="e Int"><span class="n">10</span></span></span>+<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">c</span></span>-<span class="e Char"><span class="cl">'0'</span></span></span>)</span></span></span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">parseOccurCount</span><span class="o ">(<span class="o "><span class="k">out</span> <span class="t Integral"><span class="k">uint</span></span> <span class="i">minOccur</span></span>, <span class="o "><span class="k">out</span> <span class="t Integral"><span class="k">uint</span></span> <span class="i">maxOccur</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">pattern</span></span>[<span class="e Identifier"><span class="i">cursor</span></span>]</span> == <span class="e Char"><span class="cl">'{'</span></span></span>)</span>;</span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">minOccur</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">parseNumber</span></span>()</span></span>;</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> == <span class="e Char"><span class="cl">'}'</span></span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">maxOccur</span></span> = <span class="e Identifier"><span class="i">minOccur</span></span></span>;</span>
            <span class="s Return"><span class="k">return</span>;</span>
        }</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> != <span class="e Char"><span class="cl">','</span></span></span> )
            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"Invalid occurence range at <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$])</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">maxOccur</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">parseNumber</span></span>()</span></span>;</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> != <span class="e Char"><span class="cl">'}'</span></span></span> )
            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"Invalid occurence range at <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$])</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span>
        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">maxOccur</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">maxOccur</span></span> &lt; <span class="e Identifier"><span class="i">minOccur</span></span></span></span> )
            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"Invalid occurence range (max &lt; min) at <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$])</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">clone</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">t</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">t</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span></span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span><span class="t Pointer">*</span> <span class="i">tmp</span> = <span class="e In"><span class="e Identifier"><span class="i">t</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">clonedTransitions</span></span></span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">tmp</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Deref">*<span class="e Identifier"><span class="i">tmp</span></span></span>;</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">t2</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">trans_t</span></span>(<span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">priorityClass</span></span>)</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">clonedTransitions</span></span>[<span class="e Identifier"><span class="i">t</span></span>]</span> = <span class="e Identifier"><span class="i">t2</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t2</span></span>.<span class="e Identifier"><span class="i">tag</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">tag</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t2</span></span>.<span class="e Identifier"><span class="i">priority</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">priority</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t2</span></span>.<span class="e Identifier"><span class="i">predicate</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t2</span></span>.<span class="e Identifier"><span class="i">target</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">clone</span></span>(<span class="i">t</span>.<span class="i">target</span>)</span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">transitions</span></span> ~= <span class="e Identifier"><span class="i">t2</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">t2</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">clone</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">s</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">s</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span></span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span><span class="t Pointer">*</span> <span class="i">tmp</span> = <span class="e In"><span class="e Identifier"><span class="i">s</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">clonedStates</span></span></span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">tmp</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Deref">*<span class="e Identifier"><span class="i">tmp</span></span></span>;</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">s2</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">state_t</span></span></span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">clonedStates</span></span>[<span class="e Identifier"><span class="i">s</span></span>]</span> = <span class="e Identifier"><span class="i">s2</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s2</span></span>.<span class="e Identifier"><span class="i">accept</span></span> = <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">accept</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s2</span></span>.<span class="e Identifier"><span class="i">visited</span></span> = <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">visited</span></span></span>;</span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">s2</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">clone</span></span>(<span class="i">t</span>)</span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s2</span></span>.<span class="e Identifier"><span class="i">index</span></span> = <span class="e Identifier"><span class="i">states</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">states</span></span> ~= <span class="e Identifier"><span class="i">s2</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">s2</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">clone</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">f</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">f</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">clonedStates</span></span> = <span class="e Null"><span class="k">null</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">clonedTransitions</span></span> = <span class="e Null"><span class="k">null</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">f2</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entries</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">f2</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">clone</span></span>(<span class="i">t</span>)</span></span>;</span></span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">exits</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">f2</span></span>.<span class="e Identifier"><span class="i">exits</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">clone</span></span>(<span class="i">t</span>)</span></span>;</span></span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">f2</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">clone</span></span>(<span class="i">t</span>)</span></span>;</span></span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">f2</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">clone</span></span>(<span class="i">t</span>)</span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">f2</span></span>;</span>
    }</span></span></span>

    <span class="lc">//---------------------------------------------------------------------------------------------</span>
    <span class="lc">// Thompson constructions of NFA fragments</span>

    <span class="d Function"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">constructSingleChar</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">c</span></span>, <span class="o "><span class="t Identifier"><span class="i">predicate_t</span></span>.<span class="t Identifier"><span class="i">Type</span></span> <span class="i">type</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"constructCharFrag {}"</span>, <span class="i">c</span>)</span>;</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">trans</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">appendInput</span></span>(<span class="i">CharRange</span>!(<span class="i">char_t</span>)(<span class="i">c</span>))</span>;</span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">type</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">frag</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">trans</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span>    ~= <span class="e Identifier"><span class="i">trans</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">frag</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">constructChars</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">string_t</span></span> <span class="i">chars</span></span>, <span class="o "><span class="k">in</span> <span class="t Identifier"><span class="i">predicate_t</span></span>.<span class="t Identifier"><span class="i">Type</span></span> <span class="i">type</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">cc_t</span></span> <span class="i">cc</span>;</span></span>
        <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">chars</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span> )
            <span class="s Scope"><span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">cc</span></span>.<span class="t Identifier"><span class="i">add</span></span>(<span class="i">chars</span><span class="t Array">[<span class="t Identifier"><span class="i">i</span></span>]</span>);</span></span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">constructChars</span></span>(<span class="i">cc</span>, <span class="i">type</span>)</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">constructChars</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">cc_t</span></span>)</span> <span class="i">charclass</span></span>, <span class="o "><span class="k">in</span> <span class="t Identifier"><span class="i">predicate_t</span></span>.<span class="t Identifier"><span class="i">Type</span></span> <span class="i">type</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"constructChars type={}"</span>, <span class="i">type</span>)</span>;</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">trans</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">type</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans</span></span>.<span class="t Identifier"><span class="i">predicate</span></span>.<span class="t Identifier"><span class="i">setInput</span></span>(<span class="i">cc_t</span><span class="t CFunc"><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">charclass</span></span></span>)</span></span>);</span></span>

        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"-&gt; {}"</span>, <span class="i">trans</span>.<span class="i">predicate</span>.<span class="i">toString</span>)</span>;</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">frag</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">trans</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span>    ~= <span class="e Identifier"><span class="i">trans</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">frag</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">constructCharClass</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">predicate_t</span></span>.<span class="t Identifier"><span class="i">Type</span></span> <span class="i">type</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"constructCharClass type={}"</span>, <span class="i">type</span>)</span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">oldCursor</span> = <span class="e Identifier"><span class="i">cursor</span></span>;</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">trans</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span>;</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">negated</span>=<span class="e Bool"><span class="k">false</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> == <span class="e Char"><span class="cl">'^'</span></span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">negated</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
        }</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span>  <span class="i">last</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span>    <span class="i">have_range_start</span>,
                <span class="i">first_char</span> = <span class="e Bool"><span class="k">true</span></span>;</span></span>
        <span class="s For"><span class="k">for</span> ( ; <span class="e AndAnd"><span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">endOfPattern</span></span></span>()</span> &amp;&amp; <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> != <span class="e Char"><span class="cl">']'</span></span></span></span>; )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">c</span> = <span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span></span>
            <span class="s Switch"><span class="k">switch</span> ( <span class="e Identifier"><span class="i">c</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'-'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">first_char</span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans</span></span>.<span class="t Identifier"><span class="i">predicate</span></span>.<span class="t Identifier"><span class="i">appendInput</span></span>(<span class="i">range_t</span><span class="t CFunc"><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">c</span></span></span>)</span></span>);</span></span>
                        <span class="s Break"><span class="k">break</span>;</span>
                    }</span></span></span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Not">!<span class="e Identifier"><span class="i">have_range_start</span></span></span> )
                        <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"Missing range start for '-' operator after <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>)</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span>
                    <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Call"><span class="e Identifier"><span class="i">endOfPattern</span></span>()</span> || <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">peekPattern</span></span>()</span> == <span class="e Char"><span class="cl">']'</span></span></span></span> )
                        <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"Missing range end for '-' operator after <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>)</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span>
                    <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span></span>;</span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans</span></span>.<span class="t Identifier"><span class="i">predicate</span></span>.<span class="t Identifier"><span class="i">appendInput</span></span>(<span class="i">range_t</span><span class="t CFunc"><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">last</span></span></span>, <span class="o "><span class="t Identifier"><span class="i">c</span></span></span>)</span></span>);</span></span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">have_range_start</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
                    }</span></span></span></span></span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'<span class="es">\\</span>'</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">endOfPattern</span></span>()</span> )
                        <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"unexpected end of string after <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>)</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span></span>;</span>
                    <span class="s Switch"><span class="k">switch</span> ( <span class="e Identifier"><span class="i">c</span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'t'</span></span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\t</span>'</span></span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'n'</span></span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\n</span>'</span></span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Case"><span class="k">case</span> <span class="e Char"><span class="cl">'r'</span></span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Char"><span class="cl">'<span class="es">\r</span>'</span></span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                        <span class="s Default"><span class="k">default</span>:
                            <span class="s Scope"><span class="s Compound"><span class="s Break"><span class="k">break</span>;</span></span></span></span>
                    }</span></span></span>
                    <span class="s Goto"><span class="k">goto</span> <span class="k">default</span>;</span></span></span></span>
                <span class="s Default"><span class="k">default</span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">have_range_start</span></span> )
                        <span class="s Scope"><span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans</span></span>.<span class="t Identifier"><span class="i">predicate</span></span>.<span class="t Identifier"><span class="i">appendInput</span></span>(<span class="i">range_t</span><span class="t CFunc"><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">last</span></span></span>)</span></span>);</span></span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">last</span></span> = <span class="e Identifier"><span class="i">c</span></span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">have_range_start</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span></span></span></span>
            }</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first_char</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
        }</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">endOfPattern</span></span></span>()</span> )
            <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">readPattern</span></span>()</span>;</span></span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">last</span></span> != <span class="e Identifier"><span class="i">char_t</span></span>.<span class="e Identifier"><span class="i">init</span></span></span> )
            <span class="s Scope"><span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans</span></span>.<span class="t Identifier"><span class="i">predicate</span></span>.<span class="t Identifier"><span class="i">appendInput</span></span>(<span class="i">range_t</span><span class="t CFunc"><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">last</span></span></span>)</span></span>);</span></span></span></span>
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">" {}"</span>, <span class="i">pattern</span>[<span class="i">oldCursor</span>..<span class="i">cursor</span>])</span>;</span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">negated</span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tmp</span> = <span class="e Call"><span class="e Identifier"><span class="i">cc_t</span></span>(<span class="i">cc_t</span>.<span class="i">any_char</span>)</span>;</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">subtract</span></span>(<span class="i">trans</span>.<span class="i">predicate</span>.<span class="i">input</span>)</span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">input</span></span> = <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>
        }</span></span>
        <span class="k">else</span>
            <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span></span></span>
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"-&gt; {}"</span>, <span class="i">trans</span>.<span class="i">predicate</span>.<span class="i">toString</span>)</span>;</span></span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">type</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">frag</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">trans</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span>    ~= <span class="e Identifier"><span class="i">trans</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">frag</span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">constructBracket</span><span class="o ">(<span class="o "><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">frag_t</span></span>)</span></span> <span class="i">frags</span></span>, <span class="o "><span class="t Integral"><span class="k">uint</span></span> <span class="i">tag</span>=<span class="e Int"><span class="n">0</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"constructBracket"</span>)</span>;</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">entry</span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span>,
                <span class="i">exit</span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frags</span></span>.<span class="t Identifier"><span class="i">tail</span></span>.<span class="t Identifier"><span class="i">value</span></span>.<span class="t Identifier"><span class="i">setEntry</span></span>(<span class="i">entry</span>);</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frags</span></span>.<span class="t Identifier"><span class="i">tail</span></span>.<span class="t Identifier"><span class="i">value</span></span>.<span class="t Identifier"><span class="i">setExit</span></span>(<span class="i">exit</span>);</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">tag1</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span>,
                <span class="i">tag2</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tag1</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tag2</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">tag</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="lc">// make sure the tag indeces for bracket x are always</span>
            <span class="lc">// x*2 for the opening bracket and x*2+1 for the closing bracket</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tag1</span></span>.<span class="e Identifier"><span class="i">tag</span></span> = <span class="e PostIncr"><span class="e Identifier"><span class="i">tag</span></span>++</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tag2</span></span>.<span class="e Identifier"><span class="i">tag</span></span> = <span class="e Identifier"><span class="i">tag</span></span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tag1</span></span>.<span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">entry</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">exit</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> ~= <span class="e Identifier"><span class="i">tag2</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">frag</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">tag1</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">tag2</span></span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Identifier"><span class="i">frag</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">constructOneMore</span><span class="o ">(<span class="o "><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">frag_t</span></span>)</span></span> <span class="i">frags</span></span>, <span class="o "><span class="t Identifier"><span class="i">PriorityClass</span></span> <span class="i">prioClass</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"constructOneMore"</span>)</span>;</span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"too few arguments for + at <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$])</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">repeat</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>(<span class="i">prioClass</span>)</span>,
                <span class="i">cont</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">repeat</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cont</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">s</span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frags</span></span>.<span class="t Identifier"><span class="i">tail</span></span>.<span class="t Identifier"><span class="i">value</span></span>.<span class="t Identifier"><span class="i">setExit</span></span>(<span class="i">s</span>);</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> ~= <span class="e Identifier"><span class="i">repeat</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> ~= <span class="e Identifier"><span class="i">cont</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">frag</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span>.<span class="e Identifier"><span class="i">entries</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> ~= <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> ~= <span class="e Identifier"><span class="i">repeat</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">cont</span></span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Identifier"><span class="i">frag</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">constructZeroMore</span><span class="o ">(<span class="o "><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">frag_t</span></span>)</span></span> <span class="i">frags</span></span>, <span class="o "><span class="t Identifier"><span class="i">PriorityClass</span></span> <span class="i">prioClass</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"constructZeroMore"</span>)</span>;</span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"too few arguments for * at <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$])</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">enter</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>(<span class="i">prioClass</span>)</span>,
                <span class="i">repeat</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>(<span class="i">prioClass</span>)</span>,
                <span class="i">skip</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">skip</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">repeat</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">enter</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">entry</span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span>,
                <span class="i">exit</span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frags</span></span>.<span class="t Identifier"><span class="i">tail</span></span>.<span class="t Identifier"><span class="i">value</span></span>.<span class="t Identifier"><span class="i">setEntry</span></span>(<span class="i">entry</span>);</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frags</span></span>.<span class="t Identifier"><span class="i">tail</span></span>.<span class="t Identifier"><span class="i">value</span></span>.<span class="t Identifier"><span class="i">setExit</span></span>(<span class="i">exit</span>);</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">exit</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> ~= <span class="e Identifier"><span class="i">repeat</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">enter</span></span>.<span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">entry</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">frag</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">skip</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">enter</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">skip</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> ~= <span class="e Identifier"><span class="i">repeat</span></span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Identifier"><span class="i">frag</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">constructZeroOne</span><span class="o ">(<span class="o "><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">frag_t</span></span>)</span></span> <span class="i">frags</span></span>, <span class="o "><span class="t Identifier"><span class="i">PriorityClass</span></span> <span class="i">prioClass</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"constructZeroOne"</span>)</span>;</span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"too few arguments for ? at <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$])</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">use</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>(<span class="i">prioClass</span>)</span>,
                <span class="i">skip</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">use</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">skip</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">s</span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frags</span></span>.<span class="t Identifier"><span class="i">tail</span></span>.<span class="t Identifier"><span class="i">value</span></span>.<span class="t Identifier"><span class="i">setEntry</span></span>(<span class="i">s</span>);</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">use</span></span>.<span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">s</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">frag</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">use</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">skip</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exits</span></span> ~= <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span>.<span class="e Identifier"><span class="i">exits</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">skip</span></span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Identifier"><span class="i">frag</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">constructOccur</span><span class="o ">(<span class="o "><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">frag_t</span></span>)</span></span> <span class="i">frags</span></span>, <span class="o "><span class="t Integral"><span class="k">uint</span></span> <span class="i">minOccur</span></span>, <span class="o "><span class="t Integral"><span class="k">uint</span></span> <span class="i">maxOccur</span></span>, <span class="o "><span class="t Identifier"><span class="i">PriorityClass</span></span> <span class="i">prioClass</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"constructOccur {},{}"</span>, <span class="i">minOccur</span>, <span class="i">maxOccur</span>)</span>;</span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"too few arguments for {x,y} at <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$])</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">s</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span>  <span class="i">total</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>,
                <span class="i">prev</span>;</span></span>

        <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">minOccur</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">f</span> = <span class="e Call"><span class="e Identifier"><span class="i">clone</span></span>(<span class="i">frags</span>.<span class="i">tail</span>.<span class="i">value</span>)</span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">prev</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span></span>;</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">prev</span></span>.<span class="t Identifier"><span class="i">setExit</span></span>(<span class="i">s</span>);</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">f</span></span>.<span class="t Identifier"><span class="i">setEntry</span></span>(<span class="i">s</span>);</span></span>
            }</span></span>
            <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">total</span></span>.<span class="e Identifier"><span class="i">entries</span></span> = <span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entries</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">total</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> = <span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span></span>;</span>
            }</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">f</span></span></span>;</span>
        }</span></span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">maxOccur</span></span> == <span class="e Int"><span class="n">0</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">f</span> = <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">t</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">t</span></span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">t</span></span></span>;</span>

            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">exits</span></span> ~= <span class="e Identifier"><span class="i">t</span></span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> ~= <span class="e Identifier"><span class="i">t</span></span></span>;</span>

            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span></span>;</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">f</span></span>.<span class="t Identifier"><span class="i">setEntry</span></span>(<span class="i">s</span>);</span></span>

            <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">prev</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
                <span class="s Scope"><span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">prev</span></span>.<span class="t Identifier"><span class="i">setExit</span></span>(<span class="i">s</span>);</span></span></span>
            <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">total</span></span>.<span class="e Identifier"><span class="i">entries</span></span> = <span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entries</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">total</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> = <span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span></span>;</span>
            }</span></span></span>

            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">f</span></span></span>;</span>
        }</span></span></span>

        <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span> = <span class="e Identifier"><span class="i">minOccur</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">maxOccur</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">f</span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Minus"><span class="e Identifier"><span class="i">maxOccur</span></span>-<span class="e Int"><span class="n">1</span></span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">f</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">clone</span></span>(<span class="i">frags</span>.<span class="i">tail</span>.<span class="i">value</span>)</span></span>;</span></span>
            <span class="k">else</span>
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">f</span></span> = <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span></span>;</span></span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">trans_t</span></span> <span class="i">t</span> = <span class="e Call"><span class="e Identifier"><span class="i">addTransition</span></span>()</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">t</span></span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">t</span></span></span>;</span>

            <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">prev</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span></span>;</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">prev</span></span>.<span class="t Identifier"><span class="i">setExit</span></span>(<span class="i">s</span>);</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">f</span></span>.<span class="t Identifier"><span class="i">setEntry</span></span>(<span class="i">s</span>);</span></span>
            }</span></span>
            <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">total</span></span>.<span class="e Identifier"><span class="i">entries</span></span> = <span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entries</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">total</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> = <span class="e Identifier"><span class="i">f</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span></span>;</span>
            }</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">prev</span></span> = <span class="e Identifier"><span class="i">f</span></span></span>;</span>
        }</span></span></span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">total</span></span>.<span class="e Identifier"><span class="i">exits</span></span> = <span class="e Identifier"><span class="i">prev</span></span>.<span class="e Identifier"><span class="i">exits</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">total</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> = <span class="e Identifier"><span class="i">prev</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span></span>;</span>

        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Identifier"><span class="i">total</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">constructAltern</span><span class="o ">(<span class="o "><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">frag_t</span></span>)</span></span> <span class="i">frags</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"constructAltern"</span>)</span>;</span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> || <span class="e Identity"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">head</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span></span></span> )
            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"too few arguments for | at <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$])</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span>  <span class="i">frag</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>,
                <span class="i">f1</span> = <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span>,
                <span class="i">f2</span> = <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">prev</span></span>.<span class="e Identifier"><span class="i">value</span></span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> ~= <span class="e Identifier"><span class="i">f2</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> ~= <span class="e Identifier"><span class="i">f1</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">f2</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">f1</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">f2</span></span>.<span class="e Identifier"><span class="i">entries</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">f1</span></span>.<span class="e Identifier"><span class="i">entries</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exits</span></span> ~= <span class="e Identifier"><span class="i">f2</span></span>.<span class="e Identifier"><span class="i">exits</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exits</span></span> ~= <span class="e Identifier"><span class="i">f1</span></span>.<span class="e Identifier"><span class="i">exits</span></span></span>;</span>

        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Identifier"><span class="i">frag</span></span></span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">constructConcat</span><span class="o ">(<span class="o "><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">frag_t</span></span>)</span></span> <span class="i">frags</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tnfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"constructConcat"</span>)</span>;</span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> || <span class="e Identity"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">head</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span></span></span> )
            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"too few operands for concatenation at <span class="es">\"</span>"</span></span>~<span class="e Call"><span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString</span></span>(<span class="i">pattern</span>[<span class="i">cursor</span>..$])</span>.<span class="e Identifier"><span class="i">idup</span></span></span>~<span class="e String"><span class="sl">"<span class="es">\"</span>"</span></span></span>)</span>;</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span>  <span class="i">f1</span> = <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span>,
                <span class="i">f2</span> = <span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">prev</span></span>.<span class="e Identifier"><span class="i">value</span></span>;</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">state_t</span></span> <span class="i">state</span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">f2</span></span>.<span class="t Identifier"><span class="i">setExit</span></span>(<span class="i">state</span>);</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">f1</span></span>.<span class="t Identifier"><span class="i">setEntry</span></span>(<span class="i">state</span>);</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">frag_t</span></span> <span class="i">frag</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">frag_t</span></span></span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entries</span></span> ~= <span class="e Identifier"><span class="i">f2</span></span>.<span class="e Identifier"><span class="i">entries</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exits</span></span> ~= <span class="e Identifier"><span class="i">f1</span></span>.<span class="e Identifier"><span class="i">exits</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span> ~= <span class="e Identifier"><span class="i">f2</span></span>.<span class="e Identifier"><span class="i">entry_state</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frag</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span> ~= <span class="e Identifier"><span class="i">f1</span></span>.<span class="e Identifier"><span class="i">exit_state</span></span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">frags</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">frags</span></span> ~= <span class="e Identifier"><span class="i">frag</span></span></span>;</span>
    }</span></span></span></span>
}</span></span></span></span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">core</span>.<span class="i">Array</span>;</span>

<span class="bc">/* ************************************************************************************************
    Tagged DFA
**************************************************************************************************/</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Class"><span class="k">class</span> <span class="i">TDFA</span><span class="o ">(<span class="o "><span class="i">char_t</span></span>)</span>
<span class="d Compound">{
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">Predicate</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>    <span class="i">predicate_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharRange</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>    <span class="i">range_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>    <span class="i">charclass_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span>              <span class="i">string_t</span>;</span></span>

    <span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">CURRENT_POSITION_REGISTER</span> = <span class="e Comp">~<span class="e Int"><span class="n">0</span></span></span>;</span>

    <span class="bc">/* ********************************************************************************************
        Tag map assignment command
    **********************************************************************************************/</span>
    <span class="d Struct"><span class="k">struct</span> <span class="i">Command</span>
    <span class="d Compound">{
        <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span>        <span class="i">dst</span>,    <span class="lc">/// register index to recieve data</span>
                    <span class="i">src</span>;</span>    <span class="lc">/// register index or CURRENT_POSITION_REGISTER for current position</span>

        <span class="d Function"><span class="t Identifier"><span class="i">string</span></span> <span class="i">toString</span><span class="o ">()</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"{}&lt;-{}"</span>, <span class="i">dst</span>, <span class="i">src</span>==<span class="i">CURRENT_POSITION_REGISTER</span>?<span class="sl">"p"</span>:<span class="i">Format</span>.<span class="i">convert</span>(<span class="sl">"{}"</span>, <span class="i">src</span>))</span>.<span class="e Identifier"><span class="i">idup</span></span>;</span>
        }</span></span></span>

        <span class="bc">/* ****************************************************************************************
            Order transitions by the order of their predicates.
        ******************************************************************************************/</span>
        <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opCmp</span><span class="o ">(<span class="o "><span class="k">const</span> <span class="k">ref</span> <span class="t Identifier"><span class="i">Command</span></span> <span class="i">cmd</span></span>)</span> <span class="k">const</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">src</span></span> == <span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> != <span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">1</span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">src</span></span> != <span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> == <span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">dst</span></span> &lt; <span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">dst</span></span> == <span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">1</span></span>;</span>
        }</span></span></span>

        <span class="d StorageClass"><span class="k">const</span></span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">opEquals</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="k">const</span> <span class="t Identifier"><span class="i">Command</span></span> <span class="i">cmd</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Equal"><span class="e Identifier"><span class="i">dst</span></span> != <span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span></span> || <span class="e Equal"><span class="e Identifier"><span class="i">src</span></span> != <span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span>
        }</span></span></span>
    }</span></span>

    <span class="d Struct"><span class="k">struct</span> <span class="i">TagIndex</span>
    <span class="d Compound">{
        <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span>    <span class="i">tag</span>,
                <span class="i">index</span>;</span>
    }</span></span>

    <span class="bc">/* ********************************************************************************************
        TDFA state
    **********************************************************************************************/</span>
    <span class="d Class"><span class="k">class</span> <span class="i">State</span>
    <span class="d Compound">{
        <span class="d Enum"><span class="k">enum</span> <span class="i">Mode</span> {
            <span class="d EnumMember"><span class="i">GENERIC</span></span>, <span class="d EnumMember"><span class="i">MIXED</span></span>, <span class="d EnumMember"><span class="i">LOOKUP</span></span>
        }</span>

        <span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span>  <span class="i">LOOKUP_LENGTH</span> = <span class="e Int"><span class="n">256</span></span>,
                    <span class="i">INVALID_STATE</span> = <span class="e Int"><span class="n">255</span></span>;</span>

        <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span>            <span class="i">accept</span> = <span class="e Bool"><span class="k">false</span></span>;</span>
        <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span>            <span class="i">reluctant</span> = <span class="e Bool"><span class="k">false</span></span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>          <span class="i">index</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">Transition</span></span><span class="t Array">[]</span>    <span class="i">transitions</span>,
                        <span class="i">generic_transitions</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">Command</span></span><span class="t Array">[]</span>       <span class="i">finishers</span>;</span>

        <span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span>         <span class="i">lookup</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">Mode</span></span>            <span class="i">mode</span>;</span>

        <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">optimize</span><span class="o ">()</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="lc">// merge transitions with equal targets (same state index and equal commands)</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span><span class="t Array">[]</span> <span class="i">remove_indeces</span>;</span></span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">i</span></span>, <span class="o "><span class="i">t</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">transitions</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t2</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">transitions</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">i</span></span>+<span class="e Int"><span class="n">1</span></span></span> .. <span class="e Dollar">$</span>]</span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">t2</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span></span> || <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">t</span></span></span>.<span class="e Identifier"><span class="i">equalTarget</span></span>(<span class="i">t2</span>)</span></span> )
                        <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">t2</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">appendInput</span></span>(<span class="i">t</span>.<span class="i">predicate</span>)</span>;</span>
                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">remove_indeces</span></span> ~= <span class="e Identifier"><span class="i">i</span></span></span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span>
                }</span></span></span>
            }</span></span></span>

            <span class="lc">// remove transitions that have been merged into another</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">remove_indeces</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Transition</span></span><span class="t Array">[]</span> <span class="i">tmp</span>;</span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Minus"><span class="e Identifier"><span class="i">transitions</span></span>.<span class="e Identifier"><span class="i">length</span></span> - <span class="e Identifier"><span class="i">remove_indeces</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>;</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">next_remove</span>, <span class="i">next</span>;</span></span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">i</span></span>, <span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">transitions</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">next_remove</span></span> &lt; <span class="e Identifier"><span class="i">remove_indeces</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">remove_indeces</span></span>[<span class="e Identifier"><span class="i">next_remove</span></span>]</span> == <span class="e Identifier"><span class="i">i</span></span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">next_remove</span></span></span>;</span>
                        <span class="s Continue"><span class="k">continue</span>;</span>
                    }</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">tmp</span></span>[<span class="e PostIncr"><span class="e Identifier"><span class="i">next</span></span>++</span>]</span> = <span class="e Identifier"><span class="i">t</span></span></span>;</span>
                }</span></span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">transitions</span></span> = <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>

                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">transitions</span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span></span></span>
            }</span></span></span>
        }</span></span></span>

        <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">createLookup</span><span class="o ">()</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">count</span>;</span></span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">transitions</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">t</span></span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">exceedsMax</span></span>(<span class="i">LOOKUP_LENGTH</span>)</span> )
                    <span class="s Scope"><span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">count</span></span></span>;</span></span></span>
            }</span></span></span>

            <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Rel"><span class="e Identifier"><span class="i">count</span></span> &lt; <span class="e Int"><span class="n">1</span></span></span> || <span class="e Rel"><span class="e Identifier"><span class="i">transitions</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Identifier"><span class="i">INVALID_STATE</span></span></span></span> ) <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">generic_transitions</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Identifier"><span class="i">transitions</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">generic_transitions</span></span>[]</span> = <span class="e Identifier"><span class="i">transitions</span></span></span>;</span>
                <span class="s Return"><span class="k">return</span>;</span>
            }</span></span></span>

            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">transitions</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">exceedsMax</span></span>(<span class="i">LOOKUP_LENGTH</span>)</span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">generic_transitions</span></span> ~= <span class="e Identifier"><span class="i">t</span></span></span>;</span></span></span>
            }</span></span></span>

            <span class="lc">// setup lookup table</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">lookup</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Identifier"><span class="i">LOOKUP_LENGTH</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">lookup</span></span>[]</span> = <span class="e Identifier"><span class="i">INVALID_STATE</span></span></span>;</span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">i</span></span>, <span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">transitions</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">parts</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">l_</span></span> &gt;= <span class="e Identifier"><span class="i">lookup</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
                        <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
                    <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span> <span class="i">c</span> = <span class="e Identifier"><span class="i">p</span></span>.<span class="e Identifier"><span class="i">l_</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Call"><span class="e Identifier"><span class="i">min</span></span>(<span class="i">p</span>.<span class="i">r_</span>, <span class="i">LOOKUP_LENGTH</span>-<span class="n">1</span>)</span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">c</span></span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">lookup</span></span>[<span class="e Identifier"><span class="i">c</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ubyte</span></span>)<span class="e Identifier"><span class="i">i</span></span></span></span>;</span></span></span>
                }</span></span></span>
            }</span></span></span>

            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">mode</span></span> = <span class="e Cond"><span class="e Rel"><span class="e Identifier"><span class="i">count</span></span> &lt; <span class="e Identifier"><span class="i">transitions</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>? <span class="e Identifier"><span class="i">Mode</span></span>.<span class="e Identifier"><span class="i">MIXED</span></span> : <span class="e Identifier"><span class="i">Mode</span></span>.<span class="e Identifier"><span class="i">LOOKUP</span></span></span></span>;</span>
        }</span></span></span>
    }</span></span>

    <span class="bc">/* ********************************************************************************************
        TDFA transition
    **********************************************************************************************/</span>
    <span class="d Class"><span class="k">class</span> <span class="i">Transition</span>
    <span class="d Compound">{
        <span class="d Variables"><span class="t Identifier"><span class="i">State</span></span>       <span class="i">target</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">predicate_t</span></span> <span class="i">predicate</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">Command</span></span><span class="t Array">[]</span>   <span class="i">commands</span>;</span>

        <span class="bc">/* ****************************************************************************************
            Order transitions by the order of their predicates.
        ******************************************************************************************/</span>
        <span class="d StorageClass"><span class="k">override</span></span> <span class="d StorageClass"><span class="k">final</span></span> <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opCmp</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Object</span></span> <span class="i">o</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Transition</span></span> <span class="i">t</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">Transition</span></span>)<span class="e Identifier"><span class="i">o</span></span></span>;</span></span>
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Identity"><span class="e Identifier"><span class="i">t</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span>)</span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">opCmp</span></span>(<span class="i">t</span>.<span class="i">predicate</span>)</span>;</span>
        }</span></span></span>

        <span class="d StorageClass"><span class="k">final</span></span> <span class="d StorageClass"><span class="k">const</span></span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">opEquals</span><span class="o ">(<span class="o "><span class="k">const</span> <span class="t Identifier"><span class="i">Object</span></span> <span class="i">o</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">t</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">Transition</span></span>)</span>)<span class="e Identifier"><span class="i">o</span></span></span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">t</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Call"><span class="e Identifier"><span class="i">equalTarget</span></span>(<span class="i">t</span>)</span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span> == <span class="e Identifier"><span class="i">predicate</span></span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
        }</span></span></span>

        <span class="d StorageClass"><span class="k">const</span></span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">equalTarget</span><span class="o ">(<span class="o "><span class="k">in</span> <span class="t Identifier"><span class="i">Transition</span></span> <span class="i">t</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span>.<span class="e Identifier"><span class="i">index</span></span> != <span class="e Identifier"><span class="i">target</span></span>.<span class="e Identifier"><span class="i">index</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">commands</span></span>.<span class="e Identifier"><span class="i">length</span></span> != <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">commands</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>
            <span class="s Labeled"><span class="i">Louter</span>: <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">commands</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd2</span></span></span>; <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">commands</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span> == <span class="e Identifier"><span class="i">cmd2</span></span></span> )
                        <span class="s Scope"><span class="s Continue"><span class="k">continue</span> <span class="i">Louter</span>;</span></span></span>
                }</span></span></span>
                <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
            }</span></span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span>
        }</span></span></span>
    }</span></span>


    <span class="d Variables"><span class="t Identifier"><span class="i">State</span></span><span class="t Array">[]</span>     <span class="i">states</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">State</span></span>       <span class="i">start</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">Command</span></span><span class="t Array">[]</span>   <span class="i">initializer</span>;</span>
    <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span>        <span class="i">num_tags</span>;</span>

    <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span><span class="t Array">[<span class="t Identifier"><span class="i">TagIndex</span></span>]</span>  <span class="i">registers</span>;</span>
    <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span>            <span class="i">next_register</span>;</span>

    <span class="d Function"><span class="t Integral"><span class="k">uint</span></span> <span class="i">num_regs</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">next_register</span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Constructs the TDFA from the given TNFA using extended power set method
    **********************************************************************************************/</span>
    <span class="d Constructor"><span class="k">this</span><span class="o ">(<span class="o "><span class="t TemplateInstance"><span class="i">TNFA</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span> <span class="i">tnfa</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">num_tags</span></span>        = <span class="e Call"><span class="e Identifier"><span class="i">tnfa</span></span>.<span class="e Identifier"><span class="i">tagCount</span></span>()</span></span>;</span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">next_register</span></span>   = <span class="e Identifier"><span class="i">num_tags</span></span></span>;</span>
        <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span> = <span class="e Int"><span class="n">1</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt;= <span class="e Identifier"><span class="i">num_tags</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">TagIndex</span></span> <span class="i">ti</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ti</span></span>.<span class="e Identifier"><span class="i">tag</span></span> = <span class="e Identifier"><span class="i">i</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">registers</span></span>[<span class="e Identifier"><span class="i">ti</span></span>]</span> = <span class="e Minus"><span class="e Identifier"><span class="i">i</span></span>-<span class="e Int"><span class="n">1</span></span></span></span>;</span>
        }</span></span></span>

        <span class="lc">// create epsilon closure of TNFA start state</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">subset_start</span>    = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">SubsetState</span></span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span> <span class="i">se</span>             = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">StateElement</span></span></span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span> = <span class="e Identifier"><span class="i">tnfa</span></span>.<span class="e Identifier"><span class="i">start</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">subset_start</span></span>.<span class="e Identifier"><span class="i">elms</span></span> ~= <span class="e Identifier"><span class="i">se</span></span></span>;</span>

        <span class="lc">// apply lookbehind closure for string/line start</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">predicate_t</span></span> <span class="i">tmp_pred</span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">tmp_pred</span></span>.<span class="e Identifier"><span class="i">setInput</span></span>(<span class="i">CharClass</span>!(<span class="i">char_t</span>).<span class="i">line_startend</span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">subset_start</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">epsilonClosure</span></span>(<span class="i">lookbehindClosure</span>(<span class="i">epsilonClosure</span>(<span class="i">subset_start</span>, <span class="i">subset_start</span>), <span class="i">tmp_pred</span>), <span class="i">subset_start</span>)</span></span>;</span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">subset_start</span></span>.<span class="e Identifier"><span class="i">dfa_state</span></span> = <span class="e Identifier"><span class="i">start</span></span></span>;</span>

        <span class="lc">// generate initializer and finisher commands for TDFA start state</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">generateInitializers</span></span>(<span class="i">subset_start</span>);</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">generateFinishers</span></span>(<span class="i">subset_start</span>);</span></span>

        <span class="lc">// initialize stack for state traversal</span>
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">SubsetState</span></span>)</span></span>  <span class="i">subset_states</span>   = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">SubsetState</span></span>)</span></span></span>,
                            <span class="i">unmarked</span>        = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">SubsetState</span></span>)</span></span></span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">subset_states</span></span>   ~= <span class="e Identifier"><span class="i">subset_start</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">unmarked</span></span>        ~= <span class="e Identifier"><span class="i">subset_start</span></span></span>;</span>
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"<span class="es">\n</span>{} = {}<span class="es">\n</span>"</span>, <span class="i">subset_start</span>.<span class="i">dfa_state</span>.<span class="i">index</span>, <span class="i">subset_start</span>.<span class="i">toString</span>)</span>;</span></span>

        <span class="s While"><span class="k">while</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">unmarked</span></span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">state</span> = <span class="e Identifier"><span class="i">unmarked</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span>;</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">unmarked</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>

            <span class="lc">// create transitions for each class, creating new states when necessary</span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">pred</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">disjointPredicates</span></span>(<span class="i">state</span>)</span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="lc">// find NFA state we reach with pred</span>
                <span class="lc">// reach will set predicate type correctly</span>
                <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"from {} with {} reach"</span>, <span class="i">state</span>.<span class="i">dfa_state</span>.<span class="i">index</span>, <span class="i">pred</span>.<span class="i">toString</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">target</span> = <span class="e Call"><span class="e Identifier"><span class="i">reach</span></span>(<span class="i">state</span>, <span class="i">pred</span>)</span>;</span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">target</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                    <span class="s Continue"><span class="k">continue</span>;</span>
                    <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">" nothing - lookbehind at beginning, skipping"</span>)</span>;</span></span>
                }</span></span></span>
                <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">" {}"</span>, <span class="i">target</span>.<span class="i">toString</span>)</span>;</span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">target</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">epsilonClosure</span></span>(<span class="i">lookbehindClosure</span>(<span class="i">epsilonClosure</span>(<span class="i">target</span>, <span class="i">state</span>), <span class="i">pred</span>), <span class="i">state</span>)</span></span>;</span>

                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Transition</span></span> <span class="i">trans</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Transition</span></span></span>;</span></span>
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">dfa_state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> ~= <span class="e Identifier"><span class="i">trans</span></span></span>;</span>
                <span class="s Debug"><span class="k">debug</span> (<span class="i">tdfa_new_trans</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"Creating with pred: {}"</span>, <span class="i">pred</span>)</span>;</span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">predicate</span></span> = <span class="e Identifier"><span class="i">pred</span></span></span>;</span>

                <span class="lc">// generate indeces for pos commands</span>
                <span class="lc">// delay creation of pos command until we have reorder-commands</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span><span class="t Array">[<span class="t Integral"><span class="k">uint</span></span>]</span> <span class="i">cmds</span> = <span class="e Null"><span class="k">null</span></span>;</span></span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">target</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">tag</span></span>, <span class="o "><span class="k">ref</span> <span class="i">index</span></span></span>; <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">tags</span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">found</span>=<span class="e Bool"><span class="k">false</span></span>;</span></span>
                        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">e2</span></span></span>; <span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Pointer">*</span> <span class="i">i</span> = <span class="e In"><span class="e Identifier"><span class="i">tag</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">e2</span></span>.<span class="e Identifier"><span class="i">tags</span></span></span>;</span></span>
                            <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">i</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Deref">*<span class="e Identifier"><span class="i">i</span></span></span> == <span class="e Identifier"><span class="i">index</span></span></span></span> ) <span class="s Scope"><span class="s Compound">{
                                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">found</span></span>=<span class="e Bool"><span class="k">true</span></span></span>;</span>
                                <span class="s Break"><span class="k">break</span>;</span>
                            }</span></span></span>
                        }</span></span></span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Not">!<span class="e Identifier"><span class="i">found</span></span></span> )
                        <span class="s Scope"><span class="s Compound">{
                            <span class="lc">// if index is &lt; 0 it is a temporary index</span>
                            <span class="lc">// used only to distinguish the state from existing ones.</span>
                            <span class="lc">// the previous index can be reused instead.</span>
                            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">index</span></span> &lt; <span class="e Int"><span class="n">0</span></span></span> )
                                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">index</span></span> = <span class="e Minus"><span class="e Sign">-<span class="e Identifier"><span class="i">index</span></span></span>-<span class="e Int"><span class="n">1</span></span></span></span>;</span></span></span>
                            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">cmds</span></span>[<span class="e Identifier"><span class="i">tag</span></span>]</span> = <span class="e Identifier"><span class="i">index</span></span></span>;</span>
                        }</span></span>
                        <span class="k">else</span>
                            <span class="s Scope"><span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">index</span></span>&gt;=<span class="e Int"><span class="n">0</span></span></span>)</span>;</span></span></span>
                    }</span></span></span>
                }</span></span></span>

                <span class="lc">// check whether a state exists that is identical except for tag index reorder-commands</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">exists</span>=<span class="e Bool"><span class="k">false</span></span>;</span></span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">equivTarget</span></span></span>; <span class="e Identifier"><span class="i">subset_states</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">reorderTagIndeces</span></span>(<span class="i">target</span>, <span class="i">equivTarget</span>, <span class="i">state</span>, <span class="i">trans</span>)</span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">equivTarget</span></span></span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">exists</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                        <span class="s Break"><span class="k">break</span>;</span>
                    }</span></span></span>
                }</span></span></span>
                <span class="lc">// else create new target state</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Not">!<span class="e Identifier"><span class="i">exists</span></span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">State</span></span> <span class="i">ts</span> = <span class="e Call"><span class="e Identifier"><span class="i">addState</span></span>()</span>;</span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">target</span></span>.<span class="e Identifier"><span class="i">dfa_state</span></span> = <span class="e Identifier"><span class="i">ts</span></span></span>;</span>
                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">subset_states</span></span>   ~= <span class="e Identifier"><span class="i">target</span></span></span>;</span>
                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">unmarked</span></span>        ~= <span class="e Identifier"><span class="i">target</span></span></span>;</span>
                    <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa_add</span>) <span class="s Compound">{
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"<span class="es">\n</span>Added {} = {}<span class="es">\n</span>"</span>, <span class="i">target</span>.<span class="i">dfa_state</span>.<span class="i">index</span>, <span class="i">target</span>.<span class="i">toString</span>)</span>;</span>
                    }</span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">generateFinishers</span></span>(<span class="i">target</span>);</span></span>
                }</span></span></span>

                <span class="lc">// now generate pos commands, rewriting reorder-commands if existent</span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">tag</span></span>, <span class="o "><span class="i">index</span></span></span>; <span class="e Identifier"><span class="i">cmds</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="lc">// check whether reordering used this tag, if so, overwrite the command directly,</span>
                    <span class="lc">// for it's effect would be overwritten by a subsequent pos-command anyway</span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">reg</span> = <span class="e Call"><span class="e Identifier"><span class="i">registerFromTagIndex</span></span>(<span class="i">tag</span>, <span class="i">index</span>)</span>;</span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">found</span> = <span class="e Bool"><span class="k">false</span></span>;</span></span>
                    <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="k">ref</span> <span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">commands</span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> == <span class="e Identifier"><span class="i">reg</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">found</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span>
                        }</span></span></span>
                    }</span></span></span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Not">!<span class="e Identifier"><span class="i">found</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Command</span></span> <span class="i">cmd</span>;</span></span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span> = <span class="e Identifier"><span class="i">reg</span></span></span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span>;</span>
                        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">commands</span></span> ~= <span class="e Identifier"><span class="i">cmd</span></span></span>;</span>
                    }</span></span></span>
                }</span></span></span>

                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">target</span></span>.<span class="e Identifier"><span class="i">dfa_state</span></span></span>;</span>
                <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Compound">{
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"=&gt; from {} with {} reach {}"</span>, <span class="i">state</span>.<span class="i">dfa_state</span>.<span class="i">index</span>, <span class="i">pred</span>.<span class="i">toString</span>, <span class="i">target</span>.<span class="i">dfa_state</span>.<span class="i">index</span>)</span>;</span>
                }</span></span>
            }</span></span></span>

            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">dfa_state</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
        }</span></span></span>

        <span class="lc">// renumber registers continuously</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span><span class="t Array">[<span class="t Integral"><span class="k">uint</span></span>]</span>  <span class="i">regNums</span>;</span></span>

        <span class="s For"><span class="k">for</span> ( <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">next_register</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span> <span class="e Rel"><span class="e Identifier"><span class="i">next_register</span></span> &lt; <span class="e Identifier"><span class="i">num_tags</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">next_register</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">regNums</span></span>[<span class="e Identifier"><span class="i">next_register</span></span>]</span> = <span class="e Identifier"><span class="i">next_register</span></span></span>;</span></span></span>

        <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">renumberCommand</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="t Identifier"><span class="i">Command</span></span> <span class="i">cmd</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> != <span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span> &amp;&amp; <span class="e Identity"><span class="e Paren">(<span class="e In"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">regNums</span></span></span>)</span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">regNums</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span>]</span> = <span class="e PostIncr"><span class="e Identifier"><span class="i">next_register</span></span>++</span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Paren">(<span class="e In"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">regNums</span></span></span>)</span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">regNums</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span>]</span> = <span class="e PostIncr"><span class="e Identifier"><span class="i">next_register</span></span>++</span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> != <span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">regNums</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span>]</span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">regNums</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span>]</span></span>;</span>
        }</span></span></span></span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">state</span></span></span>; <span class="e Identifier"><span class="i">states</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="k">ref</span> <span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">finishers</span></span> )
                <span class="s Scope"><span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">renumberCommand</span></span>(<span class="i">cmd</span>);</span></span></span></span>
            <span class="lc">// make sure pos-commands are executed after reorder-commands and</span>
            <span class="lc">// reorder-commands do not overwrite each other</span>
            <span class="s Expression"><span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">finishers</span></span>.<span class="e Identifier"><span class="i">sort</span></span>;</span>

            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">trans</span></span></span>; <span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="k">ref</span> <span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">commands</span></span> )
                    <span class="s Scope"><span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">renumberCommand</span></span>(<span class="i">cmd</span>);</span></span></span></span>
                <span class="s Expression"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">commands</span></span>.<span class="e Identifier"><span class="i">sort</span></span>;</span>
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">compile</span></span>()</span>;</span>
            }</span></span></span>
        }</span></span></span>

        <span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>)
        <span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="k">ref</span> <span class="i">v</span></span></span>; <span class="e Identifier"><span class="i">registers</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Paren">(<span class="e In"><span class="e Identifier"><span class="i">v</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">regNums</span></span></span>)</span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">v</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">regNums</span></span>[<span class="e Identifier"><span class="i">v</span></span>]</span></span>;</span></span></span>
            }</span></span></span>
        }</span></span>

        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">minimizeDFA</span></span>()</span>;</span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">state</span></span></span>; <span class="e Identifier"><span class="i">states</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">state</span></span>.<span class="e Identifier"><span class="i">createLookup</span></span>()</span>;</span></span></span>

        <span class="lc">// TODO: optimize memory layout of TDFA</span>

        <span class="lc">// TODO: add lookahead for string-end somewhere</span>
        <span class="lc">// TODO: mark dead-end states (not leaving a non-finishing susbet)</span>
        <span class="lc">// TODO: mark states that can leave the finishing subset of DFA states or use a greedy transition</span>
        <span class="lc">//       (execution may stop in that state)</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Print the TDFA (tabular representation of the delta function)
    **********************************************************************************************/</span>
    <span class="d Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">print</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"#tags = {}"</span>, <span class="i">num_tags</span>)</span>;</span>

        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">tis</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">TagIndex</span></span><span class="t Array">[<span class="e Identifier"><span class="i">registers</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">k</span></span>, <span class="o "><span class="i">v</span></span></span>; <span class="e Identifier"><span class="i">registers</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">tis</span></span> [<span class="e Identifier"><span class="i">v</span></span>]</span> = <span class="e Identifier"><span class="i">k</span></span></span>;</span></span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">r</span></span>, <span class="o "><span class="i">ti</span></span></span>; <span class="e Identifier"><span class="i">tis</span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"tag({},{}) in reg {}"</span>, <span class="i">ti</span>.<span class="i">tag</span>, <span class="i">ti</span>.<span class="i">index</span>, <span class="i">r</span>)</span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"Initializer:"</span>)</span>;</span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">initializer</span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"{}"</span>, <span class="i">cmd</span>.<span class="i">toString</span>)</span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"Delta function:"</span>)</span>;</span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span></span>, <span class="o "><span class="i">s</span></span></span>; <span class="e Identifier"><span class="i">states</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"{}{:d2}{}"</span>, <span class="i">s</span> <span class="k">is</span> <span class="i">start</span>?<span class="sl">"&gt;"</span>:<span class="sl">" "</span>, <span class="i">i</span>, <span class="i">s</span>.<span class="i">accept</span>?<span class="sl">"*"</span>:<span class="sl">" "</span>)</span>;</span>

            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">first</span>=<span class="e Bool"><span class="k">true</span></span>;</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">" {"</span>)</span>;</span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"{}{}-&gt;{} ("</span>, <span class="i">first</span>?<span class="sl">""</span>:<span class="sl">", "</span>, <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">toString</span>, <span class="i">t</span>.<span class="i">target</span>.<span class="i">index</span>)</span>;</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">firstcmd</span>=<span class="e Bool"><span class="k">true</span></span>;</span></span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">commands</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">firstcmd</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">firstcmd</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">","</span>)</span>;</span></span></span>
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"{}"</span>, <span class="i">cmd</span>.<span class="i">toString</span>)</span>;</span>
                }</span></span></span>
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">")"</span>)</span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
            }</span></span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"} ("</span>)</span>;</span>

            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">firstcmd</span>=<span class="e Bool"><span class="k">true</span></span>;</span></span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">finishers</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">firstcmd</span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">firstcmd</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">","</span>)</span>;</span></span></span>
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"{}"</span>, <span class="i">cmd</span>.<span class="i">toString</span>)</span>;</span>
            }</span></span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">")"</span>)</span>;</span>
        }</span></span></span>
    }</span></span></span></span>

<span class="d Protection"><span class="k">private</span></span>:
    <span class="bc">/* ********************************************************************************************
        A (TNFA state, tags) pair element of a subset state.
    **********************************************************************************************/</span>
    <span class="d Compound"><span class="d Class"><span class="k">class</span> <span class="i">StateElement</span>
    <span class="d Compound">{
        <span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFAState</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>  <span class="i">nfa_state</span>;</span>
        <span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[<span class="t Integral"><span class="k">uint</span></span>]</span>           <span class="i">tags</span>;</span>
        <span class="lc">// use place-value priority with 2 places, value(maxPrio) &gt; value(lastPrio)</span>
        <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span>                <span class="i">maxPriority</span>,
                            <span class="i">lastPriority</span>;</span>

        <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">prioGreater</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">StateElement</span></span> <span class="i">se</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">maxPriority</span></span> &lt; <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">maxPriority</span></span> == <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">lastPriority</span></span> != <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span></span>)</span>;</span>
                <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Identifier"><span class="i">lastPriority</span></span> &lt; <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span></span>;</span>
            }</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
        }</span></span></span>

        <span class="d StorageClass"><span class="k">override</span></span> <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opCmp</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">Object</span></span> <span class="i">o</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span> <span class="i">se</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">StateElement</span></span>)<span class="e Identifier"><span class="i">o</span></span></span>;</span></span>
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Identity"><span class="e Identifier"><span class="i">se</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span>)</span>;</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">maxPriority</span></span> &lt; <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">1</span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">maxPriority</span></span> == <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">lastPriority</span></span> == <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span></span> )
                    <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span></span></span>
                <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Identifier"><span class="i">lastPriority</span></span> &lt; <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span></span>;</span>
            }</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>;</span>
        }</span></span></span>

        <span class="d StorageClass"><span class="k">override</span></span> <span class="d Function"><span class="t Identifier"><span class="i">string</span></span> <span class="i">toString</span><span class="o ">()</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">str</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"{} p{}.{} {{"</span>, <span class="i">nfa_state</span>.<span class="i">index</span>, <span class="i">maxPriority</span>, <span class="i">lastPriority</span>)</span></span>;</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">first</span> = <span class="e Bool"><span class="k">true</span></span>;</span></span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">k</span></span>, <span class="o "><span class="i">v</span></span></span>; <span class="e Identifier"><span class="i">tags</span></span> ) <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">str</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"{}m({},{})"</span>, <span class="i">first</span>?<span class="sl">""</span>:<span class="sl">","</span>, <span class="i">k</span>, <span class="i">v</span>)</span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
            }</span></span></span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">str</span></span> ~= <span class="e String"><span class="sl">"}"</span></span></span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">str</span></span>.<span class="e Identifier"><span class="i">idup</span></span>;</span>
        }</span></span></span>
    }</span></span>

    <span class="bc">/* ********************************************************************************************
        Represents a state in the NFA to DFA conversion.
        Contains the set of states (StateElements) the NFA might be in at the same time and the
        corresponding DFA state that we create.
    **********************************************************************************************/</span>
    <span class="d Class"><span class="k">class</span> <span class="i">SubsetState</span>
    <span class="d Compound">{
        <span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span><span class="t Array">[]</span>  <span class="i">elms</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">State</span></span>           <span class="i">dfa_state</span>;</span>

        <span class="d Constructor"><span class="k">this</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">StateElement</span></span><span class="t Array">[]</span> <span class="i">elms</span>=<span class="e Null"><span class="k">null</span></span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e This"><span class="k">this</span></span>.<span class="e Identifier"><span class="i">elms</span></span> = <span class="e Identifier"><span class="i">elms</span></span></span>;</span>
        }</span></span></span>

        <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opApply</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span> <span class="o ">(<span class="o "><span class="k">ref</span> <span class="t TemplateInstance"><span class="i">TNFATransition</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span></span>)</span></span> <span class="i">dg</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">res</span>;</span></span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">elm</span></span></span>; <span class="e Identifier"><span class="i">elms</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">elm</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span>(<span class="i">t</span>)</span></span>;</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">res</span></span> )
                        <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span></span></span>
                }</span></span></span>
            }</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
        }</span></span></span>

        <span class="d StorageClass"><span class="k">override</span></span> <span class="d Function"><span class="t Identifier"><span class="i">string</span></span> <span class="i">toString</span><span class="o ">()</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span> <span class="i">str</span> = <span class="e String"><span class="sl">"[ "</span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">first</span> = <span class="e Bool"><span class="k">true</span></span>;</span></span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">s</span></span></span>; <span class="e Identifier"><span class="i">elms</span></span> ) <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Not">!<span class="e Identifier"><span class="i">first</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">str</span></span> ~= <span class="e String"><span class="sl">", "</span></span></span>;</span></span></span>
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">str</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
            }</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Cat"><span class="e Identifier"><span class="i">str</span></span>~<span class="e String"><span class="sl">" ]"</span></span></span>;</span>
        }</span></span></span>
    }</span></span>

    <span class="bc">/* ********************************************************************************************
        Temporary structure used for disjoint predicate computation
    **********************************************************************************************/</span>
    <span class="d Struct"><span class="k">struct</span> <span class="i">Mark</span>
    <span class="d Compound">{
        <span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span>  <span class="i">c</span>;</span>
        <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span>    <span class="i">end</span>;</span>    <span class="lc">/// false = start of range</span>

        <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opCmp</span><span class="o ">(<span class="o "><span class="k">const</span> <span class="k">ref</span> <span class="t Identifier"><span class="i">Mark</span></span> <span class="i">m</span></span>)</span> <span class="k">const</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt; <span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &gt; <span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">1</span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">end</span></span> &lt; <span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">end</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">end</span></span> &gt; <span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">end</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">1</span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span>
        }</span></span></span>
    }</span></span>

    <span class="bc">/* ********************************************************************************************
        Calculates the register index for a given tag map entry. The TDFA implementation uses
        registers to save potential tag positions, the index space gets linearized here.

        Params:     tag =   tag number
                    index = tag map index
        Returns:    index of the register to use for the tag map entry
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">uint</span></span> <span class="i">registerFromTagIndex</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">uint</span></span> <span class="i">tag</span></span>, <span class="o "><span class="t Integral"><span class="k">uint</span></span> <span class="i">index</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">index</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">TagIndex</span></span> <span class="i">ti</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ti</span></span>.<span class="e Identifier"><span class="i">tag</span></span> = <span class="e Identifier"><span class="i">tag</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ti</span></span>.<span class="e Identifier"><span class="i">index</span></span> = <span class="e Identifier"><span class="i">index</span></span></span>;</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span><span class="t Pointer">*</span> <span class="i">i</span> = <span class="e In"><span class="e Identifier"><span class="i">ti</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">registers</span></span></span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">i</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
                <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Deref">*<span class="e Identifier"><span class="i">i</span></span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">registers</span></span>[<span class="e Identifier"><span class="i">ti</span></span>]</span> = <span class="e PostIncr"><span class="e Identifier"><span class="i">next_register</span></span>++</span></span>;</span>
        }</span></span>
        <span class="k">else</span>
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Minus"><span class="e Identifier"><span class="i">tag</span></span>-<span class="e Int"><span class="n">1</span></span></span>;</span></span></span>
    }</span></span></span>

    <span class="d Variables"><span class="t Identifier"><span class="i">Mark</span></span><span class="t Array">[]</span> <span class="i">marks_</span>;</span>

    <span class="bc">/* ********************************************************************************************
        Add new TDFA state to the automaton.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Identifier"><span class="i">State</span></span> <span class="i">addState</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">State</span></span> <span class="i">s</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">State</span></span></span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">index</span></span> = <span class="e Identifier"><span class="i">states</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">states</span></span> ~= <span class="e Identifier"><span class="i">s</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">s</span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Creates disjoint predicates from all outgoing, potentially overlapping TNFA transitions.

        Params:     state = SubsetState to create the predicates from
        Returns:    List of disjoint predicates that can be used for a DFA state
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Identifier"><span class="i">predicate_t</span></span><span class="t Array">[]</span> <span class="i">disjointPredicates</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">state</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharRange</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span> <span class="i">range_t</span>;</span></span></span>
        <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"disjointPredicates()"</span>)</span>;</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">num_marks</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">state</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="lc">// partitioning will consider lookbehind transitions,</span>
            <span class="lc">// st. lb-closure will not expand for transitions with a superset of the lb-predicate</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"{}"</span>, <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">toString</span>)</span>;</span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">marks_</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt; <span class="e Plus"><span class="e Identifier"><span class="i">num_marks</span></span>+<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">getInput</span></span>()</span>.<span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">marks_</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">num_marks</span></span>+<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">getInput</span></span>()</span>.<span class="e Identifier"><span class="i">parts</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span></span>;</span></span></span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">p</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">getInput</span></span>()</span>.<span class="e Identifier"><span class="i">parts</span></span> ) <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">marks_</span></span>[<span class="e PostIncr"><span class="e Identifier"><span class="i">num_marks</span></span>++</span>]</span> = <span class="e Call"><span class="e Identifier"><span class="i">Mark</span></span>(<span class="i">p</span>.<span class="i">l</span>(), <span class="k">false</span>)</span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">marks_</span></span>[<span class="e PostIncr"><span class="e Identifier"><span class="i">num_marks</span></span>++</span>]</span> = <span class="e Call"><span class="e Identifier"><span class="i">Mark</span></span>(<span class="i">p</span>.<span class="i">r</span>(), <span class="k">true</span>)</span></span>;</span>
                }</span></span></span>
            }</span></span></span>
        }</span></span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">num_marks</span></span> &lt;= <span class="e Int"><span class="n">1</span></span></span> )
            <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Exception</span></span>(<span class="e String"><span class="sl">"disjointPredicates: No transitions in subset state"</span></span>)</span>;</span></span></span>

        <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"<span class="es">\n</span>sorting..."</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span></span>
        <span class="lc">// using built-in sort somtimes gives an AV in TypeInfo.swap</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">quickSort</span></span>(<span class="i">marks_</span><span class="t Array">[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">num_marks</span></span>]</span>);</span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Index"><span class="e Not">!<span class="e Identifier"><span class="i">marks_</span></span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">end</span></span>)</span>;</span>

        <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"<span class="es">\n</span>sorted marks:<span class="es">\n</span>"</span>)</span>;</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">first</span>=<span class="e Bool"><span class="k">true</span></span>;</span></span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">m</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">marks_</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">num_marks</span></span>]</span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">first</span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">","</span>)</span>;</span></span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span> &gt; <span class="e Int"><span class="n">0x20</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span> &lt; <span class="e Int"><span class="n">0x7f</span></span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"{}{}"</span>, <span class="i">m</span>.<span class="i">end</span>?<span class="sl">"e"</span>:<span class="sl">"s"</span>, <span class="i">m</span>.<span class="i">c</span>)</span>;</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"{}{:x}"</span>, <span class="i">m</span>.<span class="i">end</span>?<span class="sl">"e"</span>:<span class="sl">"s"</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">m</span>.<span class="i">c</span>)</span>;</span></span></span>
            }</span></span></span>
            <span class="s Expression"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">newline</span></span>;</span>
        }</span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>  <span class="i">next</span>,
                <span class="i">active</span> = <span class="e Int"><span class="n">1</span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">char_t</span></span>  <span class="i">start</span> = <span class="e Index"><span class="e Identifier"><span class="i">marks_</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">c</span></span>,
                <span class="i">end</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">range_t</span></span><span class="t Array">[]</span>   <span class="i">disjoint</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">range_t</span></span><span class="t Array">[<span class="e Plus"><span class="e Div"><span class="e Identifier"><span class="i">num_marks</span></span>/<span class="e Int"><span class="n">2</span></span></span>+<span class="e Int"><span class="n">1</span></span></span>]</span></span>;</span></span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">m</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">marks_</span></span>[<span class="e Int"><span class="n">1</span></span> .. <span class="e Identifier"><span class="i">num_marks</span></span>]</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">end</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">active</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>)</span>;</span>
                <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">active</span></span></span>;</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span> &lt; <span class="e Identifier"><span class="i">start</span></span></span> )
                    <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">end</span></span> = <span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span></span>;</span>
                <span class="lc">// the next range cannot start at the same pos</span>
                <span class="lc">// because starts are sorted before endings</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">active</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">m</span></span></span>.<span class="e Identifier"><span class="i">c</span></span>;</span></span></span>
            }</span></span>
            <span class="k">else</span>
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">active</span></span></span>;</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">active</span></span> == <span class="e Int"><span class="n">1</span></span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="lc">// skip uncovered interval</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span> &gt; <span class="e Identifier"><span class="i">start</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span></span>;</span>
                        <span class="s Continue"><span class="k">continue</span>;</span>
                    }</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">end</span></span> = <span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span></span>;</span>
                    <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">m</span></span></span>.<span class="e Identifier"><span class="i">c</span></span>;</span>
                }</span></span>
                <span class="lc">// skip range start if cursor already marks it</span>
                <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Identifier"><span class="i">start</span></span></span> )
                    <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">end</span></span> = <span class="e Minus"><span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span>-<span class="e Int"><span class="n">1</span></span></span></span>;</span></span></span></span></span>
            }</span></span></span>

            <span class="lc">// save range</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">disjoint</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt;= <span class="e Identifier"><span class="i">next</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">disjoint</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Mul"><span class="e Identifier"><span class="i">disjoint</span></span>.<span class="e Identifier"><span class="i">length</span></span>*<span class="e Int"><span class="n">2</span></span></span></span>;</span></span></span>

            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">disjoint</span></span>[<span class="e Identifier"><span class="i">next</span></span>]</span>.<span class="e Identifier"><span class="i">l_</span></span> = <span class="e Identifier"><span class="i">start</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">disjoint</span></span>[<span class="e Identifier"><span class="i">next</span></span>]</span>.<span class="e Identifier"><span class="i">r_</span></span> = <span class="e Identifier"><span class="i">end</span></span></span>;</span>
            <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">next</span></span></span>;</span>

            <span class="lc">// advance cursor</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">start</span></span> = <span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">c</span></span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">disjoint</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Identifier"><span class="i">next</span></span></span>;</span>

        <span class="lc">// merge isolated ranges into sets of ranges</span>
        <span class="lc">// no range in a set may occur separated from the others in any predicate</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">predicate_t</span></span><span class="t Array">[]</span>   <span class="i">preds</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">preds</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Int"><span class="n">1</span></span></span>;</span>
        <span class="s Labeled"><span class="i">Lmerge</span>: <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">r</span></span></span>; <span class="e Identifier"><span class="i">disjoint</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Index"><span class="e Identifier"><span class="i">preds</span></span>[<span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
                <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Index"><span class="e Identifier"><span class="i">preds</span></span>[<span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span>.<span class="e Identifier"><span class="i">appendInput</span></span>(<span class="i">r</span>)</span>;</span></span>
            <span class="k">else</span>
            <span class="s Scope"><span class="s Compound">{
                <span class="lc">// we can merge r into the current predicate if</span>
                <span class="lc">// pred contains r &lt;=&gt; pred contains all the other ranges</span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">state</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> == <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span> )
                        <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>

                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">getInput</span></span>()</span>.<span class="e Identifier"><span class="i">contains</span></span>(<span class="i">r</span>)</span>
                        != <span class="e Call"><span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">getInput</span></span>()</span>.<span class="e Identifier"><span class="i">contains</span></span>(<span class="i">preds</span>[$-<span class="n">1</span>].<span class="i">getInput</span>())</span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">preds</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">preds</span></span>.<span class="e Identifier"><span class="i">length</span></span>+<span class="e Int"><span class="n">1</span></span></span></span>;</span>
                        <span class="s Break"><span class="k">break</span>;</span>
                    }</span></span></span>
                }</span></span></span>
                <span class="s Expression"><span class="e Call"><span class="e Index"><span class="e Identifier"><span class="i">preds</span></span>[<span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span>.<span class="e Identifier"><span class="i">appendInput</span></span>(<span class="i">r</span>)</span>;</span>
            }</span></span></span>
        }</span></span></span></span>

        <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"<span class="es">\n</span>disjoint ranges:<span class="es">\n</span>"</span>)</span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span>=<span class="e Bool"><span class="k">true</span></span></span>;</span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">r</span></span></span>; <span class="e Identifier"><span class="i">disjoint</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">first</span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">","</span>)</span>;</span></span></span>
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"{}"</span>, <span class="i">r</span>)</span>;</span>
            }</span></span></span>
            <span class="s Expression"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">newline</span></span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"<span class="es">\n</span>disjoint predicates:<span class="es">\n</span>"</span>)</span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span>=<span class="e Bool"><span class="k">true</span></span></span>;</span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="k">ref</span> <span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">preds</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">first</span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">","</span>)</span>;</span></span></span>
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">format</span></span>(<span class="sl">"{}"</span>, <span class="i">p</span>.<span class="i">toString</span>)</span>;</span>
            }</span></span></span>
            <span class="s Expression"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">newline</span></span>;</span>
        }</span></span>

        <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"disjointPredicates() end"</span>)</span>;</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">preds</span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Finds all TNFA states that can be reached directly with the given predicate and creates
        a new SubsetState containing those target states.

        Params:     subst = SubsetState to start from
                    pred =  predicate that is matched against outgoing transitions
        Returns:    SubsetState containing the reached target states
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">reach</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">subst</span></span>, <span class="o "><span class="k">ref</span> <span class="t Identifier"><span class="i">predicate_t</span></span> <span class="i">pred</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="lc">// to handle the special case of overlapping consume and lookahead predicates,</span>
        <span class="lc">// we find the different intersecting predicate types</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span>    <span class="i">have_consume</span>,
                <span class="i">have_lookahead</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">subst</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">lookahead</span></span></span></span> )
                <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">intpred</span> = <span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">intersect</span></span>(<span class="i">pred</span>)</span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">intpred</span></span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> == <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">have_consume</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span></span>
                <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> == <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">lookahead</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">have_lookahead</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span></span></span></span></span>
            }</span></span></span>
        }</span></span></span>

        <span class="lc">// if there is consume/lookahead overlap,</span>
        <span class="lc">// lookahead predicates are handled first</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">predicate_t</span></span>.<span class="t Identifier"><span class="i">Type</span></span> <span class="i">processed_type</span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">have_lookahead</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">processed_type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">lookahead</span></span></span>;</span></span>
        <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">have_consume</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">processed_type</span></span> = <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span>;</span></span>
        <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
            <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"<span class="es">\n</span>ERROR: reach found no consume/lookahead symbol for {} in <span class="es">\n</span>{}"</span>, <span class="i">pred</span>.<span class="i">toString</span>, <span class="i">subst</span>.<span class="i">toString</span>)</span>;</span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span>
        }</span></span></span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">pred</span></span>.<span class="e Identifier"><span class="i">type</span></span> = <span class="e Identifier"><span class="i">processed_type</span></span></span>;</span>

        <span class="lc">// add destination states to new subsetstate</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">r</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">SubsetState</span></span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">s</span></span></span>; <span class="e Identifier"><span class="i">subst</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">processed_type</span></span></span> )
                    <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">intpred</span> = <span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">intersect</span></span>(<span class="i">pred</span>)</span>;</span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">intpred</span></span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> ) <span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span> <span class="i">se</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">StateElement</span></span></span>;</span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">t</span>.<span class="i">priority</span>, <span class="i">s</span>.<span class="i">maxPriority</span>)</span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">priority</span></span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">tags</span></span> = <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">tags</span></span></span>;</span>
                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">elms</span></span> ~= <span class="e Identifier"><span class="i">se</span></span></span>;</span>
                }</span></span></span>
            }</span></span></span>
        }</span></span></span>

        <span class="lc">// if we prioritized lookaheads, the states that may consume are also added to the new subset state</span>
        <span class="lc">// this behaviour is somewhat similar to an epsilon closure</span>
        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Identifier"><span class="i">have_lookahead</span></span> &amp;&amp; <span class="e Identifier"><span class="i">have_consume</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">s</span></span></span>; <span class="e Identifier"><span class="i">subst</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> )
                        <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
                    <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">intpred</span> = <span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">intersect</span></span>(<span class="i">pred</span>)</span>;</span></span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">intpred</span></span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">elms</span></span> ~= <span class="e Identifier"><span class="i">s</span></span></span>;</span>
                        <span class="s Break"><span class="k">break</span>;</span>
                    }</span></span></span>
                }</span></span></span>
            }</span></span></span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">r</span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Extends the given SubsetState with the states that are reached through lookbehind transitions.

        Params:     from =      SubsetState to create the lookbehind closure for
                    previous =  predicate "from" was reached with
        Returns:    SubsetState containing "from" and all states of it's lookbehind closure
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">lookbehindClosure</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">from</span></span>, <span class="o "><span class="t Identifier"><span class="i">predicate_t</span></span> <span class="i">pred</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">StateElement</span></span>)</span></span> <span class="i">stack</span> = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">StateElement</span></span>)</span></span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span><span class="t Array">[<span class="t Identifier"><span class="i">size_t</span></span>]</span>  <span class="i">closure</span>;</span></span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">from</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">stack</span></span> ~= <span class="e Identifier"><span class="i">e</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">closure</span></span>[<span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">index</span></span>]</span> = <span class="e Identifier"><span class="i">e</span></span></span>;</span>
        }</span></span></span>

        <span class="s While"><span class="k">while</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">stack</span></span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span> <span class="i">se</span> = <span class="e Identifier"><span class="i">stack</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span>;</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">stack</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">lookbehind</span></span></span> )
                    <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">intersect</span></span>(<span class="i">pred</span>)</span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
                    <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">new_maxPri</span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">t</span>.<span class="i">priority</span>, <span class="i">se</span>.<span class="i">maxPriority</span>)</span>;</span></span>

                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span><span class="t Pointer">*</span> <span class="i">tmp</span> = <span class="e In"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span>.<span class="e Identifier"><span class="i">index</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">closure</span></span></span>;</span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">tmp</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="lc">// if higher prio (smaller value) exists, do not use this transition</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span> &lt; <span class="e Identifier"><span class="i">new_maxPri</span></span></span> ) <span class="s Scope"><span class="s Compound">{
<span class="lc">//                         debug(tdfa) Stdout.formatln("maxPrio({}) {} beats {}, continuing", t.target.index, tmp.maxPriority, new_maxPri);</span>
                        <span class="s Continue"><span class="k">continue</span>;</span>
                    }</span></span>
                    <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span> == <span class="e Identifier"><span class="i">new_maxPri</span></span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="lc">// "equal lastPrio -&gt; first-come-first-serve"</span>
                        <span class="lc">// doesn't work for lexer - how to solve it properly?</span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span> &lt;= <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">priority</span></span></span> ) <span class="s Scope"><span class="s Compound">{
<span class="lc">//                             debug(tdfa) Stdout.formatln("lastPrio({}) {} beats {}, continuing", t.target.index, tmp.lastPriority, t.priority);</span>
                            <span class="s Continue"><span class="k">continue</span>;</span>
                        }</span></span></span>
<span class="lc">//                         else</span>
<span class="lc">//                             debug(tdfa) Stdout.formatln("lastPrio({}) {} beats {}", t.target.index, t.priority, tmp.lastPriority);</span>
                    }</span></span></span></span></span>
<span class="lc">//                     else</span>
<span class="lc">//                         debug(tdfa) Stdout.formatln("maxPrio({}) {} beats {}", t.target.index, new_maxPri, tmp.maxPriority);</span>
                }</span></span></span>

                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span> <span class="i">new_se</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">StateElement</span></span></span>;</span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_se</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">t</span>.<span class="i">priority</span>, <span class="i">se</span>.<span class="i">maxPriority</span>)</span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_se</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">priority</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_se</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_se</span></span>.<span class="e Identifier"><span class="i">tags</span></span> = <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">tags</span></span></span>;</span>

                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">closure</span></span>[<span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span>.<span class="e Identifier"><span class="i">index</span></span>]</span> = <span class="e Identifier"><span class="i">new_se</span></span></span>;</span>
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">stack</span></span> ~= <span class="e Identifier"><span class="i">new_se</span></span></span>;</span>
            }</span></span></span>
        }</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">res</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">SubsetState</span></span></span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">elms</span></span> = <span class="e Identifier"><span class="i">closure</span></span>.<span class="e Identifier"><span class="i">values</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Generates the epsilon closure of the given subset state, creating tag map entries
        if tags are passed. Takes priorities into account, effectively realizing
        greediness and reluctancy.

        Params:     from =      SubsetState to create the epsilon closure for
                    previous =  SubsetState "from" was reached from
        Returns:    SubsetState containing "from" and all states of it's epsilon closure
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">epsilonClosure</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">from</span></span>, <span class="o "><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">previous</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">firstFreeIndex</span>=<span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">previous</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">ti</span></span></span>; <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">tags</span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">firstFreeIndex</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">firstFreeIndex</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">ti</span>)</span></span>;</span></span></span>
        }</span></span></span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">firstFreeIndex</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">StateElement</span></span>)</span></span> <span class="i">stack</span> = <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">List</span>!<span class="o ">(<span class="t Identifier"><span class="i">StateElement</span></span>)</span></span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span><span class="t Array">[<span class="t Identifier"><span class="i">size_t</span></span>]</span>  <span class="i">closure</span>;</span></span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">from</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">stack</span></span> ~= <span class="e Identifier"><span class="i">e</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">closure</span></span>[<span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">index</span></span>]</span> = <span class="e Identifier"><span class="i">e</span></span></span>;</span>
        }</span></span></span>

        <span class="s While"><span class="k">while</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">stack</span></span></span>.<span class="e Identifier"><span class="i">empty</span></span>()</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span> <span class="i">se</span> = <span class="e Identifier"><span class="i">stack</span></span>.<span class="e Identifier"><span class="i">tail</span></span>.<span class="e Identifier"><span class="i">value</span></span>;</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">stack</span></span>.<span class="e Identifier"><span class="i">pop</span></span>()</span>;</span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">epsilon</span></span></span> )
                    <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
                <span class="lc">// this is different from Ville Laurikari's algorithm, but it's crucial</span>
                <span class="lc">// to take the max (instead of t.priority) to make reluctant operators work</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">new_maxPri</span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">t</span>.<span class="i">priority</span>, <span class="i">se</span>.<span class="i">maxPriority</span>)</span>;</span></span>

                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span><span class="t Pointer">*</span> <span class="i">tmp</span> = <span class="e In"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span>.<span class="e Identifier"><span class="i">index</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">closure</span></span></span>;</span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">tmp</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="lc">// if higher prio (smaller value) exists, do not use this transition</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span> &lt; <span class="e Identifier"><span class="i">new_maxPri</span></span></span> ) <span class="s Scope"><span class="s Compound">{
<span class="lc">//                         debug(tdfa) Stdout.formatln("maxPrio({}) {} beats {}, continuing", t.target.index, tmp.maxPriority, new_maxPri);</span>
                        <span class="s Continue"><span class="k">continue</span>;</span>
                    }</span></span>
                    <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span> == <span class="e Identifier"><span class="i">new_maxPri</span></span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="lc">// "equal lastPrio -&gt; first-come-first-serve"</span>
                        <span class="lc">// doesn't work for lexer - how to solve it properly?</span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span> &lt;= <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">priority</span></span></span> ) <span class="s Scope"><span class="s Compound">{
<span class="lc">//                             debug(tdfa) Stdout.formatln("lastPrio({}) {} beats {}, continuing", t.target.index, tmp.lastPriority, t.priority);</span>
                            <span class="s Continue"><span class="k">continue</span>;</span>
                        }</span></span></span>
<span class="lc">//                         else</span>
<span class="lc">//                             debug(tdfa) Stdout.formatln("lastPrio({}) {} beats {}", t.target.index, t.priority, tmp.lastPriority);</span>
                    }</span></span></span></span></span>
<span class="lc">//                     else</span>
<span class="lc">//                         debug(tdfa) Stdout.formatln("maxPrio({}) {} beats {}", t.target.index, new_maxPri, tmp.maxPriority);</span>
                }</span></span></span>

                <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">new_se</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">StateElement</span></span></span>;</span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_se</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span> = <span class="e Identifier"><span class="i">new_maxPri</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_se</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">priority</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_se</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span></span>;</span>

                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">tag</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">k</span></span>, <span class="o "><span class="i">v</span></span></span>; <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">tags</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">new_se</span></span>.<span class="e Identifier"><span class="i">tags</span></span>[<span class="e Identifier"><span class="i">k</span></span>]</span> = <span class="e Identifier"><span class="i">v</span></span></span>;</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">new_se</span></span>.<span class="e Identifier"><span class="i">tags</span></span>[<span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">tag</span></span>]</span> = <span class="e Identifier"><span class="i">firstFreeIndex</span></span></span>;</span>
                }</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_se</span></span>.<span class="e Identifier"><span class="i">tags</span></span> = <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">tags</span></span></span>;</span></span></span>

                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">closure</span></span>[<span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span>.<span class="e Identifier"><span class="i">index</span></span>]</span> = <span class="e Identifier"><span class="i">new_se</span></span></span>;</span>
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">stack</span></span> ~= <span class="e Identifier"><span class="i">new_se</span></span></span>;</span>
            }</span></span></span>
        }</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">res</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">SubsetState</span></span></span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">elms</span></span> = <span class="e Identifier"><span class="i">closure</span></span>.<span class="e Identifier"><span class="i">values</span></span></span>;</span>

        <span class="lc">// optimize tag usage</span>
        <span class="lc">// all we need to do is to check whether the largest tag-index from the</span>
        <span class="lc">// previous state is actually used in the new state and move all tags with</span>
        <span class="lc">// firstFreeIndex down by one if not, but only if firstFreeIndex is not 0</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">firstFreeIndex</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">seenLastUsedIndex</span> = <span class="e Bool"><span class="k">false</span></span>;</span></span>
            <span class="s Labeled"><span class="i">sluiLoop</span>: <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">i</span></span></span>; <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">tags</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> == <span class="e Minus"><span class="e Identifier"><span class="i">firstFreeIndex</span></span>-<span class="e Int"><span class="n">1</span></span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">seenLastUsedIndex</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                        <span class="s Break"><span class="k">break</span> <span class="i">sluiLoop</span>;</span>
                    }</span></span></span>
                }</span></span></span>
            }</span></span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Not">!<span class="e Identifier"><span class="i">seenLastUsedIndex</span></span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="k">ref</span> <span class="i">i</span></span></span>; <span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">tags</span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="lc">// mark index by making it negative</span>
                        <span class="lc">// to signal that it can be decremented</span>
                        <span class="lc">// after it has been detected to be a newly used index</span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> == <span class="e Identifier"><span class="i">firstFreeIndex</span></span></span> )
                            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">i</span></span> = <span class="e Sign">-<span class="e Identifier"><span class="i">firstFreeIndex</span></span></span></span>;</span></span></span>
                    }</span></span></span>
                }</span></span></span>
            }</span></span></span>
        }</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Tries to create commands that reorder the tag map of "previous", such that "from" becomes
        tag-wise identical to "to". If successful, these commands are added to "trans". This
        is done for state re-use.

        Params:     from =      SubsetState to check for tag-wise equality to "to"
                    to =        existing SubsetState that we want to re-use
                    previous =  SubsetState we're coming from
                    trans =     Transition we went along
        Returns:    true if "from" is tag-wise identical to "to" and the necessary commands have
                    been added to "trans"
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">reorderTagIndeces</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">from</span></span>, <span class="o "><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">to</span></span>, <span class="o "><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">previous</span></span>, <span class="o "><span class="t Identifier"><span class="i">Transition</span></span> <span class="i">trans</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">from</span></span>.<span class="e Identifier"><span class="i">elms</span></span>.<span class="e Identifier"><span class="i">length</span></span> != <span class="e Identifier"><span class="i">to</span></span>.<span class="e Identifier"><span class="i">elms</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span><span class="t Array">[<span class="t Identifier"><span class="i">Command</span></span>]</span>
            <span class="i">cmds</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span><span class="t Array">[<span class="t Identifier"><span class="i">TagIndex</span></span>]</span>
            <span class="i">reorderedIndeces</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span><span class="t Array">[<span class="t Identifier"><span class="i">TagIndex</span></span>]</span>
            <span class="i">reordered_elements</span>;</span></span>

        <span class="s Labeled"><span class="i">Louter</span>: <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">fe</span></span></span>; <span class="e Identifier"><span class="i">from</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">te</span></span></span>; <span class="e Identifier"><span class="i">to</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">te</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">index</span></span> != <span class="e Identifier"><span class="i">fe</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">index</span></span></span> )
                    <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">fe</span></span>.<span class="e Identifier"><span class="i">tags</span></span>.<span class="e Identifier"><span class="i">length</span></span> != <span class="e Identifier"><span class="i">te</span></span>.<span class="e Identifier"><span class="i">tags</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
                    <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">tag</span></span>, <span class="o "><span class="i">findex</span></span></span>; <span class="e Identifier"><span class="i">fe</span></span>.<span class="e Identifier"><span class="i">tags</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Paren">(<span class="e In"><span class="e Identifier"><span class="i">tag</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">te</span></span>.<span class="e Identifier"><span class="i">tags</span></span></span>)</span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
                        <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span></span>

                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">TagIndex</span></span> <span class="i">ti</span>;</span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ti</span></span>.<span class="e Identifier"><span class="i">tag</span></span> = <span class="e Identifier"><span class="i">tag</span></span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ti</span></span>.<span class="e Identifier"><span class="i">index</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">te</span></span>.<span class="e Identifier"><span class="i">tags</span></span>[<span class="e Identifier"><span class="i">tag</span></span>]</span></span>;</span>

                    <span class="lc">// apply priority for conflicting tag indeces</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Paren">(<span class="e In"><span class="e Identifier"><span class="i">ti</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">reorderedIndeces</span></span></span>)</span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">rse</span> = <span class="e Index"><span class="e Identifier"><span class="i">reordered_elements</span></span>[<span class="e Identifier"><span class="i">ti</span></span>]</span>;</span></span>
                        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">ri</span> = <span class="e Index"><span class="e Identifier"><span class="i">reorderedIndeces</span></span>[<span class="e Identifier"><span class="i">ti</span></span>]</span>;</span></span>
                        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">ri</span></span> != <span class="e Identifier"><span class="i">findex</span></span></span>
                            &amp;&amp; <span class="e Paren">( <span class="e OrOr"><span class="e Rel"><span class="e Identifier"><span class="i">rse</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span> &lt; <span class="e Identifier"><span class="i">fe</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span></span>
                                || <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">rse</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span> == <span class="e Identifier"><span class="i">fe</span></span>.<span class="e Identifier"><span class="i">maxPriority</span></span></span>
                                &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">rse</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span> &lt;= <span class="e Identifier"><span class="i">fe</span></span>.<span class="e Identifier"><span class="i">lastPriority</span></span></span></span></span> )</span></span>
                        )
                            <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Command</span></span> <span class="i">cmd</span>;</span></span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">registerFromTagIndex</span></span>(<span class="i">tag</span>,<span class="i">ri</span>)</span></span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">registerFromTagIndex</span></span>(<span class="i">tag</span>,<span class="i">te</span>.<span class="i">tags</span>[<span class="i">tag</span>])</span></span>;</span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">cmds</span></span>.<span class="t Identifier"><span class="i">remove</span></span>(<span class="i">cmd</span>);</span></span>
                    }</span></span></span>
                    <span class="lc">// if target index differs, create reordering command</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">te</span></span>.<span class="e Identifier"><span class="i">tags</span></span>[<span class="e Identifier"><span class="i">tag</span></span>]</span> != <span class="e Identifier"><span class="i">findex</span></span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Command</span></span> <span class="i">cmd</span>;</span></span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">registerFromTagIndex</span></span>(<span class="i">tag</span>,<span class="i">findex</span>)</span></span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">registerFromTagIndex</span></span>(<span class="i">tag</span>,<span class="i">te</span>.<span class="i">tags</span>[<span class="i">tag</span>])</span></span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">cmds</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>]</span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                    }</span></span></span>

                    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">reorderedIndeces</span></span>[<span class="e Identifier"><span class="i">ti</span></span>]</span> = <span class="e Identifier"><span class="i">findex</span></span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">reordered_elements</span></span>[<span class="e Identifier"><span class="i">ti</span></span>]</span> = <span class="e Identifier"><span class="i">fe</span></span></span>;</span>
                }</span></span></span>
                <span class="s Continue"><span class="k">continue</span> <span class="i">Louter</span>;</span>
            }</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
        }</span></span></span></span>

        <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"<span class="es">\n</span>reorder {} to {}<span class="es">\n</span>"</span>, <span class="i">from</span>.<span class="i">toString</span>, <span class="i">to</span>.<span class="i">dfa_state</span>.<span class="i">index</span>)</span>;</span>
        }</span></span>

        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">commands</span></span> ~= <span class="e Identifier"><span class="i">cmds</span></span>.<span class="e Identifier"><span class="i">keys</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Generate tag map initialization commands for start state.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">generateInitializers</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">start</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span><span class="t Array">[<span class="t Integral"><span class="k">uint</span></span>]</span> <span class="i">cmds</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">nds</span></span></span>; <span class="e Identifier"><span class="i">start</span></span>.<span class="e Identifier"><span class="i">elms</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">k</span></span>, <span class="o "><span class="i">v</span></span></span>; <span class="e Identifier"><span class="i">nds</span></span>.<span class="e Identifier"><span class="i">tags</span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">cmds</span></span>[<span class="e Identifier"><span class="i">k</span></span>]</span> = <span class="e Identifier"><span class="i">v</span></span></span>;</span></span></span>
        }</span></span></span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">k</span></span>, <span class="o "><span class="i">v</span></span></span>; <span class="e Identifier"><span class="i">cmds</span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Command</span></span> <span class="i">cmd</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">registerFromTagIndex</span></span>(<span class="i">k</span>,<span class="i">v</span>)</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">initializer</span></span> ~= <span class="e Identifier"><span class="i">cmd</span></span></span>;</span>
        }</span></span></span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Generates finisher commands for accepting states.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">generateFinishers</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">SubsetState</span></span> <span class="i">r</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="lc">// if at least one of the TNFA states accepts,</span>
        <span class="lc">// set the finishers from active tags in increasing priority</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">StateElement</span></span><span class="t Array">[]</span>  <span class="i">sorted_elms</span> = <span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">elms</span></span>.<span class="e Identifier"><span class="i">dup</span></span>.<span class="e Identifier"><span class="i">sort</span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">reluctant</span> = <span class="e Bool"><span class="k">false</span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">se</span></span></span>; <span class="e Identifier"><span class="i">sorted_elms</span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Debug"><span class="k">debug</span> (<span class="i">Finishers</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"Finisher: {}"</span>, <span class="i">se</span>)</span>;</span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">accept</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">dfa_state</span></span>.<span class="e Identifier"><span class="i">accept</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>

                <span class="lc">// Knowing that we're looking at an epsilon closure with an accepting</span>
                <span class="lc">// state, we look at the involved transitions - if the path from the</span>
                <span class="lc">// nfa state in the set with the highest incoming priority (last in</span>
                <span class="lc">// sorted_elms list) to the accepting nfa state is via the highest</span>
                <span class="lc">// priority transitions, and they are all epsilon transitions, this</span>
                <span class="lc">// suggests we're looking at a regex ending with a reluctant pattern.</span>
                <span class="lc">// The NFA-&gt;DFA transformation will most likely extend the automata</span>
                <span class="lc">// further, but we want the matching to stop here.</span>
                <span class="lc">// NOTE: The grounds for choosing the last element in sorted_elms</span>
                <span class="lc">// are somewhat weak (empirical testing), but sofar no new</span>
                <span class="lc">// regressions have been discovered. larsivi 20090827</span>
                <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFATransition</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span> <span class="i">highestPriTrans</span>;</span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Not">!<span class="e Paren">(<span class="e AndAnd"><span class="e AndAnd"><span class="e Index"><span class="e Identifier"><span class="i">sorted_elms</span></span>[<span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span> &amp;&amp; <span class="e Index"><span class="e Identifier"><span class="i">sorted_elms</span></span>[<span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span>.<span class="e Identifier"><span class="i">nfa_state</span></span></span> &amp;&amp;
                            <span class="e Index"><span class="e Identifier"><span class="i">sorted_elms</span></span>[<span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span>.<span class="e Identifier"><span class="i">nfa_state</span></span></span>)</span></span>)
                    <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Exception</span></span> (<span class="e String"><span class="sl">"Something is NULL that is expected to
                            be non-null"</span></span>, <span class="e SpecialToken"><span class="st">__FILE__</span></span>, <span class="e SpecialToken"><span class="st">__LINE__</span></span>)</span>;</span></span></span>

                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">trans</span></span></span>; <span class="e Index"><span class="e Identifier"><span class="i">sorted_elms</span></span>[<span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span>.<span class="e Identifier"><span class="i">nfa_state</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> ) <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">trans</span></span>.<span class="e Identifier"><span class="i">canFinish</span></span>()</span>) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">dfa_state</span></span>.<span class="e Identifier"><span class="i">reluctant</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                        <span class="s Break"><span class="k">break</span>;</span>
                    }</span></span></span>
                }</span></span></span>

                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span><span class="t Array">[<span class="t Integral"><span class="k">uint</span></span>]</span>  <span class="i">finished_tags</span>;</span></span>
                <span class="s Scope"><span class="s Compound">{
                    <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span>, <span class="o "><span class="i">i</span></span></span>; <span class="e Identifier"><span class="i">se</span></span>.<span class="e Identifier"><span class="i">tags</span></span> )
                        <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> &amp;&amp; <span class="e Not">!<span class="e Paren">(<span class="e In"><span class="e Identifier"><span class="i">t</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">finished_tags</span></span></span>)</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">finished_tags</span></span>[<span class="e Identifier"><span class="i">t</span></span>]</span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Command</span></span> <span class="i">cmd</span>;</span></span>
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">registerFromTagIndex</span></span>(<span class="i">t</span>, <span class="n">0</span>)</span></span>;</span>
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">registerFromTagIndex</span></span>(<span class="i">t</span>, <span class="i">i</span>)</span></span>;</span>
                            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">dfa_state</span></span>.<span class="e Identifier"><span class="i">finishers</span></span> ~= <span class="e Identifier"><span class="i">cmd</span></span></span>;</span>
                        }</span></span></span></span></span>
                }</span></span>
            }</span></span></span>
        }</span></span></span>
    }</span></span></span>

    <span class="bc">/* ********************************************************************************************
        Assumes that the command-lists are sorted and transitions are optimized
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">minimizeDFA</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Class"><span class="k">class</span> <span class="i">DiffTable</span>
        <span class="d Compound">{
            <span class="d Constructor"><span class="k">this</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">num</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">diff_</span></span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">bool</span></span><span class="t Array">[<span class="e Div"><span class="e Mul"><span class="e Identifier"><span class="i">num</span></span>*<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">num</span></span>+<span class="e Int"><span class="n">1</span></span></span>)</span></span>/<span class="e Int"><span class="n">2</span></span></span>]</span></span></span>;</span>
            }</span></span></span>

            <span class="d Destructor">~<span class="k">this</span>() <span class="s FuncBody"><span class="s Compound">{ <span class="s Expression"><span class="e Delete"><span class="k">delete</span> <span class="e Identifier"><span class="i">diff_</span></span></span>;</span> }</span></span></span>

            <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">opCall</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">a</span></span>, <span class="o "><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">b</span></span>)</span>
            <span class="s FuncBody"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">a</span></span> &lt; <span class="e Identifier"><span class="i">b</span></span></span> )
                    <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Index"><span class="e Identifier"><span class="i">diff_</span></span>[<span class="e Plus"><span class="e Div"><span class="e Mul"><span class="e Identifier"><span class="i">b</span></span>*<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">b</span></span>+<span class="e Int"><span class="n">1</span></span></span>)</span></span>/<span class="e Int"><span class="n">2</span></span></span>+<span class="e Identifier"><span class="i">a</span></span></span>]</span>;</span></span></span>
                <span class="s Return"><span class="k">return</span> <span class="e Index"><span class="e Identifier"><span class="i">diff_</span></span>[<span class="e Plus"><span class="e Div"><span class="e Mul"><span class="e Identifier"><span class="i">a</span></span>*<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>+<span class="e Int"><span class="n">1</span></span></span>)</span></span>/<span class="e Int"><span class="n">2</span></span></span>+<span class="e Identifier"><span class="i">b</span></span></span>]</span>;</span>
            }</span></span></span>

            <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">set</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">a</span></span>, <span class="o "><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">b</span></span>)</span>
            <span class="s FuncBody"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">a</span></span> &lt; <span class="e Identifier"><span class="i">b</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">diff_</span></span>[<span class="e Plus"><span class="e Div"><span class="e Mul"><span class="e Identifier"><span class="i">b</span></span>*<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">b</span></span>+<span class="e Int"><span class="n">1</span></span></span>)</span></span>/<span class="e Int"><span class="n">2</span></span></span>+<span class="e Identifier"><span class="i">a</span></span></span>]</span> = <span class="e Bool"><span class="k">true</span></span></span>;</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">diff_</span></span>[<span class="e Plus"><span class="e Div"><span class="e Mul"><span class="e Identifier"><span class="i">a</span></span>*<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>+<span class="e Int"><span class="n">1</span></span></span>)</span></span>/<span class="e Int"><span class="n">2</span></span></span>+<span class="e Identifier"><span class="i">b</span></span></span>]</span> = <span class="e Bool"><span class="k">true</span></span></span>;</span></span></span>
            }</span></span></span>

            <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span><span class="t Array">[]</span>  <span class="i">diff_</span>;</span>
        }</span></span></span>

        <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"Minimizing TDFA"</span>)</span>;</span></span>

        <span class="s Declaration"><span class="d StorageClass"><span class="k">scope</span></span> <span class="d Variables"><span class="i">diff</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">DiffTable</span></span>(<span class="e Identifier"><span class="i">states</span></span>.<span class="e Identifier"><span class="i">length</span></span>)</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">new_diff</span> = <span class="e Bool"><span class="k">true</span></span>;</span></span>

        <span class="s While"><span class="k">while</span> ( <span class="e Identifier"><span class="i">new_diff</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_diff</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">i</span></span>, <span class="o "><span class="i">a</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">states</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Labeled"><span class="i">Linner</span>: <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">j</span></span>, <span class="o "><span class="i">b</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">states</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">i</span></span>+<span class="e Int"><span class="n">1</span></span></span> .. <span class="e Dollar">$</span>]</span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">diff</span></span>(<span class="i">i</span>, <span class="i">j</span>+<span class="i">i</span>+<span class="n">1</span>)</span> )
                        <span class="s Scope"><span class="s Continue"><span class="k">continue</span>;</span></span></span>

                    <span class="lc">// assume optimized transitions</span>
                    <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Equal"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">accept</span></span> != <span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">accept</span></span></span> || <span class="e Equal"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">transitions</span></span>.<span class="e Identifier"><span class="i">length</span></span> != <span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">transitions</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">diff</span></span>.<span class="e Identifier"><span class="i">set</span></span>(<span class="i">i</span>, <span class="i">j</span>+<span class="i">i</span>+<span class="n">1</span>)</span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_diff</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                        <span class="s Continue"><span class="k">continue</span>;</span>
                    }</span></span></span>

                    <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">accept</span></span> ) <span class="lc">// b accepts too</span>
                    <span class="s Scope"><span class="s Compound">{
                        <span class="lc">// assume sorted finishers</span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">finishers</span></span>.<span class="e Identifier"><span class="i">length</span></span> != <span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">finishers</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">diff</span></span>.<span class="e Identifier"><span class="i">set</span></span>(<span class="i">i</span>, <span class="i">j</span>+<span class="i">i</span>+<span class="n">1</span>)</span>;</span>
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_diff</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                            <span class="s Continue"><span class="k">continue</span>;</span>
                        }</span></span></span>
                        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">k</span></span>, <span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">finishers</span></span> )
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span> != <span class="e Index"><span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">finishers</span></span>[<span class="e Identifier"><span class="i">k</span></span>]</span></span> ) <span class="s Scope"><span class="s Compound">{
                                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">diff</span></span>.<span class="e Identifier"><span class="i">set</span></span>(<span class="i">i</span>, <span class="i">j</span>+<span class="i">i</span>+<span class="n">1</span>)</span>;</span>
                                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_diff</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                                <span class="s Continue"><span class="k">continue</span> <span class="i">Linner</span>;</span>
                            }</span></span></span>
                        }</span></span></span>
                    }</span></span></span>

                    <span class="s Labeled"><span class="i">Ltrans</span>: <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">ta</span></span></span>; <span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">tb</span></span></span>; <span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">ta</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">intersects</span></span>(<span class="i">tb</span>.<span class="i">predicate</span>)</span> )
                            <span class="s Scope"><span class="s Compound">{
                                <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">diff</span></span>(<span class="i">ta</span>.<span class="i">target</span>.<span class="i">index</span>, <span class="i">tb</span>.<span class="i">target</span>.<span class="i">index</span>)</span> ) <span class="s Scope"><span class="s Compound">{
                                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">diff</span></span>.<span class="e Identifier"><span class="i">set</span></span>(<span class="i">i</span>, <span class="i">j</span>+<span class="i">i</span>+<span class="n">1</span>)</span>;</span>
                                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_diff</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                                    <span class="s Continue"><span class="k">continue</span> <span class="i">Linner</span>;</span>
                                }</span></span></span>
                                <span class="lc">// assume sorted commands</span>
                                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">ta</span></span>.<span class="e Identifier"><span class="i">commands</span></span>.<span class="e Identifier"><span class="i">length</span></span> != <span class="e Identifier"><span class="i">tb</span></span>.<span class="e Identifier"><span class="i">commands</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">diff</span></span>.<span class="e Identifier"><span class="i">set</span></span>(<span class="i">i</span>, <span class="i">j</span>+<span class="i">i</span>+<span class="n">1</span>)</span>;</span>
                                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_diff</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                                    <span class="s Continue"><span class="k">continue</span> <span class="i">Linner</span>;</span>
                                }</span></span></span>
                                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">k</span></span>, <span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">ta</span></span>.<span class="e Identifier"><span class="i">commands</span></span> )
                                <span class="s Scope"><span class="s Compound">{
                                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span> != <span class="e Index"><span class="e Identifier"><span class="i">tb</span></span>.<span class="e Identifier"><span class="i">commands</span></span>[<span class="e Identifier"><span class="i">k</span></span>]</span></span> ) <span class="s Scope"><span class="s Compound">{
                                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">diff</span></span>.<span class="e Identifier"><span class="i">set</span></span>(<span class="i">i</span>, <span class="i">j</span>+<span class="i">i</span>+<span class="n">1</span>)</span>;</span>
                                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_diff</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                                        <span class="s Continue"><span class="k">continue</span> <span class="i">Linner</span>;</span>
                                    }</span></span></span>
                                }</span></span></span>
                                <span class="s Continue"><span class="k">continue</span> <span class="i">Ltrans</span>;</span>
                            }</span></span></span>
                        }</span></span></span>

                        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">diff</span></span>.<span class="e Identifier"><span class="i">set</span></span>(<span class="i">i</span>, <span class="i">j</span>+<span class="i">i</span>+<span class="n">1</span>)</span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">new_diff</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                        <span class="s Continue"><span class="k">continue</span> <span class="i">Linner</span>;</span>
                    }</span></span></span></span>

                }</span></span></span></span>
            }</span></span></span>
        }</span></span></span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">i</span></span>, <span class="o "><span class="i">a</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">states</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Dollar">$</span>-<span class="e Int"><span class="n">1</span></span></span>]</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">j</span></span>, <span class="o "><span class="i">b</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">states</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">i</span></span>+<span class="e Int"><span class="n">1</span></span></span> .. <span class="e Dollar">$</span>]</span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">diff</span></span></span>(<span class="i">i</span>, <span class="i">j</span>+<span class="i">i</span>+<span class="n">1</span>)</span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s Debug"><span class="k">debug</span>(<span class="i">tdfa</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"State {} == {}"</span>, <span class="i">i</span>, <span class="i">j</span>+<span class="i">i</span>+<span class="n">1</span>)</span>;</span></span>
                    <span class="lc">// remap b to a</span>
                    <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">k</span></span>, <span class="o "><span class="i">c</span></span></span>; <span class="e Identifier"><span class="i">states</span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">c</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span>.<span class="e Identifier"><span class="i">index</span></span> == <span class="e Plus"><span class="e Plus"><span class="e Identifier"><span class="i">j</span></span>+<span class="e Identifier"><span class="i">i</span></span></span>+<span class="e Int"><span class="n">1</span></span></span></span> )
                                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">a</span></span></span>;</span></span></span>
                        }</span></span></span>
                    }</span></span></span>
                }</span></span></span>
            }</span></span></span>
        }</span></span></span>

    }</span></span></span></span>
}</span></span></span></span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">text</span>.<span class="i">Util</span>;</span>

<span class="bc">/**************************************************************************************************
    Regular expression compiler and interpreter.
**************************************************************************************************/</span>
<span class="d Template"><span class="d Compound"><span class="d Class"><span class="k">class</span> <span class="i">RegExpT</span><span class="o ">(<span class="o "><span class="i">char_t</span></span>)</span>
<span class="d Compound">{
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">TDFA</span>!<span class="o ">(<span class="t Integral"><span class="k">dchar</span></span>)</span></span>      <span class="i">tdfa_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">TNFA</span>!<span class="o ">(<span class="t Integral"><span class="k">dchar</span></span>)</span></span>      <span class="i">tnfa_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CharClass</span>!<span class="o ">(<span class="t Integral"><span class="k">dchar</span></span>)</span></span> <span class="i">charclass_t</span>;</span></span>
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">Predicate</span>!<span class="o ">(<span class="t Integral"><span class="k">dchar</span></span>)</span></span> <span class="i">predicate_t</span>;</span></span>

    <span class="bc">/**********************************************************************************************
        Construct a RegExpT object.
        Params:
            pattern = Regular expression.
        Throws: RegExpException if there are any compilation errors.
        Example:
            Declare two variables and assign to them a Regex object:
            ---
            auto r = new Regex("pattern");
            auto s = new Regex(r"p[1-5]\s*");
            ---
    **********************************************************************************************/</span>
    <span class="d Constructor"><span class="k">this</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">pattern</span></span>, <span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">attributes</span>=<span class="e Null"><span class="k">null</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e This"><span class="k">this</span></span>(<span class="i">pattern</span>, <span class="k">false</span>, <span class="k">true</span>)</span>;</span>
    }</span></span></span>

    <span class="bc">/** ditto */</span>
    <span class="d Constructor"><span class="k">this</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">pattern</span></span>, <span class="o "><span class="t Integral"><span class="k">bool</span></span> <span class="i">swapMBS</span></span>, <span class="o "><span class="t Integral"><span class="k">bool</span></span> <span class="i">unanchored</span></span>, <span class="o "><span class="t Integral"><span class="k">bool</span></span> <span class="i">printNFA</span>=<span class="e Bool"><span class="k">false</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">pattern_</span></span> = <span class="e Identifier"><span class="i">pattern</span></span></span>;</span>

        <span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Compound">{}</span>
        <span class="k">else</span> <span class="s Compound">{
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> ( <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">char_t</span></span> == <span class="t Integral"><span class="k">dchar</span></span>)</span> ) <span class="s Compound">{
                <span class="s Declaration"><span class="d StorageClass"><span class="k">scope</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">tnfa_t</span></span> <span class="i">tnfa_</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">tnfa_t</span></span>(<span class="e Identifier"><span class="i">pattern_</span></span>)</span>;</span></span>
            }</span>
            <span class="k">else</span> <span class="s Compound">{
                <span class="s Declaration"><span class="d StorageClass"><span class="k">scope</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">tnfa_t</span></span> <span class="i">tnfa_</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">tnfa_t</span></span>(<span class="e Call"><span class="e Identifier"><span class="i">tango</span></span>.<span class="e Identifier"><span class="i">text</span></span>.<span class="e Identifier"><span class="i">convert</span></span>.<span class="e Identifier"><span class="i">Utf</span></span>.<span class="e Identifier"><span class="i">toString32</span></span>(<span class="i">pattern_</span>)</span>)</span>;</span></span>
            }</span></span>
        }</span></span>
       
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tnfa_</span></span>.<span class="e Identifier"><span class="i">swapMatchingBracketSyntax</span></span> = <span class="e Identifier"><span class="i">swapMBS</span></span></span>;</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">tnfa_</span></span>.<span class="t Identifier"><span class="i">parse</span></span>(<span class="i">unanchored</span>);</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">printNFA</span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"<span class="es">\n</span>TNFA:"</span>)</span>;</span></span>
            <span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Identifier"><span class="i">tnfa_</span></span>.<span class="e Identifier"><span class="i">print</span></span>;</span></span>
        }</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tdfa_</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">tdfa_t</span></span>(<span class="e Identifier"><span class="i">tnfa_</span></span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">registers_</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">num_regs</span></span>()</span></span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Generate instance of Regex.
        Params:
            pattern = Regular expression.
        Throws: RegExpException if there are any compilation errors.
        Example:
            Declare two variables and assign to them a Regex object:
            ---
            auto r = Regex("pattern");
            auto s = Regex(r"p[1-5]\s*");
            ---
    **********************************************************************************************/</span>
    <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t TemplateInstance"><span class="i">RegExpT</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span> <span class="i">opCall</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">pattern</span></span>, <span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">attributes</span> = <span class="e Null"><span class="k">null</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">RegExpT</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span>(<span class="e Identifier"><span class="i">pattern</span></span>, <span class="e Identifier"><span class="i">attributes</span></span>)</span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Set up for start of foreach loop.
        Returns:    Instance of RegExpT set up to search input.
        Example:
            ---
            import tango.io.Stdout;
            import tango.text.Regex;

            void main()
            {
                foreach(m; Regex("ab").search("qwerabcabcababqwer"))
                    Stdout.formatln("{}[{}]{}", m.pre, m.match(0), m.post);
            }
            // Prints:
            // qwer[ab]cabcababqwer
            // qwerabc[ab]cababqwer
            // qwerabcabc[ab]abqwer
            // qwerabcabcab[ab]qwer
            ---
    **********************************************************************************************/</span>
    <span class="d Protection"><span class="k">public</span></span> <span class="d Function"><span class="t TemplateInstance"><span class="i">RegExpT</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span> <span class="i">search</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">input</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">input_</span></span> = <span class="e Identifier"><span class="i">input</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">next_start_</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">last_start_</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
    }</span></span></span>

    <span class="bc">/** ditto */</span>
    <span class="d Protection"><span class="k">public</span></span> <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opApply</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="t TemplateInstance"><span class="i">RegExpT</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span></span>)</span></span> <span class="i">dg</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">result</span>;</span></span>
        <span class="s While"><span class="k">while</span> ( <span class="e AndAnd"><span class="e Not">!<span class="e Identifier"><span class="i">result</span></span></span> &amp;&amp; <span class="e Call"><span class="e Identifier"><span class="i">test</span></span>()</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">result</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span>(<span class="k">this</span>)</span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Search input for match.
        Returns: false for no match, true for match
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">test</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">input</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e This"><span class="k">this</span></span>.<span class="e Identifier"><span class="i">input_</span></span> = <span class="e Identifier"><span class="i">input</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">next_start_</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">last_start_</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">test</span></span>()</span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Pick up where last test(input) or test() left off, and search again.
        Returns: false for no match, true for match
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">test</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="lc">// initialize registers</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">registers_</span></span>.<span class="e Identifier"><span class="i">length</span></span> == <span class="e Call"><span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">num_regs</span></span>()</span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Int"><span class="n">0</span></span>..<span class="e Dollar">$</span>]</span> = <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span></span>;</span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">initializer</span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> == <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span>)</span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span>]</span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
        }</span></span></span>

        <span class="lc">// DFA execution</span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">inp</span> = <span class="e Slice"><span class="e Identifier"><span class="i">input_</span></span>[<span class="e Identifier"><span class="i">next_start_</span></span> .. <span class="e Dollar">$</span>]</span>;</span></span>
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">s</span> = <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">start</span></span>;</span></span>

        <span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"{}{}: {}"</span>, <span class="i">s</span>.<span class="i">accept</span>?<span class="sl">"*"</span>:<span class="sl">" "</span>, <span class="i">s</span>.<span class="i">index</span>, <span class="i">inp</span>)</span>;</span></span>
        <span class="s Labeled"><span class="i">LmainLoop</span>: <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">p</span>, <span class="i">next_p</span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">p</span></span> &lt; <span class="e Identifier"><span class="i">inp</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>; )
        <span class="s Scope"><span class="s Compound">{
        <span class="s Labeled"><span class="i">Lread_char</span>:
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">c</span> = <span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">dchar</span></span>)<span class="e Identifier"><span class="i">inp</span></span></span>[<span class="e Identifier"><span class="i">p</span></span>]</span>;</span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e And"><span class="e Identifier"><span class="i">c</span></span> &amp; <span class="e Int"><span class="n">0x80</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">decode</span></span>(<span class="i">inp</span>, <span class="i">next_p</span>)</span></span>;</span></span>
            <span class="k">else</span>
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">next_p</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">p</span></span>+<span class="e Int"><span class="n">1</span></span></span></span>;</span></span></span>

        <span class="s Labeled"><span class="i">Lprocess_char</span>:
            <span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"{} (0x{:x})"</span>, <span class="i">c</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">c</span>)</span>;</span></span></span>

            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">tdfa_t</span></span>.<span class="t Identifier"><span class="i">Transition</span></span> <span class="i">t</span> = <span class="e VoidInit"><span class="k">void</span></span>;</span></span>
            <span class="s Switch"><span class="k">switch</span> ( <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">mode</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">Mode</span></span>.<span class="e Identifier"><span class="i">LOOKUP</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">LOOKUP_LENGTH</span></span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"lookup"</span>)</span>;</span></span>
                        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">i</span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">lookup</span></span>[<span class="e Identifier"><span class="i">c</span></span>]</span>;</span></span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> == <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">INVALID_STATE</span></span></span> )
                            <span class="s Scope"><span class="s Break"><span class="k">break</span> <span class="i">LmainLoop</span>;</span></span></span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">transitions</span></span>[ <span class="e Identifier"><span class="i">i</span></span> ]</span></span>;</span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> )
                            <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lno_consume</span>;</span></span></span>
                        <span class="s Goto"><span class="k">goto</span> <span class="i">Lconsume</span>;</span>
                    }</span></span></span>
                    <span class="s Break"><span class="k">break</span> <span class="i">LmainLoop</span>;</span></span></span></span>

                <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">Mode</span></span>.<span class="e Identifier"><span class="i">MIXED</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">LOOKUP_LENGTH</span></span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"mixed"</span>)</span>;</span></span>
                        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">i</span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">lookup</span></span>[<span class="e Identifier"><span class="i">c</span></span>]</span>;</span></span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> == <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">INVALID_STATE</span></span></span> )
                            <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">transitions</span></span>[ <span class="e Identifier"><span class="i">i</span></span> ]</span></span>;</span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> != <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">Type</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> )
                            <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lno_consume</span>;</span></span></span>
                        <span class="s Goto"><span class="k">goto</span> <span class="i">Lconsume</span>;</span>
                    }</span></span></span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>

                <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">Mode</span></span>.<span class="e Identifier"><span class="i">GENERIC</span></span><span class="s Scope"><span class="s Compound">:</span></span></span>
                <span class="s Default"><span class="k">default</span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Break"><span class="k">break</span>;</span></span></span></span>
            }</span></span></span>

            <span class="s Labeled"><span class="i">Ltrans_loop</span>: <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">tdfa_t</span></span>.<span class="t Identifier"><span class="i">Transition</span></span><span class="t Pointer">*</span> <span class="i">tp</span> = <span class="e Index"><span class="e Address">&amp;<span class="e Identifier"><span class="i">s</span></span></span>.<span class="e Identifier"><span class="i">generic_transitions</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>, <span class="i">tp_end</span> = <span class="e Plus"><span class="e Identifier"><span class="i">tp</span></span>+<span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">generic_transitions</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="e Rel"><span class="e Identifier"><span class="i">tp</span></span> &lt; <span class="e Identifier"><span class="i">tp_end</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">tp</span></span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">t</span></span> = <span class="e Deref">*<span class="e Identifier"><span class="i">tp</span></span></span></span>;</span>
                <span class="s Switch"><span class="k">switch</span> ( <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">mode</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="lc">// single char</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">single_char</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"single char 0x{:x} == 0x{:x}"</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">c</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">t</span>.<span class="i">predicate</span>.<span class="i">data_chr</span>)</span>;</span></span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">c</span></span> != <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">data_chr</span></span></span> )
                            <span class="s Scope"><span class="s Continue"><span class="k">continue</span> <span class="i">Ltrans_loop</span>;</span></span></span>
                        <span class="s Goto"><span class="k">goto</span> <span class="i">Lconsume</span>;</span></span></span></span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">single_char_l</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"single char 0x{:x} == 0x{:x}"</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">c</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">t</span>.<span class="i">predicate</span>.<span class="i">data_chr</span>)</span>;</span></span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">c</span></span> != <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">data_chr</span></span></span> )
                            <span class="s Scope"><span class="s Continue"><span class="k">continue</span> <span class="i">Ltrans_loop</span>;</span></span></span>
                        <span class="s Goto"><span class="k">goto</span> <span class="i">Lno_consume</span>;</span></span></span></span>

                    <span class="lc">// bitmap</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">bitmap</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"bitmap {}<span class="es">\n</span>{}"</span>, <span class="i">c</span>, <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">toString</span>)</span>;</span></span>
                        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">MAX_BITMAP_LENGTH</span></span></span> &amp;&amp; <span class="e Paren">( <span class="e And"><span class="e Index"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">data_bmp</span></span>[<span class="e Div"><span class="e Identifier"><span class="i">c</span></span>/<span class="e Int"><span class="n">8</span></span></span>]</span> &amp; <span class="e Paren">(<span class="e LShift"><span class="e Int"><span class="n">1</span></span> &lt;&lt; <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">c</span></span>&amp;<span class="e Int"><span class="n">7</span></span></span>)</span></span>)</span></span> )</span></span> )
                            <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lconsume</span>;</span></span></span>
                        <span class="s Continue"><span class="k">continue</span> <span class="i">Ltrans_loop</span>;</span></span></span></span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">bitmap_l</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"bitmap {}<span class="es">\n</span>{}"</span>, <span class="i">c</span>, <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">toString</span>)</span>;</span></span>
                        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">MAX_BITMAP_LENGTH</span></span></span> &amp;&amp; <span class="e Paren">( <span class="e And"><span class="e Index"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">data_bmp</span></span>[<span class="e Div"><span class="e Identifier"><span class="i">c</span></span>/<span class="e Int"><span class="n">8</span></span></span>]</span> &amp; <span class="e Paren">(<span class="e LShift"><span class="e Int"><span class="n">1</span></span> &lt;&lt; <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">c</span></span>&amp;<span class="e Int"><span class="n">7</span></span></span>)</span></span>)</span></span> )</span></span> )
                            <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lno_consume</span>;</span></span></span>
                        <span class="s Continue"><span class="k">continue</span> <span class="i">Ltrans_loop</span>;</span></span></span></span>

                    <span class="lc">// string search</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">string_search</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"string search {} in {}"</span>, <span class="i">c</span>, <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">data_str</span>)</span>;</span></span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span>(<span class="i">t</span>.<span class="i">predicate</span>.<span class="i">data_str</span>.<span class="i">ptr</span>, <span class="i">c</span>, <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">data_str</span>.<span class="i">length</span>)</span> &gt;= <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">data_str</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
                            <span class="s Scope"><span class="s Continue"><span class="k">continue</span> <span class="i">Ltrans_loop</span>;</span></span></span>
                        <span class="s Goto"><span class="k">goto</span> <span class="i">Lconsume</span>;</span></span></span></span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">string_search_l</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"string search {} in {}"</span>, <span class="i">c</span>, <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">data_str</span>)</span>;</span></span>
                        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Call"><span class="e Identifier"><span class="i">indexOf</span></span>(<span class="i">t</span>.<span class="i">predicate</span>.<span class="i">data_str</span>.<span class="i">ptr</span>, <span class="i">c</span>, <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">data_str</span>.<span class="i">length</span>)</span> &gt;= <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">data_str</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
                            <span class="s Scope"><span class="s Continue"><span class="k">continue</span> <span class="i">Ltrans_loop</span>;</span></span></span>
                        <span class="s Goto"><span class="k">goto</span> <span class="i">Lno_consume</span>;</span></span></span></span>

                    <span class="lc">// generic</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">generic</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"generic {}<span class="es">\n</span>{}"</span>, <span class="i">c</span>, <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">toString</span>)</span>;</span></span>
                        <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">cmp</span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">data_str</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>,
                            <span class="i">cmpend</span> = <span class="e Plus"><span class="e Identifier"><span class="i">cmp</span></span> + <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">data_str</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                            <span class="e Rel"><span class="e Identifier"><span class="i">cmp</span></span> &lt; <span class="e Identifier"><span class="i">cmpend</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">cmp</span></span></span> )
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt; <span class="e Deref">*<span class="e Identifier"><span class="i">cmp</span></span></span></span> ) <span class="s Scope"><span class="s Compound">{
                                <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">cmp</span></span></span>;</span>
                                <span class="s Continue"><span class="k">continue</span>;</span>
                            }</span></span></span>
                            <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">cmp</span></span></span>;</span>
                            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Deref">*<span class="e Identifier"><span class="i">cmp</span></span></span></span> )
                                <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lconsume</span>;</span></span></span>
                        }</span></span></span>
                        <span class="s Continue"><span class="k">continue</span> <span class="i">Ltrans_loop</span>;</span></span></span></span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">predicate_t</span></span>.<span class="e Identifier"><span class="i">MatchMode</span></span>.<span class="e Identifier"><span class="i">generic_l</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"generic {}<span class="es">\n</span>{}"</span>, <span class="i">c</span>, <span class="i">t</span>.<span class="i">predicate</span>.<span class="i">toString</span>)</span>;</span></span>
                        <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">cmp</span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">data_str</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>,
                            <span class="i">cmpend</span> = <span class="e Plus"><span class="e Identifier"><span class="i">cmp</span></span> + <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">data_str</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                            <span class="e Rel"><span class="e Identifier"><span class="i">cmp</span></span> &lt; <span class="e Identifier"><span class="i">cmpend</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">cmp</span></span></span> )
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt; <span class="e Deref">*<span class="e Identifier"><span class="i">cmp</span></span></span></span> ) <span class="s Scope"><span class="s Compound">{
                                <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">cmp</span></span></span>;</span>
                                <span class="s Continue"><span class="k">continue</span>;</span>
                            }</span></span></span>
                            <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">cmp</span></span></span>;</span>
                            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Deref">*<span class="e Identifier"><span class="i">cmp</span></span></span></span> )
                                <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lno_consume</span>;</span></span></span>
                        }</span></span></span>
                        <span class="s Continue"><span class="k">continue</span> <span class="i">Ltrans_loop</span>;</span></span></span></span>

                    <span class="s Default"><span class="k">default</span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>)</span>;</span></span></span></span>
                }</span></span></span>

            <span class="s Labeled"><span class="i">Lconsume</span>:
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span> = <span class="e Identifier"><span class="i">next_p</span></span></span>;</span></span>
            <span class="s Labeled"><span class="i">Lno_consume</span>:

                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span></span>;</span></span>
                <span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"{}{}: {}"</span>, <span class="i">s</span>.<span class="i">accept</span>?<span class="sl">"*"</span>:<span class="sl">" "</span>, <span class="i">s</span>.<span class="i">index</span>, <span class="i">inp</span>[<span class="i">p</span>..$])</span>;</span></span>
                <span class="s Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>.<span class="e Identifier"><span class="i">formatln</span></span>(<span class="sl">"{} commands"</span>, <span class="i">t</span>.<span class="i">commands</span>.<span class="i">length</span>)</span>;</span></span>

                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">commands</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> == <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">p</span></span></span></span>;</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span>]</span> = <span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span>]</span></span>;</span></span></span>
                }</span></span></span>

                <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">accept</span></span> &amp;&amp; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">reluctant</span></span></span>)
                    <span class="lc">// Don't continue matching, the current find should be correct</span>
                    <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Laccept</span>;</span></span></span>

                <span class="lc">// if all input was consumed and we do not already accept, try to</span>
                <span class="lc">// add an explicit string/line end</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">p</span></span> &gt;= <span class="e Identifier"><span class="i">inp</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">accept</span></span> || <span class="e Equal"><span class="e Identifier"><span class="i">c</span></span> == <span class="e Int"><span class="n">0</span></span></span></span> )
                        <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">c</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
                    <span class="s Goto"><span class="k">goto</span> <span class="i">Lprocess_char</span>;</span>
                }</span></span></span>
                <span class="s Goto"><span class="k">goto</span> <span class="i">Lread_char</span>;</span>
            }</span></span></span></span>
            <span class="lc">// no applicable transition</span>
            <span class="s Break"><span class="k">break</span>;</span>
        }</span></span></span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">accept</span></span> )
        <span class="s Scope"><span class="s Compound">{
        <span class="s Labeled"><span class="i">Laccept</span>:
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">finishers</span></span> ) <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> != <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span>)</span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span>]</span> = <span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span>]</span></span>;</span>
            }</span></span></span></span>
            <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">registers_</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Int"><span class="n">1</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> &gt;= <span class="e Int"><span class="n">0</span></span></span></span> ) <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">last_start_</span></span> = <span class="e Identifier"><span class="i">next_start_</span></span></span>;</span>
                <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">next_start_</span></span> += <span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Int"><span class="n">1</span></span>]</span></span>;</span>
            }</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span>
        }</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Return submatch with the given index.
        Params:
            index = 0 returns whole match, index &gt; 0 returns submatch of bracket #index
        Returns:
            Slice of input for the requested submatch, or null if no such submatch exists.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">match</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">uint</span></span> <span class="i">index</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">index</span></span> &gt; <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">num_tags</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span></span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">start</span>   = <span class="e Plus"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">last_start_</span></span></span>+<span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Mul"><span class="e Identifier"><span class="i">index</span></span>*<span class="e Int"><span class="n">2</span></span></span>]</span></span>,
            <span class="i">end</span>     = <span class="e Plus"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">last_start_</span></span></span>+<span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">index</span></span>*<span class="e Int"><span class="n">2</span></span></span>+<span class="e Int"><span class="n">1</span></span></span>]</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">start</span></span> &gt;= <span class="e Int"><span class="n">0</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">start</span></span> &lt; <span class="e Identifier"><span class="i">end</span></span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">end</span></span> &lt;= <span class="e Identifier"><span class="i">input_</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">input_</span></span>[<span class="e Identifier"><span class="i">start</span></span> .. <span class="e Identifier"><span class="i">end</span></span>]</span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span>
    }</span></span></span>

    <span class="bc">/** ditto */</span>
    <span class="d Function"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">opIndex</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">uint</span></span> <span class="i">index</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">match</span></span>(<span class="i">index</span>)</span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Return the slice of the input that precedes the matched substring.
        If no match was found, null is returned.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">pre</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">start</span> = <span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">start</span></span> &lt; <span class="e Int"><span class="n">0</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Null"><span class="k">null</span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">input_</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Plus"><span class="e Identifier"><span class="i">last_start_</span></span>+<span class="e Identifier"><span class="i">start</span></span></span>]</span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Return the slice of the input that follows the matched substring.
        If no match was found, the whole slice of the input that was processed in the last test.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">post</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Index"><span class="e Identifier"><span class="i">registers_</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> &gt;= <span class="e Int"><span class="n">0</span></span></span> )
            <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">input_</span></span>[<span class="e Identifier"><span class="i">next_start_</span></span> .. <span class="e Dollar">$</span>]</span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Slice"><span class="e Identifier"><span class="i">input_</span></span>[<span class="e Identifier"><span class="i">last_start_</span></span> .. <span class="e Dollar">$</span>]</span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Splits the input at the matches of this regular expression into an array of slices.
        Example:
            ---
            import tango.io.Stdout;
            import tango.text.Regex;

            void main()
            {
                auto strs = Regex("ab").split("abcabcababqwer");
                foreach( s; strs )
                    Stdout.formatln("{}", s);
            }
            // Prints:
            // c
            // c
            // qwer
            ---
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">split</span><span class="o ">(<span class="o "><span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">input</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">res</span> = <span class="e New"><span class="k">new</span> <span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span><span class="t Array">[<span class="e Identifier"><span class="i">PREALLOC</span></span></span>]</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">index</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">tmp</span> = <span class="e Identifier"><span class="i">input</span></span>;</span></span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">r</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">search</span></span>(<span class="i">input</span>)</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span> = <span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span>)<span class="e Identifier"><span class="i">pre</span></span></span>()</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">res</span></span>[<span class="e PostIncr"><span class="e Identifier"><span class="i">index</span></span>++</span>]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">tmp</span></span>[<span class="e Identifier"><span class="i">last_start_</span></span> .. <span class="e Dollar">$</span>]</span></span>;</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">index</span></span> &gt;= <span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Mul"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">length</span></span>*<span class="e Int"><span class="n">2</span></span></span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span> = <span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Inout"><span class="k">inout</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span>)<span class="e Identifier"><span class="i">post</span></span></span>()</span></span>;</span>
        }</span></span></span>

        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">res</span></span>[<span class="e PostIncr"><span class="e Identifier"><span class="i">index</span></span>++</span>]</span> = <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Identifier"><span class="i">index</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Returns a copy of the input with all matches replaced by replacement.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span> <span class="i">replaceAll</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">input</span></span>, <span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">replacement</span></span>, <span class="o "><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span> <span class="i">output_buffer</span>=<span class="e Null"><span class="k">null</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">tmp</span> = <span class="e Identifier"><span class="i">input</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">output_buffer</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt;= <span class="e Int"><span class="n">0</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">output_buffer</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[<span class="e Plus"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">length</span></span>+<span class="e Identifier"><span class="i">replacement</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">output_buffer</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">r</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">search</span></span>(<span class="i">input</span>)</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">pre</span></span>()</span></span>;</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Identifier"><span class="i">last_start_</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Slice"><span class="e Identifier"><span class="i">tmp</span></span>[<span class="e Identifier"><span class="i">last_start_</span></span> .. <span class="e Dollar">$</span>]</span></span>;</span></span></span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Identifier"><span class="i">replacement</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">post</span></span>()</span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">output_buffer</span></span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Returns a copy of the input with the last match replaced by replacement.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span> <span class="i">replaceLast</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">input</span></span>, <span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">replacement</span></span>, <span class="o "><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span> <span class="i">output_buffer</span>=<span class="e Null"><span class="k">null</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">tmp_pre</span>, <span class="i">tmp_post</span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">output_buffer</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt;= <span class="e Int"><span class="n">0</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">output_buffer</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[<span class="e Plus"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">length</span></span>+<span class="e Identifier"><span class="i">replacement</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">output_buffer</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">r</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">search</span></span>(<span class="i">input</span>)</span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp_pre</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">pre</span></span>()</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp_post</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">post</span></span>()</span></span>;</span>
        }</span></span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Identity"><span class="e Identifier"><span class="i">tmp_pre</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> || <span class="e Identity"><span class="e Identifier"><span class="i">tmp_post</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span></span> ) <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Identifier"><span class="i">tmp_pre</span></span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Identifier"><span class="i">replacement</span></span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Identifier"><span class="i">tmp_post</span></span></span>;</span>
        }</span></span>
        <span class="k">else</span>
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Identifier"><span class="i">input</span></span></span>;</span></span></span>

        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">output_buffer</span></span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Returns a copy of the input with the first match replaced by replacement.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span> <span class="i">replaceFirst</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">input</span></span>, <span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">replacement</span></span>, <span class="o "><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span> <span class="i">output_buffer</span>=<span class="e Null"><span class="k">null</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">tmp</span> = <span class="e Identifier"><span class="i">input</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">output_buffer</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt;= <span class="e Int"><span class="n">0</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">output_buffer</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[<span class="e Plus"><span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">length</span></span>+<span class="e Identifier"><span class="i">replacement</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span></span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">output_buffer</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>

        <span class="s If"><span class="k">if</span> ( <span class="e Call"><span class="e Identifier"><span class="i">test</span></span>(<span class="i">input</span>)</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">pre</span></span>()</span></span>;</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Identifier"><span class="i">last_start_</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Slice"><span class="e Identifier"><span class="i">tmp</span></span>[<span class="e Identifier"><span class="i">last_start_</span></span> .. <span class="e Dollar">$</span>]</span></span>;</span></span></span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Identifier"><span class="i">replacement</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">post</span></span>()</span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">output_buffer</span></span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Calls dg for each match and replaces it with dg's return value.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span> <span class="i">replaceAll</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">input</span></span>, <span class="o "><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span> <span class="t Delegate"><span class="k">delegate</span><span class="o ">(<span class="o "><span class="t TemplateInstance"><span class="i">RegExpT</span>!<span class="o ">(<span class="t Identifier"><span class="i">char_t</span></span>)</span></span></span>)</span></span> <span class="i">dg</span></span>, <span class="o "><span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[]</span> <span class="i">output_buffer</span>=<span class="e Null"><span class="k">null</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span>    <span class="i">tmp</span> = <span class="e Identifier"><span class="i">input</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">output_buffer</span></span>.<span class="e Identifier"><span class="i">length</span></span> &lt;= <span class="e Int"><span class="n">0</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">output_buffer</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">char_t</span></span><span class="t Array">[<span class="e Identifier"><span class="i">input</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span></span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">output_buffer</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>

        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">r</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">search</span></span>(<span class="i">input</span>)</span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">pre</span></span>()</span></span>;</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">tmp</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Identifier"><span class="i">last_start_</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Slice"><span class="e Identifier"><span class="i">tmp</span></span>[<span class="e Identifier"><span class="i">last_start_</span></span> .. <span class="e Dollar">$</span>]</span></span>;</span></span></span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">dg</span></span>(<span class="k">this</span>)</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tmp</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">post</span></span>()</span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">output_buffer</span></span> ~= <span class="e Identifier"><span class="i">tmp</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">output_buffer</span></span>;</span>
    }</span></span></span>

    <span class="bc">/**********************************************************************************************
        Compiles the regular expression to D code.

        NOTE : Remember to import this module (tango.text.Regex) in the module where you put the
        generated D code.

    **********************************************************************************************/</span>
    <span class="lc">// TODO: input-end special case</span>
    <span class="d Function"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">compileToD</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">func_name</span> = <span class="e String"><span class="sl">"match"</span></span></span>, <span class="o "><span class="t Integral"><span class="k">bool</span></span> <span class="i">lexer</span>=<span class="e Bool"><span class="k">false</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">code</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">str_type</span>;</span></span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> ( <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">char_t</span></span> == <span class="t Integral"><span class="k">char</span></span>)</span> )
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str_type</span></span> = <span class="e String"><span class="sl">"const(char)[]"</span></span></span>;</span></span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> ( <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">char_t</span></span> == <span class="t Integral"><span class="k">wchar</span></span>)</span> )
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str_type</span></span> = <span class="e String"><span class="sl">"const(wchar)[]"</span></span></span>;</span></span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> ( <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">char_t</span></span> == <span class="t Integral"><span class="k">dchar</span></span>)</span> )
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">str_type</span></span> = <span class="e String"><span class="sl">"const(dchar)[]"</span></span></span>;</span></span>

        <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">lexer</span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">code</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"// {}<span class="es">\n</span>bool {}({} input, out uint token, out {} match"</span>, <span class="i">pattern_</span>, <span class="i">func_name</span>, <span class="i">str_type</span>, <span class="i">str_type</span>)</span></span>;</span></span>
        <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">code</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"// {}<span class="es">\n</span>bool match({} input"</span>, <span class="i">pattern_</span>, <span class="i">str_type</span>)</span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">", ref {}[] groups"</span>, <span class="i">str_type</span>)</span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">")<span class="es">\n</span>{{<span class="es">\n</span>    uint s = {};"</span>, <span class="i">tdfa_</span>.<span class="i">start</span>.<span class="i">index</span>)</span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">num_vars</span> = <span class="e Call"><span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">num_regs</span></span>()</span>;</span></span>
        <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Identifier"><span class="i">num_vars</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">lexer</span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>    static int "</span></span></span>;</span></span>
            <span class="k">else</span>
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>    int "</span></span></span>;</span></span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">first</span> = <span class="e Bool"><span class="k">true</span></span>;</span></span>
            <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span> = <span class="e Int"><span class="n">0</span></span>, <span class="i">used</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">num_vars</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">hasInit</span> = <span class="e Bool"><span class="k">false</span></span>;</span></span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">initializer</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span> == <span class="e Identifier"><span class="i">i</span></span></span> ) <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">hasInit</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                        <span class="s Break"><span class="k">break</span>;</span>
                    }</span></span></span>
                }</span></span></span>

                <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">first</span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">", "</span></span></span>;</span></span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">used</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Mod"><span class="e Identifier"><span class="i">used</span></span> % <span class="e Int"><span class="n">10</span></span></span> == <span class="e Int"><span class="n">0</span></span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>        "</span></span></span>;</span></span></span>
                <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">used</span></span></span>;</span>
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"r{}"</span>, <span class="i">i</span>)</span></span>;</span>

                <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">hasInit</span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"=0"</span></span></span>;</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"=-1"</span></span></span>;</span></span></span>
            }</span></span></span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">";"</span></span></span>;</span>
        }</span></span></span>

        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span><span class="es">\n</span>    for ( size_t p, next_p; p &lt; input.length; )<span class="es">\n</span>    {"</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>        dchar c = cast(dchar)input[p];<span class="es">\n</span>        if ( c &amp; 0x80 )<span class="es">\n</span>            decode(input, next_p);"</span></span></span>;</span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>        else<span class="es">\n</span>            next_p = p+1;<span class="es">\n</span>        switch ( s )<span class="es">\n</span>        {"</span></span></span>;</span>

        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span><span class="t Array">[]</span> <span class="i">finish_states</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">s</span></span></span>; <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">states</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"<span class="es">\n</span>            case {}:"</span>, <span class="i">s</span>.<span class="i">index</span>)</span></span>;</span>

            <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">accept</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">finish_states</span></span> ~= <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">index</span></span></span>;</span>

                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">tdfa_t</span></span>.<span class="t Identifier"><span class="i">State</span></span> <span class="i">target</span>;</span></span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">target</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span></span>;</span></span>
                    <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> ( <span class="e Identity"><span class="e Identifier"><span class="i">target</span></span> !<span class="k">is</span> <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">target</span></span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">target</span></span> = <span class="e Null"><span class="k">null</span></span></span>;</span>
                        <span class="s Break"><span class="k">break</span>;</span>
                    }</span></span></span></span></span>
                }</span></span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">target</span></span> !<span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> &amp;&amp; <span class="e Identity"><span class="e Identifier"><span class="i">target</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">s</span></span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">transitions</span></span> = <span class="e Null"><span class="k">null</span></span></span>;</span></span></span>
            }</span></span></span>

            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">first_if</span>=<span class="e Bool"><span class="k">true</span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">charclass_t</span></span> <span class="i">cc</span>, <span class="i">ccTest</span>;</span></span>

            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">t</span></span></span>; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">transitions</span></span>.<span class="e Identifier"><span class="i">sort</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">ccTest</span></span>.<span class="e Identifier"><span class="i">add</span></span>(<span class="i">t</span>.<span class="i">predicate</span>.<span class="i">getInput</span>())</span>;</span>
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">ccTest</span></span>.<span class="e Identifier"><span class="i">optimize</span></span>()</span>;</span>
                <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">getInput</span></span>()</span> &lt; <span class="e Identifier"><span class="i">ccTest</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cc</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">getInput</span></span>()</span></span>;</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cc</span></span> = <span class="e Identifier"><span class="i">ccTest</span></span></span>;</span></span></span>

                <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">first_if</span></span> ) <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>                if ( "</span></span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first_if</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
                }</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>                else if ( "</span></span></span>;</span></span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">first_cond</span>=<span class="e Bool"><span class="k">true</span></span>;</span></span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cr</span></span></span>; <span class="e Identifier"><span class="i">cc</span></span>.<span class="e Identifier"><span class="i">parts</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">first_cond</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first_cond</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">" || "</span></span></span>;</span></span></span>
                    <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">l</span></span>()</span> == <span class="e Call"><span class="e Identifier"><span class="i">cr</span></span>.<span class="e Identifier"><span class="i">r</span></span>()</span></span> )
                        <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"c == 0x{:x}"</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">cr</span>.<span class="i">l</span>())</span></span>;</span></span>
                    <span class="k">else</span>
                        <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"c &gt;= 0x{:x} &amp;&amp; c &lt;= 0x{:x}"</span>, <span class="k">cast</span>(<span class="k">int</span>)<span class="i">cr</span>.<span class="i">l</span>(), <span class="k">cast</span>(<span class="k">int</span>)<span class="i">cr</span>.<span class="i">r</span>())</span></span>;</span></span></span>
                }</span></span></span>
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">" ) {{<span class="es">\n</span>                    s = {};"</span>, <span class="i">t</span>.<span class="i">target</span>.<span class="i">index</span>)</span></span>;</span>

                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span> == <span class="e Typeof"><span class="t Typeof"><span class="k">typeof</span>(<span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">predicate</span></span>.<span class="e Identifier"><span class="i">type</span></span>)</span></span>.<span class="e Identifier"><span class="i">consume</span></span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>                    p = next_p;"</span></span></span>;</span></span></span>
                <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd</span></span></span>; <span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">commands</span></span> )
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">compileCommand</span></span>(<span class="i">cmd</span>, <span class="sl">"                    "</span>)</span></span>;</span></span></span>
<span class="bc">/*
                // if inp ends here and we do not already accept, try to add an explicit string/line end
                if ( p &gt;= inp.length &amp;&amp; !s.accept &amp;&amp; c != 0 ) {
                    c = 0;
                    goto Lprocess_char;
                }
*/</span>
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>                }"</span></span></span>;</span>
            }</span></span></span>

            <span class="s If"><span class="k">if</span> ( <span class="e Not">!<span class="e Identifier"><span class="i">first_if</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(
                    <span class="sl">"<span class="es">\n</span>                else<span class="es">\n</span>                    {};<span class="es">\n</span>                break;"</span>,
                    <span class="i">s</span>.<span class="i">accept</span>?<span class="i">Format</span>.<span class="i">convert</span>(<span class="sl">"goto finish{}"</span>, <span class="i">s</span>.<span class="i">index</span>):<span class="sl">"return false"</span>
                )</span></span>;</span></span>
            <span class="k">else</span>
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"<span class="es">\n</span>                {};"</span>, <span class="i">s</span>.<span class="i">accept</span>?<span class="i">Format</span>.<span class="i">convert</span>(<span class="sl">"goto finish{}"</span>, <span class="i">s</span>.<span class="i">index</span>):<span class="sl">"return false"</span>)</span></span>;</span></span></span>
        }</span></span></span>

        <span class="lc">// create finisher groups</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span><span class="t Array">[]</span><span class="t Array">[<span class="t Identifier"><span class="i">size_t</span></span>]</span> <span class="i">finisherGroup</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">fs</span></span></span>; <span class="e Identifier"><span class="i">finish_states</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="lc">// check if finisher group with same commands exists</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">haveFinisher</span> = <span class="e Bool"><span class="k">false</span></span>;</span></span>
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">fg</span></span></span>; <span class="e Identifier"><span class="i">finisherGroup</span></span>.<span class="e Identifier"><span class="i">keys</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">equalCommands</span> = <span class="e Bool"><span class="k">false</span></span>;</span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">states</span></span>[<span class="e Identifier"><span class="i">fs</span></span>]</span>.<span class="e Identifier"><span class="i">finishers</span></span>.<span class="e Identifier"><span class="i">length</span></span> == <span class="e Index"><span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">states</span></span>[<span class="e Identifier"><span class="i">fg</span></span>]</span>.<span class="e Identifier"><span class="i">finishers</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">equalCommands</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                    <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">i</span></span>, <span class="o "><span class="i">cmd</span></span></span>; <span class="e Index"><span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">states</span></span>[<span class="e Identifier"><span class="i">fs</span></span>]</span>.<span class="e Identifier"><span class="i">finishers</span></span> )
                    <span class="s Scope"><span class="s Compound">{
                        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span> != <span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">states</span></span>[<span class="e Identifier"><span class="i">fg</span></span>]</span>.<span class="e Identifier"><span class="i">finishers</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span></span> ) <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">equalCommands</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
                            <span class="s Break"><span class="k">break</span>;</span>
                        }</span></span></span>
                    }</span></span></span>
                }</span></span></span>
                <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">equalCommands</span></span> ) <span class="s Scope"><span class="s Compound">{
                    <span class="lc">// use existing group for this state</span>
                    <span class="s Expression"><span class="e CatAssign"><span class="e Index"><span class="e Identifier"><span class="i">finisherGroup</span></span>[<span class="e Identifier"><span class="i">fg</span></span>]</span> ~= <span class="e Identifier"><span class="i">fs</span></span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">haveFinisher</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span>
                }</span></span></span>
            }</span></span></span>
            <span class="lc">// create new group</span>
            <span class="s If"><span class="k">if</span> ( <span class="e Not">!<span class="e Identifier"><span class="i">haveFinisher</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Index"><span class="e Identifier"><span class="i">finisherGroup</span></span>[<span class="e Identifier"><span class="i">fs</span></span>]</span> ~= <span class="e Identifier"><span class="i">fs</span></span></span>;</span></span></span>
        }</span></span></span>


        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>            default:<span class="es">\n</span>                assert(0);<span class="es">\n</span>        }<span class="es">\n</span>    }<span class="es">\n</span><span class="es">\n</span>    switch ( s )<span class="es">\n</span>    {"</span></span></span>;</span>
        <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">group</span></span>, <span class="o "><span class="i">states</span></span></span>; <span class="e Identifier"><span class="i">finisherGroup</span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">s</span></span></span>; <span class="e Identifier"><span class="i">states</span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"<span class="es">\n</span>        case {}: finish{}:"</span>, <span class="i">s</span>, <span class="i">s</span>)</span></span>;</span></span></span>

            <span class="s Foreach"><span class="k">foreach</span> ( <span class="o "><span class="o "><span class="i">cmd</span></span></span>; <span class="e Index"><span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">states</span></span>[<span class="e Identifier"><span class="i">group</span></span>]</span>.<span class="e Identifier"><span class="i">finishers</span></span> )
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> ( <span class="e Identifier"><span class="i">lexer</span></span> )
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> ( <span class="e Rel"><span class="e Index"><span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">states</span></span>[<span class="e Identifier"><span class="i">group</span></span>]</span>.<span class="e Identifier"><span class="i">finishers</span></span>.<span class="e Identifier"><span class="i">length</span></span> &gt; <span class="e Int"><span class="n">1</span></span></span> )
                        <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e String"><span class="sl">"Lexer error: more than one finisher in flm lexer!"</span></span>)</span>;</span></span></span>
                    <span class="s If"><span class="k">if</span> ( <span class="e OrOr"><span class="e Equal"><span class="e Mod"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span> % <span class="e Int"><span class="n">2</span></span></span> == <span class="e Int"><span class="n">0</span></span></span> || <span class="e Rel"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">dst</span></span> &gt;= <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">num_tags</span></span></span></span> )
                        <span class="s Scope"><span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RegExpException</span></span>(<span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"Lexer error: unexpected dst register {} in flm lexer!"</span>, <span class="i">cmd</span>.<span class="i">dst</span>)</span>.<span class="e Identifier"><span class="i">idup</span></span>)</span>;</span></span></span>
                    <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"<span class="es">\n</span>            match = input[0 .. r{}];<span class="es">\n</span>            token = {};"</span>, <span class="i">cmd</span>.<span class="i">src</span>, <span class="i">cmd</span>.<span class="i">dst</span>/<span class="n">2</span>)</span></span>;</span>
                }</span></span>
                <span class="k">else</span>
                    <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">compileCommand</span></span>(<span class="i">cmd</span>, <span class="sl">"            "</span>)</span></span>;</span></span></span>
            }</span></span></span>

            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>            break;"</span></span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>        default:<span class="es">\n</span>            return false;<span class="es">\n</span>    }<span class="es">\n</span>"</span></span></span>;</span>

        <span class="s If"><span class="k">if</span> ( <span class="e Not">!<span class="e Identifier"><span class="i">lexer</span></span></span> )
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"<span class="es">\n</span>    groups.length = {};"</span>, <span class="i">tdfa_</span>.<span class="i">num_tags</span>/<span class="n">2</span>)</span></span>;</span>
            <span class="s For"><span class="k">for</span> ( <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Div"><span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">num_tags</span></span>/<span class="e Int"><span class="n">2</span></span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span> )
                <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"<span class="es">\n</span>    if ( r{} &gt; -1 &amp;&amp; r{} &gt; -1 )<span class="es">\n</span>        groups[{}] = input[r{} .. r{}];"</span>, <span class="n">2</span>*<span class="i">i</span>, <span class="n">2</span>*<span class="i">i</span>+<span class="n">1</span>, <span class="i">i</span>, <span class="n">2</span>*<span class="i">i</span>, <span class="n">2</span>*<span class="i">i</span>+<span class="n">1</span>)</span></span>;</span></span></span>
        }</span></span></span>

        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"<span class="es">\n</span>    return true;<span class="es">\n</span>}"</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">code</span></span>;</span>
    }</span></span></span>

    <span class="bc">/*********************************************************************************************
        Get the pattern with which this regex was constructed.
    **********************************************************************************************/</span>
    <span class="d Protection"><span class="k">public</span></span> <span class="d Function"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span> <span class="i">pattern</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">pattern_</span></span>;</span>
    }</span></span></span>

    <span class="bc">/*********************************************************************************************
        Get the tag count of this regex, representing the number of sub-matches.

        This value is the max valid value for match/opIndex.
    **********************************************************************************************/</span>
    <span class="d Function"><span class="t Integral"><span class="k">uint</span></span> <span class="i">tagCount</span><span class="o ">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">num_tags</span></span>;</span>
    }</span></span></span>

    <span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span>       <span class="i">registers_</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span>      <span class="i">next_start_</span>,
                <span class="i">last_start_</span>;</span>

    <span class="d Debug"><span class="k">debug</span>(<span class="i">TangoRegex</span>) <span class="d Variables"><span class="t Identifier"><span class="i">tnfa_t</span></span> <span class="i">tnfa_</span>;</span></span>
    <span class="d Variables"><span class="t Identifier"><span class="i">tdfa_t</span></span>      <span class="i">tdfa_</span>;</span>
<span class="d Protection"><span class="k">private</span></span>:
    <span class="d Compound"><span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t Integral"><span class="k">int</span></span>   <span class="i">PREALLOC</span> = <span class="e Int"><span class="n">16</span></span>;</span>
    <span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">char_t</span></span>)</span><span class="t Array">[]</span>    <span class="i">input_</span>,
                       <span class="i">pattern_</span>;</span>

    <span class="d Function"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">compileCommand</span><span class="o ">(<span class="o "><span class="t Identifier"><span class="i">tdfa_t</span></span>.<span class="t Identifier"><span class="i">Command</span></span> <span class="i">cmd</span></span>, <span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">indent</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span>  <span class="i">code</span>,
                <span class="i">dst</span>;</span></span>
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"<span class="es">\n</span>{}r{} = "</span>, <span class="i">indent</span>, <span class="i">cmd</span>.<span class="i">dst</span>)</span></span>;</span>
        <span class="s If"><span class="k">if</span> ( <span class="e Equal"><span class="e Identifier"><span class="i">cmd</span></span>.<span class="e Identifier"><span class="i">src</span></span> == <span class="e Identifier"><span class="i">tdfa_</span></span>.<span class="e Identifier"><span class="i">CURRENT_POSITION_REGISTER</span></span></span> )
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e String"><span class="sl">"p;"</span></span></span>;</span></span>
        <span class="k">else</span>
            <span class="s Scope"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">code</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">Format</span></span>.<span class="e Identifier"><span class="i">convert</span></span>(<span class="sl">"r{};"</span>, <span class="i">cmd</span>.<span class="i">src</span>)</span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">code</span></span>;</span>
    }</span></span></span></span>
}</span></span></span></span>

<span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">RegExpT</span>!<span class="o ">(<span class="t Integral"><span class="k">char</span></span>)</span></span> <span class="i">Regex</span>;</span></span>

<span class="d Debug"><span class="k">debug</span>(<span class="i">utf</span>) <span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">stdc</span>.<span class="i">stdio</span>;</span></span>
<span class="lc">// the following block is stolen from phobos.</span>
<span class="lc">// the copyright notice applies for this block only.</span>
<span class="bc">/*
 *  Copyright (C) 2003-2004 by Digital Mars, www.digitalmars.com
 *  Written by Walter Bright
 *
 *  This software is provided 'as-is', without any express or implied
 *  warranty. In no event will the authors be held liable for any damages
 *  arising from the use of this software.
 *
 *  Permission is granted to anyone to use this software for any purpose,
 *  including commercial applications, and to alter it and redistribute it
 *  freely, subject to the following restrictions:
 *
 *  o  The origin of this software must not be misrepresented; you must not
 *     claim that you wrote the original software. If you use this software
 *     in a product, an acknowledgment in the product documentation would be
 *     appreciated but is not required.
 *  o  Altered source versions must be plainly marked as such, and must not
 *     be misrepresented as being the original software.
 *  o  This notice may not be removed or altered from any source
 *     distribution.
 */</span>

<span class="d Class"><span class="k">class</span> <span class="i">UtfException</span> : <span class="t BaseClass"><span class="t Identifier"><span class="i">Exception</span></span></span>
<span class="d Compound">{
    <span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">idx</span>;</span> <span class="lc">/// index in string of where error occurred</span>

    <span class="d Constructor"><span class="k">this</span><span class="o ">(<span class="o "><span class="t Immutable"><span class="k">immutable</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">s</span></span>, <span class="o "><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">i</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">idx</span></span> = <span class="e Identifier"><span class="i">i</span></span></span>;</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="k">super</span></span>(<span class="i">s</span>);</span></span>
    }</span></span></span>
}</span></span>

<span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">isValidDchar</span><span class="o ">(<span class="o "><span class="t Integral"><span class="k">dchar</span></span> <span class="i">c</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="bc">/* Note: FFFE and FFFF are specifically permitted by the
     * Unicode standard for application internal use, but are not
     * allowed for interchange.
     * (thanks to Arcane Jill)
     */</span>

    <span class="s Return"><span class="k">return</span> <span class="e OrOr"><span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt; <span class="e Int"><span class="n">0xD800</span></span></span> ||
        <span class="e Paren">(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &gt; <span class="e Int"><span class="n">0xDFFF</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Int"><span class="n">0x10FFFF</span></span></span></span> <span class="bc">/*&amp;&amp; c != 0xFFFE &amp;&amp; c != 0xFFFF*/</span>)</span></span>;</span>
}</span></span></span>

<span class="bc">/* *************
 * Decodes and returns character starting at s[idx]. idx is advanced past the
 * decoded character. If the character is not well formed, a UtfException is
 * thrown and idx remains unchanged.
 */</span>

<span class="d Function"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">decode</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">s</span></span>, <span class="o "><span class="k">ref</span> <span class="t Identifier"><span class="i">size_t</span></span> <span class="i">idx</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">len</span> = <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">length</span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">V</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">i</span> = <span class="e Identifier"><span class="i">idx</span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">char</span></span> <span class="i">u</span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>;</span></span>

        <span class="s If"><span class="k">if</span> (<span class="e And"><span class="e Identifier"><span class="i">u</span></span> &amp; <span class="e Int"><span class="n">0x80</span></span></span>)
        <span class="s Scope"><span class="s Compound">{   <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">n</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">char</span></span> <span class="i">u2</span>;</span></span>

            <span class="bc">/* The following encodings are valid, except for the 5 and 6 byte
             * combinations:
             *  0xxxxxxx
             *  110xxxxx 10xxxxxx
             *  1110xxxx 10xxxxxx 10xxxxxx
             *  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
             *  111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
             *  1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
             */</span>
            <span class="s For"><span class="k">for</span> (<span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">n</span></span> = <span class="e Int"><span class="n">1</span></span></span>;</span> ; <span class="e PostIncr"><span class="e Identifier"><span class="i">n</span></span>++</span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">n</span></span> &gt; <span class="e Int"><span class="n">4</span></span></span>)
                    <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span></span></span>          <span class="lc">// only do the first 4 of 6 encodings</span>
                <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Paren">(<span class="e And"><span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">u</span></span> &lt;&lt; <span class="e Identifier"><span class="i">n</span></span></span>)</span> &amp; <span class="e Int"><span class="n">0x80</span></span></span>)</span> == <span class="e Int"><span class="n">0</span></span></span>)
                <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">n</span></span> == <span class="e Int"><span class="n">1</span></span></span>)
                        <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span></span></span>
                    <span class="s Break"><span class="k">break</span>;</span>
                }</span></span></span>
            }</span></span></span>

            <span class="lc">// Pick off (7 - n) significant bits of B from first byte of octet</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">V</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">dchar</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">u</span></span> &amp; <span class="e Paren">(<span class="e Minus"><span class="e Paren">(<span class="e LShift"><span class="e Int"><span class="n">1</span></span> &lt;&lt; <span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">7</span></span> - <span class="e Identifier"><span class="i">n</span></span></span>)</span></span>)</span> - <span class="e Int"><span class="n">1</span></span></span>)</span></span>)</span></span></span>;</span>

            <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Plus"><span class="e Identifier"><span class="i">i</span></span> + <span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">n</span></span> - <span class="e Int"><span class="n">1</span></span></span>)</span></span> &gt;= <span class="e Identifier"><span class="i">len</span></span></span>)
                <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span></span></span>                      <span class="lc">// off end of string</span>

            <span class="bc">/* The following combinations are overlong, and illegal:
             *  1100000x (10xxxxxx)
             *  11100000 100xxxxx (10xxxxxx)
             *  11110000 1000xxxx (10xxxxxx 10xxxxxx)
             *  11111000 10000xxx (10xxxxxx 10xxxxxx 10xxxxxx)
             *  11111100 100000xx (10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx)
             */</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">u2</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">i</span></span> + <span class="e Int"><span class="n">1</span></span></span>]</span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e Equal"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">u</span></span> &amp; <span class="e Int"><span class="n">0xFE</span></span></span>)</span> == <span class="e Int"><span class="n">0xC0</span></span></span> ||
                <span class="e Paren">(<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">u</span></span> == <span class="e Int"><span class="n">0xE0</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">u2</span></span> &amp; <span class="e Int"><span class="n">0xE0</span></span></span>)</span> == <span class="e Int"><span class="n">0x80</span></span></span></span>)</span></span> ||
                <span class="e Paren">(<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">u</span></span> == <span class="e Int"><span class="n">0xF0</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">u2</span></span> &amp; <span class="e Int"><span class="n">0xF0</span></span></span>)</span> == <span class="e Int"><span class="n">0x80</span></span></span></span>)</span></span> ||
                <span class="e Paren">(<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">u</span></span> == <span class="e Int"><span class="n">0xF8</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">u2</span></span> &amp; <span class="e Int"><span class="n">0xF8</span></span></span>)</span> == <span class="e Int"><span class="n">0x80</span></span></span></span>)</span></span> ||
                <span class="e Paren">(<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">u</span></span> == <span class="e Int"><span class="n">0xFC</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">u2</span></span> &amp; <span class="e Int"><span class="n">0xFC</span></span></span>)</span> == <span class="e Int"><span class="n">0x80</span></span></span></span>)</span></span>)
                <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span></span></span>                      <span class="lc">// overlong combination</span>

            <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">j</span> = <span class="e Int"><span class="n">1</span></span>;</span></span> <span class="e Equal"><span class="e Identifier"><span class="i">j</span></span> != <span class="e Identifier"><span class="i">n</span></span></span>; <span class="e PostIncr"><span class="e Identifier"><span class="i">j</span></span>++</span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">u</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">i</span></span> + <span class="e Identifier"><span class="i">j</span></span></span>]</span></span>;</span>
                <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">u</span></span> &amp; <span class="e Int"><span class="n">0xC0</span></span></span>)</span> != <span class="e Int"><span class="n">0x80</span></span></span>)
                    <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span></span></span>                  <span class="lc">// trailing bytes are 10xxxxxx</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">V</span></span> = <span class="e Or"><span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">V</span></span> &lt;&lt; <span class="e Int"><span class="n">6</span></span></span>)</span> | <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">u</span></span> &amp; <span class="e Int"><span class="n">0x3F</span></span></span>)</span></span></span>;</span>
            }</span></span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">isValidDchar</span></span></span>(<span class="i">V</span>)</span>)
                <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span></span></span>
            <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">i</span></span> += <span class="e Identifier"><span class="i">n</span></span></span>;</span>
        }</span></span>
        <span class="k">else</span>
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">V</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">dchar</span></span>) <span class="e Identifier"><span class="i">u</span></span></span></span>;</span>
            <span class="s Expression"><span class="e PostIncr"><span class="e Identifier"><span class="i">i</span></span>++</span>;</span>
        }</span></span></span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">idx</span></span> = <span class="e Identifier"><span class="i">i</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">V</span></span>;</span>

      <span class="s Labeled"><span class="i">Lerr</span>:
        <span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Exception</span></span>(<span class="e String"><span class="sl">"invalid UTF-8 sequence"</span></span>)</span>;</span></span>
    }</span></span></span>

<span class="bc">/*  ditto */</span>

<span class="d Function"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">decode</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">wchar</span></span>)</span><span class="t Array">[]</span> <span class="i">s</span></span>, <span class="o "><span class="k">ref</span> <span class="t Identifier"><span class="i">size_t</span></span> <span class="i">idx</span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span>
    <span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">idx</span></span> &gt;= <span class="e Int"><span class="n">0</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">idx</span></span> &lt; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>)</span>;</span>
    }</span>
    <span class="k">out</span> (<span class="i">result</span>)
    <span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">isValidDchar</span></span>(<span class="i">result</span>)</span>)</span>;</span>
    }</span>
    <span class="k">body</span>
    <span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">msg</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">V</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">i</span> = <span class="e Identifier"><span class="i">idx</span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">u</span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>;</span></span>

        <span class="s If"><span class="k">if</span> (<span class="e And"><span class="e Identifier"><span class="i">u</span></span> &amp; <span class="e Comp">~<span class="e Int"><span class="n">0x7F</span></span></span></span>)
        <span class="s Scope"><span class="s Compound">{   <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">u</span></span> &gt;= <span class="e Int"><span class="n">0xD800</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">u</span></span> &lt;= <span class="e Int"><span class="n">0xDBFF</span></span></span></span>)
            <span class="s Scope"><span class="s Compound">{   <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">u2</span>;</span></span>

                <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Plus"><span class="e Identifier"><span class="i">i</span></span> + <span class="e Int"><span class="n">1</span></span></span> == <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
                <span class="s Scope"><span class="s Compound">{   <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">msg</span></span> = <span class="e String"><span class="sl">"surrogate UTF-16 high value past end of string"</span></span></span>;</span>
                    <span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span>
                }</span></span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">u2</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">i</span></span> + <span class="e Int"><span class="n">1</span></span></span>]</span></span>;</span>
                <span class="s If"><span class="k">if</span> (<span class="e OrOr"><span class="e Rel"><span class="e Identifier"><span class="i">u2</span></span> &lt; <span class="e Int"><span class="n">0xDC00</span></span></span> || <span class="e Rel"><span class="e Identifier"><span class="i">u2</span></span> &gt; <span class="e Int"><span class="n">0xDFFF</span></span></span></span>)
                <span class="s Scope"><span class="s Compound">{   <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">msg</span></span> = <span class="e String"><span class="sl">"surrogate UTF-16 low value out of range"</span></span></span>;</span>
                    <span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span>
                }</span></span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">u</span></span> = <span class="e Plus"><span class="e Paren">(<span class="e LShift"><span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">u</span></span> - <span class="e Int"><span class="n">0xD7C0</span></span></span>)</span> &lt;&lt; <span class="e Int"><span class="n">10</span></span></span>)</span> + <span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">u2</span></span> - <span class="e Int"><span class="n">0xDC00</span></span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">i</span></span> += <span class="e Int"><span class="n">2</span></span></span>;</span>
            }</span></span>
            <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">u</span></span> &gt;= <span class="e Int"><span class="n">0xDC00</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">u</span></span> &lt;= <span class="e Int"><span class="n">0xDFFF</span></span></span></span>)
            <span class="s Scope"><span class="s Compound">{   <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">msg</span></span> = <span class="e String"><span class="sl">"unpaired surrogate UTF-16 value"</span></span></span>;</span>
                <span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span>
            }</span></span>
            <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e OrOr"><span class="e Equal"><span class="e Identifier"><span class="i">u</span></span> == <span class="e Int"><span class="n">0xFFFE</span></span></span> || <span class="e Equal"><span class="e Identifier"><span class="i">u</span></span> == <span class="e Int"><span class="n">0xFFFF</span></span></span></span>)
            <span class="s Scope"><span class="s Compound">{   <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">msg</span></span> = <span class="e String"><span class="sl">"illegal UTF-16 value"</span></span></span>;</span>
                <span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span>
            }</span></span>
            <span class="k">else</span>
                <span class="s Scope"><span class="s Expression"><span class="e PostIncr"><span class="e Identifier"><span class="i">i</span></span>++</span>;</span></span></span></span></span></span></span>
        }</span></span>
        <span class="k">else</span>
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e PostIncr"><span class="e Identifier"><span class="i">i</span></span>++</span>;</span>
        }</span></span></span>

        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">idx</span></span> = <span class="e Identifier"><span class="i">i</span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">dchar</span></span>)<span class="e Identifier"><span class="i">u</span></span></span>;</span>

      <span class="s Labeled"><span class="i">Lerr</span>:
        <span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">UtfException</span></span>(<span class="e Identifier"><span class="i">msg</span></span>.<span class="e Identifier"><span class="i">idup</span></span>, <span class="e Identifier"><span class="i">i</span></span>)</span>;</span></span>
    }</span></span></span>

<span class="bc">/*  ditto */</span>

<span class="d Function"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">decode</span><span class="o ">(<span class="o "><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">dchar</span></span>)</span><span class="t Array">[]</span> <span class="i">s</span></span>, <span class="o "><span class="k">ref</span> <span class="t Identifier"><span class="i">size_t</span></span> <span class="i">idx</span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span>
    <span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">idx</span></span> &gt;= <span class="e Int"><span class="n">0</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">idx</span></span> &lt; <span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>)</span>;</span>
    }</span>
    <span class="k">body</span>
    <span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">i</span> = <span class="e Identifier"><span class="i">idx</span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">dchar</span></span> <span class="i">c</span> = <span class="e Index"><span class="e Identifier"><span class="i">s</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>;</span></span>

        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">isValidDchar</span></span></span>(<span class="i">c</span>)</span>)
            <span class="s Scope"><span class="s Goto"><span class="k">goto</span> <span class="i">Lerr</span>;</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">idx</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">i</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">c</span></span>;</span>

      <span class="s Labeled"><span class="i">Lerr</span>:
        <span class="s Throw"><span class="k">throw</span> <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">UtfException</span></span>(<span class="e String"><span class="sl">"5invalid UTF-32 value"</span></span>, <span class="e Identifier"><span class="i">i</span></span>)</span>;</span></span>
    }</span></span></span>



<span class="bc">/* =================== Encode ======================= */</span>

<span class="bc">/* *****************************
 * Encodes character c and appends it to array s[].
 */</span>

<span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">encode</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">s</span></span>, <span class="o "><span class="t Integral"><span class="k">dchar</span></span> <span class="i">c</span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span>
    <span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">isValidDchar</span></span>(<span class="i">c</span>)</span>)</span>;</span>
    }</span>
    <span class="k">body</span>
    <span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span>)</span><span class="t Array">[]</span> <span class="i">r</span> = <span class="e Identifier"><span class="i">s</span></span>;</span></span>

        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Int"><span class="n">0x7F</span></span></span>)
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">r</span></span> ~= <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">char</span></span>) <span class="e Identifier"><span class="i">c</span></span></span></span>;</span>
        }</span></span>
        <span class="k">else</span>
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">char</span></span><span class="t Array">[<span class="e Int"><span class="n">4</span></span>]</span> <span class="i">buf</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">L</span>;</span></span>

            <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Int"><span class="n">0x7FF</span></span></span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">char</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Int"><span class="n">0xC0</span></span> | <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span> &gt;&gt; <span class="e Int"><span class="n">6</span></span></span>)</span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">char</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Int"><span class="n">0x80</span></span> | <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">c</span></span> &amp; <span class="e Int"><span class="n">0x3F</span></span></span>)</span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">L</span></span> = <span class="e Int"><span class="n">2</span></span></span>;</span>
            }</span></span>
            <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Int"><span class="n">0xFFFF</span></span></span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">char</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Int"><span class="n">0xE0</span></span> | <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span> &gt;&gt; <span class="e Int"><span class="n">12</span></span></span>)</span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">char</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Int"><span class="n">0x80</span></span> | <span class="e Paren">(<span class="e And"><span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span> &gt;&gt; <span class="e Int"><span class="n">6</span></span></span>)</span> &amp; <span class="e Int"><span class="n">0x3F</span></span></span>)</span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">char</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Int"><span class="n">0x80</span></span> | <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">c</span></span> &amp; <span class="e Int"><span class="n">0x3F</span></span></span>)</span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">L</span></span> = <span class="e Int"><span class="n">3</span></span></span>;</span>
            }</span></span>
            <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Int"><span class="n">0x10FFFF</span></span></span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">char</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Int"><span class="n">0xF0</span></span> | <span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span> &gt;&gt; <span class="e Int"><span class="n">18</span></span></span>)</span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">char</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Int"><span class="n">0x80</span></span> | <span class="e Paren">(<span class="e And"><span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span> &gt;&gt; <span class="e Int"><span class="n">12</span></span></span>)</span> &amp; <span class="e Int"><span class="n">0x3F</span></span></span>)</span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">char</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Int"><span class="n">0x80</span></span> | <span class="e Paren">(<span class="e And"><span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">c</span></span> &gt;&gt; <span class="e Int"><span class="n">6</span></span></span>)</span> &amp; <span class="e Int"><span class="n">0x3F</span></span></span>)</span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">3</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">char</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Int"><span class="n">0x80</span></span> | <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">c</span></span> &amp; <span class="e Int"><span class="n">0x3F</span></span></span>)</span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">L</span></span> = <span class="e Int"><span class="n">4</span></span></span>;</span>
            }</span></span>
            <span class="k">else</span>
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>)</span>;</span>
            }</span></span></span></span></span></span></span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">r</span></span> ~= <span class="e Slice"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">L</span></span>]</span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span> = <span class="e Identifier"><span class="i">r</span></span></span>;</span>
    }</span></span></span>

<span class="bc">/*  ditto */</span>

<span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">encode</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">wchar</span></span>)</span><span class="t Array">[]</span> <span class="i">s</span></span>, <span class="o "><span class="t Integral"><span class="k">dchar</span></span> <span class="i">c</span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span>
    <span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">isValidDchar</span></span>(<span class="i">c</span>)</span>)</span>;</span>
    }</span>
    <span class="k">body</span>
    <span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">wchar</span></span>)</span><span class="t Array">[]</span> <span class="i">r</span> = <span class="e Identifier"><span class="i">s</span></span>;</span></span>

        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">c</span></span> &lt;= <span class="e Int"><span class="n">0xFFFF</span></span></span>)
        <span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">r</span></span> ~= <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">wchar</span></span>) <span class="e Identifier"><span class="i">c</span></span></span></span>;</span>
        }</span></span>
        <span class="k">else</span>
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">wchar</span></span><span class="t Array">[<span class="e Int"><span class="n">2</span></span>]</span> <span class="i">buf</span>;</span></span>

            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">wchar</span></span>) <span class="e Paren">(<span class="e Plus"><span class="e Paren">(<span class="e And"><span class="e Paren">(<span class="e RShift"><span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">c</span></span> - <span class="e Int"><span class="n">0x10000</span></span></span>)</span> &gt;&gt; <span class="e Int"><span class="n">10</span></span></span>)</span> &amp; <span class="e Int"><span class="n">0x3FF</span></span></span>)</span> + <span class="e Int"><span class="n">0xD800</span></span></span>)</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">buf</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">wchar</span></span>) <span class="e Paren">(<span class="e Plus"><span class="e Paren">(<span class="e And"><span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">c</span></span> - <span class="e Int"><span class="n">0x10000</span></span></span>)</span> &amp; <span class="e Int"><span class="n">0x3FF</span></span></span>)</span> + <span class="e Int"><span class="n">0xDC00</span></span></span>)</span></span></span>;</span>
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">r</span></span> ~= <span class="e Identifier"><span class="i">buf</span></span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span> = <span class="e Identifier"><span class="i">r</span></span></span>;</span>
    }</span></span></span>

<span class="bc">/*  ditto */</span>

<span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">encode</span><span class="o ">(<span class="o "><span class="k">ref</span> <span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">dchar</span></span>)</span><span class="t Array">[]</span> <span class="i">s</span></span>, <span class="o "><span class="t Integral"><span class="k">dchar</span></span> <span class="i">c</span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span>
    <span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">isValidDchar</span></span>(<span class="i">c</span>)</span>)</span>;</span>
    }</span>
    <span class="k">body</span>
    <span class="s Compound">{
        <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">s</span></span> ~= <span class="e Identifier"><span class="i">c</span></span></span>;</span>
    }</span></span></span>

<span class="d Debug"><span class="k">debug</span>(<span class="i">UnitTest</span>)
<span class="d Compound">{
    <span class="d Unittest"><span class="k">unittest</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="lc">// match a fixed string</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Regex</span></span> <span class="i">r</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Regex</span></span>(<span class="e String"><span class="sl">"abc"</span></span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"abc123"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"feabc123"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">r</span></span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"abe123"</span>)</span>)</span>;</span>

        <span class="lc">// match a non-ASCII string</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Regex</span></span>(<span class="e String"><span class="sl">""</span></span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"ac123"</span>)</span>)</span>;</span>

        <span class="lc">// capture</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Regex</span></span>(<span class="e String"><span class="sl">"(c)"</span></span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"ac123"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">match</span></span>(<span class="n">1</span>)</span> == <span class="e String"><span class="sl">"c"</span></span></span>)</span>;</span>

        <span class="lc">// dot</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Regex</span></span>(<span class="e String"><span class="sl">".."</span></span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"ac123"</span>)</span>)</span>;</span>

        <span class="lc">// dot capture</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Regex</span></span>(<span class="e String"><span class="sl">"(..)"</span></span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"ac123"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">match</span></span>(<span class="n">1</span>)</span> == <span class="e String"><span class="sl">"a"</span></span></span>)</span>;</span>



        <span class="lc">// two captures</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Regex</span></span>(<span class="e String"><span class="sl">"(.)(.)"</span></span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"ac123"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">match</span></span>(<span class="n">1</span>)</span> == <span class="e String"><span class="sl">"a"</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">match</span></span>(<span class="n">2</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>

        <span class="lc">// multiple letters</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Regex</span></span>(<span class="e String"><span class="sl">".*(e+).*"</span></span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"aeeeeec123"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">match</span></span>(<span class="n">1</span>)</span> == <span class="e String"><span class="sl">"eeeee"</span></span></span>, <span class="e Cat"><span class="e String"><span class="sl">"Expected: eeeee Got: "</span></span> ~ <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">match</span></span>(<span class="n">1</span>)</span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">r</span></span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"abfua"</span>)</span>)</span>;</span>

        <span class="lc">// multiple snowmen</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Regex</span></span>(<span class="e String"><span class="sl">".*(+).*"</span></span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"ac123"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">match</span></span>(<span class="n">1</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>, <span class="e Cat"><span class="e String"><span class="sl">"Expected:  Got: "</span></span> ~ <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">match</span></span>(<span class="n">1</span>)</span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">r</span></span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"abeua"</span>)</span>)</span>;</span>

        <span class="bc">/**
           "*" quantifier bug. In "(+)" pattern test ((r.match(0) == "")&amp;&amp;(r.match(1) == "")) has passed.
        */</span>
        <span class="lc">// multiple snowmen</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Regex</span></span>(<span class="e String"><span class="sl">"(+)"</span></span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"ac123"</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">match</span></span>(<span class="n">0</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">match</span></span>(<span class="n">1</span>)</span> == <span class="e String"><span class="sl">""</span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">test</span></span>(<span class="sl">"abeua"</span>)</span>)</span>;</span>
    }</span></span></span>

    <span class="d Debug"><span class="k">debug</span>(<span class="i">RegexTestOnly</span>)
    <span class="d Compound">{
        <span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">io</span>.<span class="i">Stdout</span>;</span>
        <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">main</span><span class="o ">()</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Expression"><span class="e Call"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"All tests pass"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>()</span>;</span> }</span></span></span>
    }</span></span>
}</span></span></span>

</pre></td>
</tr></table>
</body>
</html>